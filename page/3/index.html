<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 一派胡言</title><meta name="description" content="我向往安静且自由的生活"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://threezj.com/atom.xml" title="一派胡言"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="https://github.com/zyycj" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/06/25/Tomcat 架构探索/" class="post-title-link">Tomcat 架构探索</a></h2><div class="post-info">2016年6月25日</div><div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>花了一个礼拜的时间阅读了 <code>how tomcat works</code>，本文基于此书，整理了一下<code>Tomcat 5</code>的基本架构，其实也没什么多复杂的东西，无非是解析<code>Http</code>请求，然后调用相应的<code>Servlet</code>。另推荐看<code>CSAPP</code>的网络编程那一章</p>
<h2 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h2><p><code>Tomcat</code>由两个模块协同合作</p>
<ul>
<li><code>connector</code></li>
<li><code>container</code></li>
</ul>
<p><code>connector</code> 负责解析处理<code>HTTP</code>请求，比如说<code>请求头</code>,<code>查询字符串</code>,<code>请求参数</code>之类的。生成<code>HttpRequest</code>和<code>HttpResponse</code><br>之后交给<code>container</code>，由它负责调用相应的<code>Servlet</code>。<br></div><a href="/2016/06/25/Tomcat 架构探索/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/05/04/CSAPP Cache 详细解析/" class="post-title-link">CSAPP Cache 详细解析</a></h2><div class="post-info">2016年5月4日</div><div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>又要来推荐<code>CSAPP</code>这本书啦。很多同学可能写了这么久代码，计算机的基本工作方式都不太懂，看这本书会给你一种融会贯通的感觉，小到二进制位级操作，大到手撸web服务器。</p>
<p>今天主要整理下<code>Cache</code>的运行机制。</p>
<h2 id="什么是Cache"><a href="#什么是Cache" class="headerlink" title="什么是Cache"></a>什么是<code>Cache</code></h2><p>编程说到底其实就是对数据的操作。<code>CPU</code>通过各种总线从读取数据，放入<code>ALU(运算器)</code>进行运算，然后再把数据放回主存中。下面是一个简单的示意图。</p>
<p><img src="http://7xrsib.com1.z0.glb.clouddn.com/QQ%E6%88%AA%E5%9C%9620160503224541.jpg" alt=""></p>
<p>很明显。数据运输过程的时间，就是性能的提现。没有数据<code>CPU</code>只能在那里等待.所以为了加快主存到<code>CPU</code>的速度，系统设计者采取了存储设备分层的结构.</p>
<p><code>Cache</code>又称为<code>高速缓存存储器</code>，是一种非常小非常快的存储器，同时也非常贵，放在<code>CPU</code>和<code>主存</code>之间，相当于中介的存在，每当<code>CPU</code>取数据的时候总是先从<code>Cache</code>中找，如果<code>Cache</code>没有，再到<code>主存</code>找。</p>
<p><code>CPU</code>和<code>主存</code>直接会放置多个<code>Cache</code>，越靠近<code>CPU</code>则越小越快越贵。</p>
<p><img src="http://7xrsib.com1.z0.glb.clouddn.com/QQ%E6%88%AA%E5%9C%9620160503230817.jpg" alt=""><br></div><a href="/2016/05/04/CSAPP Cache 详细解析/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/05/02/最短路径算法总结/" class="post-title-link">最短路径算法总结</a></h2><div class="post-info">2016年5月2日</div><div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>因为我在跟<code>Robert Sedgewick</code>的<code>Algorithms</code>，所以本文和前面几篇算法文章一样，都是基于这门课的梳理总结，并加以自己理解，这种学习方式其实效率还挺高的。</p>
<h2 id="最短路径算法"><a href="#最短路径算法" class="headerlink" title="最短路径算法"></a>最短路径算法</h2><p>最短路径问题有多种情况可以讨论</p>
<ul>
<li>给定起点的最短路径问题</li>
<li>给定终点的最短路径问题</li>
<li>给定起点和终点的最短路径，也就是求任意两点之间的最短路径问题</li>
</ul>
<p>本文只讨论<code>单源起点问题</code>，有如下三个算法可以解决这个问题。</p>
<ul>
<li><code>Dijkstra</code>            //适用于无负权重</li>
<li><code>Topological sort</code>    //适用于无环</li>
<li><code>Bellman-Ford</code>        //适用于无负环<a id="more"></a></li>
</ul></div><a href="/2016/05/02/最短路径算法总结/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/04/24/最小生成树,Prim和Kruskal详细学习笔记/" class="post-title-link">最小生成树,Prim和Kruskal详细学习笔记</a></h2><div class="post-info">2016年4月24日</div><div class="post-content"><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>最小生成树是一副连通加权无向图中一棵权值最小的生成树。<br>最小生成树其实是<strong>最小权重生成树</strong>的简称。</p>
</blockquote>
<p>可能翻译为<code>最小权重生成树</code>更容易理解一些。意思就是说在图中的每条边都加上权值，所谓权值是一种抽象的含义。可以指代一切可以量化的东西。比如说修路的费用，路程等等。然后在图中找到这样一棵树，边的权值加起来最小。并且既然是棵树，必须满足的要求是无环.</p>
<p>一般用两种贪心算法来找到最小生成树，分别是<code>prim</code>和<code>Kruskal</code><br></div><a href="/2016/04/24/最小生成树,Prim和Kruskal详细学习笔记/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/04/15/推荐一门CMU公开课/" class="post-title-link">推荐一门CMU公开课</a></h2><div class="post-info">2016年4月15日</div><div class="post-content"></div><a href="/2016/04/15/推荐一门CMU公开课/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/03/28/用拉链法和线性探测法解决哈希冲突/" class="post-title-link">用拉链法和线性探测法解决哈希冲突</a></h2><div class="post-info">2016年3月28日</div><div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面学习到的几种算法比如<code>红黑树</code>，<code>二叉搜索树</code>，查找插入<code>时间复杂度</code>最快也只能到<code>O(logn)</code>.现在介绍一种算法可以使查找插入<code>时间复杂度</code>达到常数级别。</p>
<h2 id="散列表-Hash-table"><a href="#散列表-Hash-table" class="headerlink" title="散列表(Hash table)"></a>散列表(Hash table)</h2><p>也称为<code>哈希表</code>。是字典的一种抽象。比如说你要查一个字，通过这个字的拼音首字母，找到这个字的页码，然后翻到那页找就行了。这种方法直接把查找<code>时间复杂度</code>降到了常数。但是要牺牲一定的计算索引的时间。计算索引的那个函数称为<code>哈希函数</code>(<code>散列函数`</code>)。如果两个不同的<code>key</code>算出了同一个索引，此时就要用到一定的方法来解决哈希冲突。<br></div><a href="/2016/03/28/用拉链法和线性探测法解决哈希冲突/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/03/20/查找算法之顺序、二分、二叉搜索树、红黑树 详细比较总结/" class="post-title-link">查找算法之顺序、二分、二叉搜索树、红黑树 详细比较总结</a></h2><div class="post-info">2016年3月20日</div><div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一般用<code>符号表</code>来储存键值对，就好像字典那样，通过索引来查找值，若键重复则覆盖值。我们能希望找到一种高效的查找算法使在平均情况和最差情况下，时间复杂度都能达到<code>O(logn)</code>。下面会逐步介绍四种算法，最终达到我们的目的。</p>
<h2 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h2><p>用链表实现，无法索引数据，必须遍历找数据，速度比较慢，查找插入时间复杂度都为<code>O(n)</code>，而且无法保证有序。但是实现简单，适用于小型数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SequentialSearchST</span>&lt;<span class="title">Key</span>,<span class="title">Value</span>&gt;  </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key,Value v)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Node p=head;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.key.equals(key))&#123;</span><br><span class="line">                p.v=v;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p=p.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        head=<span class="keyword">new</span> Node(key,v,head);</span><br><span class="line">        size++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        Node p=head;</span><br><span class="line">        <span class="keyword">while</span> (p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.key.equals(key))&#123;</span><br><span class="line">                <span class="keyword">return</span>  p.v;</span><br><span class="line">            &#125;</span><br><span class="line">            p=p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><a href="/2016/03/20/查找算法之顺序、二分、二叉搜索树、红黑树 详细比较总结/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/03/16/复杂排序之归并、快速、三向切分、堆排序 详细总结/" class="post-title-link">复杂排序之归并、快速、三向切分、堆排序 详细总结</a></h2><div class="post-info">2016年3月16日</div><div class="post-content"><h2 id="归并排序-MergeSort"><a href="#归并排序-MergeSort" class="headerlink" title="归并排序(MergeSort)"></a>归并排序(MergeSort)</h2><p>复杂度<code>O(nlogn)</code>.</p>
<p>核心思想就是采用分而治之的方法，递归的合并两个有序的数组。效率比较高，缺点是空间复杂度高，会用到额外的数组。</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>核心代码是合并的函数。合并的前提是保证左右两边的数组分别有序，在合并之前和之后在<code>Java</code>中我们可以用断言来保证数组有序。</p>
<p>合并的原理其实也很简单，先把<code>a</code>数组中的内容复制到额外储存的<code>temp</code>数组中去。分别用两个<code>index</code>指向<code>a</code>数组的起始位置和中间位置，保证<code>a</code>数组左右两边有序，比如<code>i</code>，<code>j</code>。现在开始从头扫描比较左右两个数组,若<code>a[i]&amp;lt;=a[j]</code>，则把<code>a[i]</code>放到<code>temp</code>数组中去，且<code>i</code>向前走一步。反正则放<code>a[j]</code>，且<code>j</code>走一步。若其中一个数组走完了，则把另一个数组剩余的数直接放到temp数组中。</p>
<p>我们用递归的方式来实现左右两边有序。递归到数组只有1个数时肯定是有序的，再合并2个数，再退出来合并4个数，以此类推。</p>
<p><img src="http://7xrsib.com1.z0.glb.clouddn.com/sortMerge-sort-example-300px.gif" alt=""></p>
<p><img src="http://7xrsib.com1.z0.glb.clouddn.com/sortQQ%E6%88%AA%E5%9C%9620160316182738.jpg" alt=""><br></div><a href="/2016/03/16/复杂排序之归并、快速、三向切分、堆排序 详细总结/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/03/13/简单排序之冒泡、选择、插入、希尔详细总结/" class="post-title-link">简单排序之冒泡、选择、插入、希尔详细总结</a></h2><div class="post-info">2016年3月13日</div><div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文讲述一些简单算法的实现和效率比较。所有代码用<code>java</code>实现。用到的两个基本的<code>api</code>代码如下。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable v,Comparable w)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v.compareTo(w) &lt;<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(Comparable[] a,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    Comparable temp = a[i];</span><br><span class="line">    a[i] = a[j];</span><br><span class="line">    a[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></div><a href="/2016/03/13/简单排序之冒泡、选择、插入、希尔详细总结/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/03/12/Union-Find/" class="post-title-link">Union-Find</a></h2><div class="post-info">2016年3月12日</div><div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>开始刷<code>Coursera</code>的<code>Algorithms</code>课，在此尽量为每个<code>Lectures</code>写篇笔记。</p>
<h2 id="Union-Find"><a href="#Union-Find" class="headerlink" title="Union-Find"></a>Union-Find</h2><p>并查集，顾名思义，主要两个操作。</p>
<ul>
<li><code>union</code>  合并两个集合</li>
<li><code>find</code>   查询两个对象是否属于一个集合</li>
</ul>
<p>一个集合称为<code>Connected components</code>.</p>
<p><img src="http://7xrsib.com1.z0.glb.clouddn.com/union-find2.jpg" alt=""><br></div><a href="/2016/03/12/Union-Find/" class="read-more">...阅读全文</a></article></li></ul></main><footer><div class="paginator"><a href="/page/2/" class="prev">上一页</a><a href="/page/4/" class="next">下一页</a></div><div class="copyright"><p>© 2015 - 2018 <a href="http://threezj.com">Jian Zhang</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>