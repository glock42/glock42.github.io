<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 一派胡言</title><meta name="description" content="我向往安静且自由的生活"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://threezj.com/atom.xml" title="一派胡言"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="https://github.com/zyycj" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/11/14/MIT 6.828 lab2/" class="post-title-link">MIT 6.828 lab2</a></h2><div class="post-info">2016年11月14日</div><div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这个<code>lab</code>主要是写内存管理相关的代码。实现操作系统必须满足三个要求<code>multiplexing, isolation, and interaction</code> 。翻译成中文就是<code>复用，隔离和相互作用</code>。这三个条件其实主要靠抽象完成。<code>复用</code> 比如<code>IO</code>读写，都对文件描述符进行处理，而不管底下是网络读写还是磁盘读写等。<code>隔离</code>抽象地址空间，每个进程拥有一个自己的地址空间，相互并不影响。<code>相互作用</code>也需要抽象的控制，防止一些恶意的软件。</p>
<p><code>lab2</code>关注点在于如何实现地址空间。<code>jos</code>通过实现分页管理来实现。操作系统中所有程序接触的地址都是虚拟地址，然后硬件上真正需要的则是物理地址，所以中间则是使用<code>MMU(memory management unit)</code>来把虚拟地址翻译为物理地址。</p>
<h2 id="连续的内存分配"><a href="#连续的内存分配" class="headerlink" title="连续的内存分配"></a>连续的内存分配</h2><p>早期操作系统都是直接操作物理地址，很明显，这样做有着致命的缺点。比如用户程序可以直接访问<code>kernel</code>地址，导致系统崩溃，多个用户程序程序直接相互影响。即使设立了保护机制，也就是通过一些<code>flag</code>来辨别是否可以访问，但还是会有问题。就是当两个进程同时载入内存时，会进行地址偏移，跳转到指令并不会是程序中原先的指令，此时需要进行<code>重定位</code>，就是扫描一遍程序，给程序中涉及到的地址加上偏移量。但是这种方法效率是很低的。需要为每个需要执行的程序进行扫描判定计算。</p>
<h4 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h4><p>所以这里我们提出了<code>地址空间</code>的概念。重点还是抽象。我门让每个进程处于独立的进程空间中。比如虽然两个进程都指向同一个虚拟地址，但是实际所指的物理地址是不同的。</p>
<h4 id="基地寄存器和界限寄存器"><a href="#基地寄存器和界限寄存器" class="headerlink" title="基地寄存器和界限寄存器"></a>基地寄存器和界限寄存器</h4><p>其实就是动态重定位。把重定位的时间推迟了，之前的重定位一般发生在加载时，而现在推迟到访问内存时，并且减少了扫描查找的时间。通过两个寄存器来保存进程的起始地址和进程使用空间的长度。当程序访问内存时，自动加上偏移量，如果超出界限，则产生错误。但这种方法还是不够快，需要进行计算，比较可以进行的很快，但计算不行。进行动态重定位之后地址称为<code>线性地址</code><br></div><a href="/2016/11/14/MIT 6.828 lab2/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/11/06/MIT 6.828 lab1/" class="post-title-link">MIT 6.828 lab1</a></h2><div class="post-info">2016年11月6日</div><div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>开启一场漫长且有趣的旅程，即日起开始学习<code>MIT 6.828</code>。总共有七个<code>lab</code>。<code>lab6</code>和<code>lab7</code>其中选一个做。</p>
<h2 id="PC启动流程简述"><a href="#PC启动流程简述" class="headerlink" title="PC启动流程简述"></a>PC启动流程简述</h2><p>先了解一下当<code>PC</code>加电后，整个物理地址空间分布。</p>
<p><img src="http://7xrsib.com1.z0.glb.clouddn.com/2016-11-03%2020-55-37%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p>
<p>早期的<code>16位</code>计算机是只有<code>1MB</code>的寻址能力。也就是说只能使用<code>0x0000 - 0xffff</code>这么多，如上图所示，<code>640kb</code>以下的部分为早期计算机使用的部分。而上面<code>640kb - 1mb</code>的这些地方则保留下来作为特殊使用，比如视频显示之类的。其中最重要的部分为<code>BIOS( Basic Input/Output System)</code>，<code>BIOS</code>的主要责任为进行一些自检，然后从启动设备中，并载入它的第一扇区到内存的特定位置，即<code>0x7c00</code>，然后跳转到这个位置继续执行。此时，<code>BIOS</code>的工作完成。<code>0x7c00</code> 即是<code>bootloader</code>的入口点。</p>
<p>当现代计算机突破了<code>1MB</code>内存，达到<code>4GB</code>甚至更多的时候，依然保留了最开始的<code>1M</code>内存空间。所以开始一开始加电以后，是处于实模式的，也就是只有<code>1MB</code>内存可以访问。<code>bootloader</code>会把实模式切换到保护模式。也就是<code>4GB</code>寻址模式。然后再读取<code>kernel</code>到内存中，并且把控制权转给<code>kernel</code>。至此操作系统才算真正的启动起来。</p>
<p>下面简单总结下启动流程。</p>
<ol>
<li><code>PC</code>启动，并且执行第一条指令，位于<code>0xffff0</code>。是一条跳转指令，跳到<code>BIOS</code>刚开始的地方</li>
<li><code>BIOS</code> 进行初始化。</li>
<li><code>BIOS</code>搜寻启动设备，并加载<code>bootloader</code>到内存中，转移控制给<code>bootloader</code></li>
<li><code>bootloader</code>从实模式切换到保护模式</li>
<li><code>bootloader</code>从硬盘中读取<code>kernel</code>到内存中，并转移控制给<code>kernel</code></li>
<li>操作系统启动</div><a href="/2016/11/06/MIT 6.828 lab1/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/10/30/生成学习算法/" class="post-title-link">生成学习算法</a></h2><div class="post-info">2016年10月30日</div><div class="post-content"><h2 id="生成学习算法"><a href="#生成学习算法" class="headerlink" title="生成学习算法"></a>生成学习算法</h2><p>可能大部分人之前学过的分类算法，都是基于<code>train data</code>来最佳化参数，从而得到<code>data</code>的类别。也就是基于<code>p(y|x; θ)</code>来进行学习，比如<code>Logistic Regression</code>。现在我们换一种思路，反过来求解，分别对<code>p(x|y)</code> 求解，也就是说，对每一个<code>y</code>，<code>model</code>一个概率模型。当需要对新的<code>data</code>分类时，分别计算属于每个类的概率，从而得到最优的类别。公式基于贝叶斯定理,如下所示。</p>
<p><img src="http://7xrsib.com1.z0.glb.clouddn.com/2016-10-29%2023-45-27%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""><br></div><a href="/2016/10/30/生成学习算法/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/10/12/我对于动态规划的理解/" class="post-title-link">我对于动态规划的理解</a></h2><div class="post-info">2016年10月12日</div><div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>动态规划很早就接触过了，但一直都心存疑惑。网上的一些文章，基本都是满篇术语。<code>状态转移</code>， <code>状态方程</code>，这种名词，其实是让初学者比较迷惑。直到我上完<code>Berkeley</code>的<a href="http://cs61a.org/" target="_blank" rel="noopener">CS 61 A</a>, 突然就理解了所谓的动态规划。或者说是真正的理解了递归。把玩函数式语言对理解递归，或者说程序结构，非常有帮助。<a href="https://www.amazon.cn/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E8%A7%A3%E9%87%8A/dp/B0011AP7RY/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1476242304&amp;sr=1-1&amp;keywords=SICP" target="_blank" rel="noopener">SICP</a> 这本书已经很多人推荐了，用<code>Scheme</code>讲的，我没看完，看了大概前面两章。我比较推荐的是<code>华盛顿大学</code>的<a href="http://courses.cs.washington.edu/courses/cse341/16sp/" target="_blank" rel="noopener">Programming Languages</a> 还有上面<code>Berkeley</code>那门课。</p>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>我认为所谓的动态规划，就是递归的记忆化过程。这里必须要提一个函数式语言的好处，支持<code>尾递归</code>。<code>尾递归</code>可以用来防止重复计算。可惜很多语言并不支持，很容易就栈溢出了，比如<code>JAVA</code> ，<code>Python</code>。所以需要把递归改写成循环形式。其实本质还是和尾递归一样。<br></div><a href="/2016/10/12/我对于动态规划的理解/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/09/27/MIT 6.824 lab1/" class="post-title-link">MIT 6.824 lab1</a></h2><div class="post-info">2016年9月27日</div><div class="post-content"></div><a href="/2016/09/27/MIT 6.824 lab1/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/07/28/进程与线程/" class="post-title-link">进程与线程</a></h2><div class="post-info">2016年7月28日</div><div class="post-content"><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><blockquote>
<p>进程是一个程序的实例</p>
</blockquote>
<p>上面是最基本进程定义。就好比说当你双击<code>txt</code>文件，就开启了一个进程运行文本编辑器。当你再双击一下，就又开启了一个进程。这两个进程互不干扰，一个进程关闭或者崩溃，并不会导致另一个进程关闭。但是这两个进程拥有一个通信的接口，就是那个<code>txt</code>文件。这两个文本编辑器使用的同一个文件，这就又引申出另一个问题，进程间通信<code>(IPC)</code>.</p>
<p>在举个例子程序是一系列指令的集合，就好比一个类，进程则是真正在执行这些指令的东西，就好比对象。</p>
<h4 id="进程的特点"><a href="#进程的特点" class="headerlink" title="进程的特点"></a>进程的特点</h4><p>进程拥有一个独立的执行环境。进程之间互不干扰。它拥有自己栈，堆，<code>code</code>，静态文本，完全自给自足。所以说一个进程拥有独立的地址空间以及一个或者多个线程。<br></div><a href="/2016/07/28/进程与线程/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/07/27/为什么机器可以学习？/" class="post-title-link">为什么机器学习真的可以学到东西？</a></h2><div class="post-info">2016年7月27日</div><div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>开始跟《机器学习基石》这门课，相对于<code>Stanford</code>那门课，这门明显难度大很多，我跟到第10个<code>Lecture</code>，才刚刚讲到<code>Logistic Regression</code>。前面费了很大力气在讲机器什么时候可以学习，以及证明为什么能学习。</p>
<p>此文主要是基于《机器学习基石》的学习笔记。<code>Topic</code>是为什么机器可以学习？</p>
<h2 id="机器学习流程"><a href="#机器学习流程" class="headerlink" title="机器学习流程"></a>机器学习流程</h2><p>下面是一个粗略的机器学习流程图</p>
<p><img src="http://beader.me/mlnotebook/section2/images/basic_setup_of_the%20_learning_problem.png" alt=""></p>
<p>机器学习最开始也是最终的目的是获得一个<code>target function</code>，喂进去数据能直接得到正确结论的函数。为了得到这个函数，我们需要一大堆的训练数据。然后通过一个好的机器学习算法，从一大堆<code>可能的function(也就是H)</code>中挑选一个<code>比较好的function(也就是g)</code>，这个<code>g</code>和<code>target function</code>长得越像越好。<br></div><a href="/2016/07/27/为什么机器可以学习？/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/06/25/Tomcat 架构探索/" class="post-title-link">Tomcat 架构探索</a></h2><div class="post-info">2016年6月25日</div><div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>花了一个礼拜的时间阅读了 <code>how tomcat works</code>，本文基于此书，整理了一下<code>Tomcat 5</code>的基本架构，其实也没什么多复杂的东西，无非是解析<code>Http</code>请求，然后调用相应的<code>Servlet</code>。另推荐看<code>CSAPP</code>的网络编程那一章</p>
<h2 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h2><p><code>Tomcat</code>由两个模块协同合作</p>
<ul>
<li><code>connector</code></li>
<li><code>container</code></li>
</ul>
<p><code>connector</code> 负责解析处理<code>HTTP</code>请求，比如说<code>请求头</code>,<code>查询字符串</code>,<code>请求参数</code>之类的。生成<code>HttpRequest</code>和<code>HttpResponse</code><br>之后交给<code>container</code>，由它负责调用相应的<code>Servlet</code>。<br></div><a href="/2016/06/25/Tomcat 架构探索/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/05/04/CSAPP Cache 详细解析/" class="post-title-link">CSAPP Cache 详细解析</a></h2><div class="post-info">2016年5月4日</div><div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>又要来推荐<code>CSAPP</code>这本书啦。很多同学可能写了这么久代码，计算机的基本工作方式都不太懂，看这本书会给你一种融会贯通的感觉，小到二进制位级操作，大到手撸web服务器。</p>
<p>今天主要整理下<code>Cache</code>的运行机制。</p>
<h2 id="什么是Cache"><a href="#什么是Cache" class="headerlink" title="什么是Cache"></a>什么是<code>Cache</code></h2><p>编程说到底其实就是对数据的操作。<code>CPU</code>通过各种总线从读取数据，放入<code>ALU(运算器)</code>进行运算，然后再把数据放回主存中。下面是一个简单的示意图。</p>
<p><img src="http://7xrsib.com1.z0.glb.clouddn.com/QQ%E6%88%AA%E5%9C%9620160503224541.jpg" alt=""></p>
<p>很明显。数据运输过程的时间，就是性能的提现。没有数据<code>CPU</code>只能在那里等待.所以为了加快主存到<code>CPU</code>的速度，系统设计者采取了存储设备分层的结构.</p>
<p><code>Cache</code>又称为<code>高速缓存存储器</code>，是一种非常小非常快的存储器，同时也非常贵，放在<code>CPU</code>和<code>主存</code>之间，相当于中介的存在，每当<code>CPU</code>取数据的时候总是先从<code>Cache</code>中找，如果<code>Cache</code>没有，再到<code>主存</code>找。</p>
<p><code>CPU</code>和<code>主存</code>直接会放置多个<code>Cache</code>，越靠近<code>CPU</code>则越小越快越贵。</p>
<p><img src="http://7xrsib.com1.z0.glb.clouddn.com/QQ%E6%88%AA%E5%9C%9620160503230817.jpg" alt=""><br></div><a href="/2016/05/04/CSAPP Cache 详细解析/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/05/02/最短路径算法总结/" class="post-title-link">最短路径算法总结</a></h2><div class="post-info">2016年5月2日</div><div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>因为我在跟<code>Robert Sedgewick</code>的<code>Algorithms</code>，所以本文和前面几篇算法文章一样，都是基于这门课的梳理总结，并加以自己理解，这种学习方式其实效率还挺高的。</p>
<h2 id="最短路径算法"><a href="#最短路径算法" class="headerlink" title="最短路径算法"></a>最短路径算法</h2><p>最短路径问题有多种情况可以讨论</p>
<ul>
<li>给定起点的最短路径问题</li>
<li>给定终点的最短路径问题</li>
<li>给定起点和终点的最短路径，也就是求任意两点之间的最短路径问题</li>
</ul>
<p>本文只讨论<code>单源起点问题</code>，有如下三个算法可以解决这个问题。</p>
<ul>
<li><code>Dijkstra</code>            //适用于无负权重</li>
<li><code>Topological sort</code>    //适用于无环</li>
<li><code>Bellman-Ford</code>        //适用于无负环<a id="more"></a></li>
</ul></div><a href="/2016/05/02/最短路径算法总结/" class="read-more">...阅读全文</a></article></li></ul></main><footer><div class="paginator"><a href="/" class="prev">上一页</a><a href="/page/3/" class="next">下一页</a></div><div class="copyright"><p>© 2015 - 2018 <a href="http://threezj.com">Jian Zhang</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>