<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 一派胡言</title><meta name="description" content="我向往安静且自由的生活"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://threezj.com/atom.xml" title="一派胡言"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="https://github.com/zyycj" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/12/07/MIT 6.828 lab5/" class="post-title-link">MIT 6.828 lab5</a></h2><div class="post-info">2016年12月7日</div><div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>lab5</code>比较简单，相对于之前的<code>lab</code>来说。主要就是完成简单的文件系统。大部分代码<code>mit</code>都已经帮你搭好了。</p>
<h2 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise 1"></a>Exercise 1</h2><blockquote>
<p><code>i386_init</code> identifies the file system environment by passing the type <code>ENV_TYPE_FS</code> to your environment creation function, <code>env_create</code>. Modify <code>env_create</code> in env.c, so that it gives the file system environment I/O privilege, but never gives that privilege to any other environment</p>
</blockquote>
<p>启动<code>IO</code>驱动器，设置一下标志位即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(type == ENV_TYPE_FS)&#123;</span><br><span class="line">       e-&gt;env_tf.tf_eflags |= FL_IOPL_3;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="Question-1"><a href="#Question-1" class="headerlink" title="Question 1"></a>Question 1</h4><blockquote>
<p>Do you have to do anything else to ensure that this I/O privilege setting is saved and restored properly when you subsequently switch from one environment to another? Why?</p>
</blockquote>
<p>不需要。因为进程切换时会保存<code>Trapframe</code>。</p>
<h2 id="Exercise-2"><a href="#Exercise-2" class="headerlink" title="Exercise 2"></a>Exercise 2</h2><blockquote>
<p>Implement the <code>bc_pgfault</code> and <code>flush_block</code> functions in fs/bc.c. <code>bc_pgfault</code> is a page fault handler, just like the one your wrote in the previous lab for copy-on-write fork, except that its job is to load pages in from the disk in response to a page fault. When writing this, keep in mind that (1) <code>addr</code> may not be aligned to a block boundary and (2) <code>ide_read</code> operates in sectors, not blocks.</p>
</blockquote>
<p>我们用<code>3G</code>的内存地址来映射磁盘。从<code>DISKMAP</code>至<code>DISKMAP+DISKMAX</code>。但是不可能把整块磁盘的内容都加载到内存中来。所以我们采用类似于<code>COW</code>的方式，延迟到<code>page fault</code>时，再从磁盘中读取，这种方式抽象了整个磁盘都在内存中的假象，并且以有限的内存空间，支持更大的磁盘读取。</p>
<p><code>bc_pgfault</code> 当产生<code>page fault</code>，说明这一页还未读取到内存中，则先分配一页，然后进行读取。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">addr = ROUNDDOWN(addr, PGSIZE);</span><br><span class="line">   r = sys_page_alloc(<span class="number">0</span>, addr, PTE_P | PTE_U | PTE_W);</span><br><span class="line">   <span class="keyword">if</span>(r != <span class="number">0</span>)</span><br><span class="line">       panic(<span class="string">"bc.c: paga_alloc failed %e"</span>, r);</span><br><span class="line">   r = ide_read(blockno * BLKSECTS, addr, BLKSECTS);</span><br><span class="line">   <span class="keyword">if</span>(r != <span class="number">0</span>)</span><br><span class="line">       panic(<span class="string">"bc.c: ide_read failed %e"</span>, r);</span><br></pre></td></tr></table></figure>
<p><code>flush_block</code> 内存中的内容被修改之后，需要写回到磁盘中。因为本质上它就是一块<code>Cache</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flush_block</span><span class="params">(<span class="keyword">void</span> *addr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> blockno = ((<span class="keyword">uint32_t</span>)addr - DISKMAP) / BLKSIZE;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">if</span> (addr &lt; (<span class="keyword">void</span>*)DISKMAP || addr &gt;= (<span class="keyword">void</span>*)(DISKMAP + DISKSIZE))</span><br><span class="line">        panic(<span class="string">"flush_block of bad va %08x"</span>, addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(va_is_mapped(addr) &amp;&amp; va_is_dirty(addr)))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    addr = ROUNDDOWN(addr, PGSIZE);</span><br><span class="line">    <span class="keyword">if</span>(va_is_mapped(addr) &amp;&amp; va_is_dirty(addr))&#123;</span><br><span class="line">        r = ide_write(blockno * BLKSECTS, addr, BLKSECTS);</span><br><span class="line">        <span class="keyword">if</span>(r != <span class="number">0</span>)</span><br><span class="line">            panic(<span class="string">"flush_block: ide_write failed %e"</span>, r);</span><br><span class="line">        r = sys_page_map(<span class="number">0</span>, addr, <span class="number">0</span>, addr, uvpt[PGNUM(addr)] &amp; PTE_SYSCALL);</span><br><span class="line">        <span class="keyword">if</span>(r != <span class="number">0</span>)</span><br><span class="line">            panic(<span class="string">"flush_block: sys_page_map failed %e"</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><a href="/2016/12/07/MIT 6.828 lab5/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/12/02/MIT 6.828 lab4/" class="post-title-link">MIT 6.828 lab4</a></h2><div class="post-info">2016年12月2日</div><div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>lab4</code>终于完成了。<code>lab4</code>是到目前为止，比较复杂而且代码最多的<code>lab</code>。总共需要完成三个部分。<code>part A</code>添加多核支持，实现<code>RR</code>调度。<code>part B</code>实现<code>Copy-On-Write fork</code>。<code>part C</code> 实现时钟中断以及支持基本的<code>IPC</code>。</p>
<h2 id="Part-A"><a href="#Part-A" class="headerlink" title="Part A"></a>Part A</h2><h4 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise 1"></a>Exercise 1</h4><blockquote>
<p>Implement <code>mmio_map_region</code> in kern/pmap.c. To see how this is used, look at the beginning of <code>lapic_init</code> in kern/lapic.c. You’ll have to do the next exercise, too, before the tests for <code>mmio_map_region</code> will run.</p>
</blockquote>
<p>实现需要让<code>Jos</code>支持<code>symmetric multiprocessing</code>，也就是所有的<code>cpu</code>都拥有相同的权限去访问资源。<code>Jos</code>使用<code>LAPIC</code>来分发中断，以及通过它来知道当前使用的<code>cpu</code>。而处理器访问<code>LAPIC</code>，需要使用<code>MMIO</code>。所以我们需要对<code>MMIO</code>进行内存映射，这个函数比较简单。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line">mmio_map_region(<span class="keyword">physaddr_t</span> pa, <span class="keyword">size_t</span> size) &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">uintptr_t</span> base = MMIOBASE;</span><br><span class="line"></span><br><span class="line">    size = ROUNDUP(size, PGSIZE);</span><br><span class="line">    <span class="keyword">if</span>(base + size &gt; MMIOLIM)&#123;</span><br><span class="line">        panic(<span class="string">"mmio_map_region: reservation mem overflow"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    boot_map_region(kern_pgdir, base, size, pa, PTE_W | PTE_PCD | PTE_P);</span><br><span class="line">    <span class="keyword">uintptr_t</span> b = base;</span><br><span class="line">    base += size;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span> *) b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><a href="/2016/12/02/MIT 6.828 lab4/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/11/22/MIT 6.828 lab3/" class="post-title-link">MIT 6.828 lab3</a></h2><div class="post-info">2016年11月22日</div><div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这次<code>lab</code>的<code>Part A</code>让操作系统支持进程(单进程)，<code>Part B</code>处理了异常中断，使其能在<code>kernel态</code>和<code>用户态</code>进行切换。我觉得这次lab不算很难，可能是因为经过了前面两个lab洗礼的缘故。但还是在中断跳转那里卡了好一会，不会写汇编啊。</p>
<h2 id="Part-A"><a href="#Part-A" class="headerlink" title="Part A"></a>Part A</h2><p>在<code>Jos</code>中 我们用<code>Env</code>结构体来描述进程，关于Env，讲义中已经很清楚了，这里不赘述。关键点是通过<code>envs</code>数组和<code>env_free_list</code>来维护数组，这里需要注意的是<code>env_free_list</code>，不是像之前<code>free_page_list</code>那样是反向。这里需要和<code>envs</code>的顺序相同。</p>
<h4 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise 1"></a>Exercise 1</h4><blockquote>
<p>Modify <code>mem_init()</code> in kern/pmap.c to allocate and map the <code>envs</code> array. This array consists of exactly <code>NENV</code> instances of the <code>Env</code> structure allocated much like how you allocated the <code>pages</code> array. Also like the <code>pages</code> array, the memory backing <code>envs</code> should also be mapped user read-only at <code>UENVS</code> (defined in inc/memlayout.h) so user processes can read from this array.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">envs = (struct Env *) boot_alloc(NENV * <span class="keyword">sizeof</span>(struct Env));</span><br><span class="line">boot_map_region(kern_pgdir, UENVS, PTSIZE, PADDR(envs), PTE_U);</span><br></pre></td></tr></table></figure>
<p>这个应该轻车熟路了，就是为<code>envs</code>分配内存，并开启虚拟映射。<br></div><a href="/2016/11/22/MIT 6.828 lab3/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/11/14/MIT 6.828 lab2/" class="post-title-link">MIT 6.828 lab2</a></h2><div class="post-info">2016年11月14日</div><div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这个<code>lab</code>主要是写内存管理相关的代码。实现操作系统必须满足三个要求<code>multiplexing, isolation, and interaction</code> 。翻译成中文就是<code>复用，隔离和相互作用</code>。这三个条件其实主要靠抽象完成。<code>复用</code> 比如<code>IO</code>读写，都对文件描述符进行处理，而不管底下是网络读写还是磁盘读写等。<code>隔离</code>抽象地址空间，每个进程拥有一个自己的地址空间，相互并不影响。<code>相互作用</code>也需要抽象的控制，防止一些恶意的软件。</p>
<p><code>lab2</code>关注点在于如何实现地址空间。<code>jos</code>通过实现分页管理来实现。操作系统中所有程序接触的地址都是虚拟地址，然后硬件上真正需要的则是物理地址，所以中间则是使用<code>MMU(memory management unit)</code>来把虚拟地址翻译为物理地址。</p>
<h2 id="连续的内存分配"><a href="#连续的内存分配" class="headerlink" title="连续的内存分配"></a>连续的内存分配</h2><p>早期操作系统都是直接操作物理地址，很明显，这样做有着致命的缺点。比如用户程序可以直接访问<code>kernel</code>地址，导致系统崩溃，多个用户程序程序直接相互影响。即使设立了保护机制，也就是通过一些<code>flag</code>来辨别是否可以访问，但还是会有问题。就是当两个进程同时载入内存时，会进行地址偏移，跳转到指令并不会是程序中原先的指令，此时需要进行<code>重定位</code>，就是扫描一遍程序，给程序中涉及到的地址加上偏移量。但是这种方法效率是很低的。需要为每个需要执行的程序进行扫描判定计算。</p>
<h4 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h4><p>所以这里我们提出了<code>地址空间</code>的概念。重点还是抽象。我门让每个进程处于独立的进程空间中。比如虽然两个进程都指向同一个虚拟地址，但是实际所指的物理地址是不同的。</p>
<h4 id="基地寄存器和界限寄存器"><a href="#基地寄存器和界限寄存器" class="headerlink" title="基地寄存器和界限寄存器"></a>基地寄存器和界限寄存器</h4><p>其实就是动态重定位。把重定位的时间推迟了，之前的重定位一般发生在加载时，而现在推迟到访问内存时，并且减少了扫描查找的时间。通过两个寄存器来保存进程的起始地址和进程使用空间的长度。当程序访问内存时，自动加上偏移量，如果超出界限，则产生错误。但这种方法还是不够快，需要进行计算，比较可以进行的很快，但计算不行。进行动态重定位之后地址称为<code>线性地址</code><br></div><a href="/2016/11/14/MIT 6.828 lab2/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/11/06/MIT 6.828 lab1/" class="post-title-link">MIT 6.828 lab1</a></h2><div class="post-info">2016年11月6日</div><div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>开启一场漫长且有趣的旅程，即日起开始学习<code>MIT 6.828</code>。总共有七个<code>lab</code>。<code>lab6</code>和<code>lab7</code>其中选一个做。</p>
<h2 id="PC启动流程简述"><a href="#PC启动流程简述" class="headerlink" title="PC启动流程简述"></a>PC启动流程简述</h2><p>先了解一下当<code>PC</code>加电后，整个物理地址空间分布。</p>
<p><img src="http://zhang.nos-eastchina1.126.net/blog/2016-11-03%2020-55-37%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p>
<p>早期的<code>16位</code>计算机是只有<code>1MB</code>的寻址能力。也就是说只能使用<code>0x0000 - 0xffff</code>这么多，如上图所示，<code>640kb</code>以下的部分为早期计算机使用的部分。而上面<code>640kb - 1mb</code>的这些地方则保留下来作为特殊使用，比如视频显示之类的。其中最重要的部分为<code>BIOS( Basic Input/Output System)</code>，<code>BIOS</code>的主要责任为进行一些自检，然后从启动设备中，并载入它的第一扇区到内存的特定位置，即<code>0x7c00</code>，然后跳转到这个位置继续执行。此时，<code>BIOS</code>的工作完成。<code>0x7c00</code> 即是<code>bootloader</code>的入口点。</p>
<p>当现代计算机突破了<code>1MB</code>内存，达到<code>4GB</code>甚至更多的时候，依然保留了最开始的<code>1M</code>内存空间。所以开始一开始加电以后，是处于实模式的，也就是只有<code>1MB</code>内存可以访问。<code>bootloader</code>会把实模式切换到保护模式。也就是<code>4GB</code>寻址模式。然后再读取<code>kernel</code>到内存中，并且把控制权转给<code>kernel</code>。至此操作系统才算真正的启动起来。</p>
<p>下面简单总结下启动流程。</p>
<ol>
<li><code>PC</code>启动，并且执行第一条指令，位于<code>0xffff0</code>。是一条跳转指令，跳到<code>BIOS</code>刚开始的地方</li>
<li><code>BIOS</code> 进行初始化。</li>
<li><code>BIOS</code>搜寻启动设备，并加载<code>bootloader</code>到内存中，转移控制给<code>bootloader</code></li>
<li><code>bootloader</code>从实模式切换到保护模式</li>
<li><code>bootloader</code>从硬盘中读取<code>kernel</code>到内存中，并转移控制给<code>kernel</code></li>
<li>操作系统启动</div><a href="/2016/11/06/MIT 6.828 lab1/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/10/30/生成学习算法/" class="post-title-link">生成学习算法</a></h2><div class="post-info">2016年10月30日</div><div class="post-content"><h2 id="生成学习算法"><a href="#生成学习算法" class="headerlink" title="生成学习算法"></a>生成学习算法</h2><p>可能大部分人之前学过的分类算法，都是基于<code>train data</code>来最佳化参数，从而得到<code>data</code>的类别。也就是基于<code>p(y|x; θ)</code>来进行学习，比如<code>Logistic Regression</code>。现在我们换一种思路，反过来求解，分别对<code>p(x|y)</code> 求解，也就是说，对每一个<code>y</code>，<code>model</code>一个概率模型。当需要对新的<code>data</code>分类时，分别计算属于每个类的概率，从而得到最优的类别。公式基于贝叶斯定理,如下所示。</p>
<p><img src="http://zhang.nos-eastchina1.126.net/blog/2016-10-29%2023-45-27%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""><br></div><a href="/2016/10/30/生成学习算法/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/10/12/我对于动态规划的理解/" class="post-title-link">我对于动态规划的理解</a></h2><div class="post-info">2016年10月12日</div><div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>动态规划很早就接触过了，但一直都心存疑惑。网上的一些文章，基本都是满篇术语。<code>状态转移</code>， <code>状态方程</code>，这种名词，其实是让初学者比较迷惑。直到我上完<code>Berkeley</code>的<a href="http://cs61a.org/" target="_blank" rel="noopener">CS 61 A</a>, 突然就理解了所谓的动态规划。或者说是真正的理解了递归。把玩函数式语言对理解递归，或者说程序结构，非常有帮助。<a href="https://www.amazon.cn/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E8%A7%A3%E9%87%8A/dp/B0011AP7RY/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1476242304&amp;sr=1-1&amp;keywords=SICP" target="_blank" rel="noopener">SICP</a> 这本书已经很多人推荐了，用<code>Scheme</code>讲的，我没看完，看了大概前面两章。我比较推荐的是<code>华盛顿大学</code>的<a href="http://courses.cs.washington.edu/courses/cse341/16sp/" target="_blank" rel="noopener">Programming Languages</a> 还有上面<code>Berkeley</code>那门课。</p>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>我认为所谓的动态规划，就是递归的记忆化过程。这里必须要提一个函数式语言的好处，支持<code>尾递归</code>。<code>尾递归</code>可以用来防止重复计算。可惜很多语言并不支持，很容易就栈溢出了，比如<code>JAVA</code> ，<code>Python</code>。所以需要把递归改写成循环形式。其实本质还是和尾递归一样。<br></div><a href="/2016/10/12/我对于动态规划的理解/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/09/27/MIT 6.824 lab1/" class="post-title-link">MIT 6.824 lab1</a></h2><div class="post-info">2016年9月27日</div><div class="post-content"></div><a href="/2016/09/27/MIT 6.824 lab1/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/07/28/进程与线程/" class="post-title-link">进程与线程</a></h2><div class="post-info">2016年7月28日</div><div class="post-content"><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><blockquote>
<p>进程是一个程序的实例</p>
</blockquote>
<p>上面是最基本进程定义。就好比说当你双击<code>txt</code>文件，就开启了一个进程运行文本编辑器。当你再双击一下，就又开启了一个进程。这两个进程互不干扰，一个进程关闭或者崩溃，并不会导致另一个进程关闭。但是这两个进程拥有一个通信的接口，就是那个<code>txt</code>文件。这两个文本编辑器使用的同一个文件，这就又引申出另一个问题，进程间通信<code>(IPC)</code>.</p>
<p>在举个例子程序是一系列指令的集合，就好比一个类，进程则是真正在执行这些指令的东西，就好比对象。</p>
<h4 id="进程的特点"><a href="#进程的特点" class="headerlink" title="进程的特点"></a>进程的特点</h4><p>进程拥有一个独立的执行环境。进程之间互不干扰。它拥有自己栈，堆，<code>code</code>，静态文本，完全自给自足。所以说一个进程拥有独立的地址空间以及一个或者多个线程。<br></div><a href="/2016/07/28/进程与线程/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/07/27/为什么机器可以学习？/" class="post-title-link">为什么机器学习真的可以学到东西？</a></h2><div class="post-info">2016年7月27日</div><div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>开始跟《机器学习基石》这门课，相对于<code>Stanford</code>那门课，这门明显难度大很多，我跟到第10个<code>Lecture</code>，才刚刚讲到<code>Logistic Regression</code>。前面费了很大力气在讲机器什么时候可以学习，以及证明为什么能学习。</p>
<p>此文主要是基于《机器学习基石》的学习笔记。<code>Topic</code>是为什么机器可以学习？</p>
<h2 id="机器学习流程"><a href="#机器学习流程" class="headerlink" title="机器学习流程"></a>机器学习流程</h2><p>下面是一个粗略的机器学习流程图</p>
<p><img src="http://beader.me/mlnotebook/section2/images/basic_setup_of_the%20_learning_problem.png" alt=""></p>
<p>机器学习最开始也是最终的目的是获得一个<code>target function</code>，喂进去数据能直接得到正确结论的函数。为了得到这个函数，我们需要一大堆的训练数据。然后通过一个好的机器学习算法，从一大堆<code>可能的function(也就是H)</code>中挑选一个<code>比较好的function(也就是g)</code>，这个<code>g</code>和<code>target function</code>长得越像越好。<br></div><a href="/2016/07/27/为什么机器可以学习？/" class="read-more">...阅读全文</a></article></li></ul></main><footer><div class="paginator"><a href="/" class="prev">上一页</a><a href="/page/3/" class="next">下一页</a></div><div class="copyright"><p>© 2015 - 2018 <a href="http://threezj.com">Jian Zhang</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>