<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一派胡言</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://threezj.com/"/>
  <updated>2018-04-16T16:05:28.565Z</updated>
  <id>http://threezj.com/</id>
  
  <author>
    <name>Jian Zhang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://threezj.com/2018/04/16/2017%E8%BF%99%E4%B8%80%E5%B9%B4%E7%9A%84%E6%A0%A1%E6%8B%9B%E5%8E%86%E7%A8%8B/"/>
    <id>http://threezj.com/2018/04/16/2017这一年的校招历程/</id>
    <published>2018-04-16T15:56:15.915Z</published>
    <updated>2018-04-16T16:05:28.565Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>2017对我来说是复杂的一年。经历了太多事，</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;2017对我来说是复杂的一年。经历了太多事，&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Raft 共识算法</title>
    <link href="http://threezj.com/2017/06/11/Raft%20%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/"/>
    <id>http://threezj.com/2017/06/11/Raft 共识算法/</id>
    <published>2017-06-11T14:00:00.000Z</published>
    <updated>2018-04-17T15:39:38.980Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Raft"><a href="#Raft" class="headerlink" title="Raft"></a>Raft</h2><p>关于<code>mit 6.824</code>，这门课在找工作期间，又拾起来继续做了，断断续续的把<code>lab2</code>做完了，pass掉所有test。完整的实现了<code>Raft</code>算法，对分布式的了解也算是更进了一步。此文会对<code>Raft</code>做一个归纳总结，大部分的内容基于<a href="https://pdos.csail.mit.edu/6.824/papers/raft-extended.pdf" target="_blank" rel="noopener">raft 论文</a> 。</p><p><code>Raft</code>是一个共识算法，目的是为了保证多个副本在多个服务器的情况下数据的一致性，以及保证一定的容错能力。</p><p><code>Raft</code>的卖点是<code>understandable</code>，论文中一直在强调可理解（这个可理解对没接触过分布式的人来说，其实也不太好理解…）。这个可理解应该是相对于<code>paxos</code>来说的。基于<code>understandable</code>这个目标，<code>Raft</code>把整个共识的过程分成三块，分别是<code>leader election</code>， <code>log replication</code>和<code>safety</code>，下面我们会一一介绍。<br><a id="more"></a></p><h4 id="复制状态机（Replicated-state-machines）"><a href="#复制状态机（Replicated-state-machines）" class="headerlink" title="复制状态机（Replicated state machines）"></a>复制状态机（Replicated state machines）</h4><p>所谓的复制状态机其实并不是指某个服务器，而是一种用来容错的方法。比如说无论是<code>GFS</code>还是<code>HDFS</code>都需要有一个master服务器来保存<code>metadata</code>，那么就会存在这个<code>master</code>宕机的情况，一旦宕机，你的整个服务就不可用。解决方法就是通过复制多个副本到另外的服务器来备用，一旦<code>master</code>宕机，备用的服务器就可以立刻上线来充当<code>master</code>。但是这里存在一个问题，如何保证<code>master</code>和备用服务器的数据一致性？最直接的办法，就是在<code>master</code>上执行的命令，都在备用服务器都执行一遍。那么如何让备用服务器知道执行什么命令？通过<code>log</code>。当<code>master</code>接到客户端的命令之后，把这个命令写到<code>log</code>中，接着把<code>log</code>发给所有的备用服务器，等到大部分备用服务器接收到<code>log</code>，并反馈给<code>master</code>之后，<code>master</code>才提交这个命令（表示这个命令可以执行了）。但是这当中会有一些问题，比如备用服务器宕机，网络丢包等等。这其实就是<code>Raft</code>需要解决的核心问题，保证<code>master</code>和备用服务器的数据一致，也就是所有<code>log</code>都按顺序执行。那么<code>master</code>和备用服务器合在一起，就像是一个服务器一样，无所谓请求哪个服务器都会得到一致的结果。</p><h4 id="Raft的状态"><a href="#Raft的状态" class="headerlink" title="Raft的状态"></a>Raft的状态</h4><p><code>Raft</code>分为以下三个状态。</p><ul><li>Leader</li><li>Candidate</li><li>Follower</li></ul><p>Raft简单的地方在于，日志是由<code>Leader</code>到<code>Follower</code>的单向传递。也就是说<code>Leader</code>相当于一个总控节点，由它负责接受<code>client</code>的请求，并且把日志发送各个<code>Follower</code>，进行复制。也是只有Leader能决定何时提交一个日志。</p><p>其实整个Raft算法都是围绕着<code>Leader</code>进行的，主要分成以下三块。</p><ul><li><p>Leader election</p><p>一开始每个服务器都是<code>Follower</code>，那么需要决定由谁来做<code>Leader</code>，这里延伸出<code>Leader election</code>的问题。而且当Leader宕机的时候也需要重新进行选举。</p></li><li><p>Log replication</p><p>当<code>Leader</code>选举出来之后，需要把日志复制到每个<code>Follower</code>。这里复制需要保证所有日志都有序且正确的复制到<code>Follower</code>上。也就是说<code>Follower</code>上的日志不管是顺序还是内容都要和Leader上的一样。</p></li><li><p>Safety</p><p>一但Leader把一项日志复制到绝大多数（容错）的<code>Follower</code>时，需要执行这个日志。这里的安全性是指所有的服务器都要在这同一个位置执行同一个Log，简单来说就是<code>所有的服务器都要按一样的顺序执行相同的Log</code>。比方说一个log，<code>index = 3, command = x -&gt; 2</code>，那么所有的服务器在<code>Index=3</code>这个位置必须执行<code>x-&gt;2</code>这个操作，不然就会数据不一致了。<code>Safety</code>可能翻译成<code>正确性</code>更容易理解。</p></li></ul><h2 id="Leader-election"><a href="#Leader-election" class="headerlink" title="Leader election"></a>Leader election</h2><h4 id="任期（Term）"><a href="#任期（Term）" class="headerlink" title="任期（Term）"></a>任期（Term）</h4><p>在讲领导选举之前有一个比较关键的概念，就是<code>任期（Term）</code>。按照论文上的说法，<code>term</code>相当于一个逻辑上的时钟，用来检测过时的信息。请仔细理解上面这句话。<code>Follower</code>在超时之后就会成为<code>Candidate</code>，成为<code>Candidate</code>之后，它自增任期，并且把票投给自己，并且发送<code>RPC</code>请求给各个服务器，在得到绝大多数选票之后，成为<code>Leader</code>。为什么是绝大多数选票？因为一个任期只能有一个领导。假如<code>Candidate</code>没有拿到绝大多数选票，即有其他<code>Candidate</code>在竞争选票，那么<code>Candidate</code>会再次自增<code>Term</code>，发起下一轮投票。</p><p>这里有一个关键的点，就是一个任期只能有一个领导。假如领导宕机，会重新进行选举换领导，那么<code>Term</code>也会改变。所以通过这个方式可以用<code>Term</code>来感知过时的信息。假设有这一种情况，一开始a为领导，然后a断开了网络，集群的服务器因收不到a的心跳包，重新选举出一位领导b，b的任期大于a，当a再次加入网络，当发送心跳给b或者接受到b的心跳包时，通过比较<code>Term</code>可知a已经过期，会把a的<code>Term</code>改成b的<code>Term</code>，且状态变回<code>Follower</code>。</p><p><img src="https://camo.githubusercontent.com/f9b80d45d67996bb9ce63ba6e5d37b6a03150097/68747470733a2f2f646e2d307830312d696f2e71626f782e6d652f726166742d254535253942254245352e706e67" alt=""></p><h4 id="选举"><a href="#选举" class="headerlink" title="选举"></a>选举</h4><p>我们再来捋一下这个选举的过程</p><ol><li>服务器刚启动时，状态都是<code>Follower</code>。假如<code>Follower</code>在定时器设定的时间（随机）内，收到来自<code>Leader</code>或者<code>Candidate</code>合法的<code>RPC</code>请求，会继续保持<code>Follower</code>，并重置定时器的时间。</li><li>在定时器设定的时间内，没有收到合法的<code>RPC</code>请求，那么则发生<code>election timeout</code>，表示此时没有<code>Leader</code>。则超时的<code>Follower</code>，转换成<code>Candidate</code>。</li><li>成为<code>Candidate</code>之后，立即开始投票。先<code>Term</code>自增，然后投票给自己，重置定时器，并且并发的发送<code>RequestVote</code>给所有的服务器。接下来有三种情况会发生。<ul><li>A.收到绝大多数服务器的选票，赢得选举，成为<code>Leader</code></li><li>B.另一个服务器成为<code>Leader</code>，选举失败。（如何得知另一个服务器成为<code>Leader</code>？）</li><li>C.定时器超时，仍然没有<code>Leader</code>产生，说明有另外的<code>Candidate</code>竞争，产生平票之类的情况，则进入下一轮选举（也就是重做3）。</li></ul></li></ol><p>这里产生了Raft的第一个特性</p><ul><li><p>Election Safety</p><p>一个任期内只能有一个<code>Leader</code>。（任期不同即表示<code>Leader</code>已经换过了）</p></li></ul><h5 id="情况A"><a href="#情况A" class="headerlink" title="情况A"></a>情况A</h5><p>服务器按照先来先服务的原则进行投票（这里还有<code>Safety</code>的限制，只有含有全部<code>commit log</code>的<code>Candidate</code>才能获得选票）。所谓绝大多数的选票是指大于<code>n/2</code>。一旦赢得选举之后，则转成<code>Leader</code>，并且发送心跳包给另外的服务器来保证不会<code>election timeout</code>。</p><h5 id="情况B"><a href="#情况B" class="headerlink" title="情况B"></a>情况B</h5><p>假设另一个服务器成为了<code>Leader</code>，那么会发生什么？也就是当前这个<code>Candidate</code>会收到来自另一个<code>Leader</code>合法（<code>Term</code>没有落后）的<code>AppendEntries</code>请求。说明当前<code>Term</code>已经选举出<code>Leader</code>了，当前<code>Candidate</code>可以转为<code>Follower</code>了。</p><h5 id="情况C"><a href="#情况C" class="headerlink" title="情况C"></a>情况C</h5><p>也就是多个<code>Follower</code>都成为了<code>Candidate</code>，各自抢了一部分选票，一个都没赢。这种情况会再次发生election timeout，则直接进行下一轮竞选。</p><p>这里有个关键的问题，就是如何保证最终一定会产生一个<code>Leader</code>？办法是定时器设置的时间随机的<code>（150–300 ms）</code>。</p><h2 id="Log-replication"><a href="#Log-replication" class="headerlink" title="Log replication"></a>Log replication</h2><p>当<code>Leader</code>选出来之后，就到了发送log的环节了。这一部分的本质要解决的问题就是让<code>Follower</code>和<code>Leader</code>的日志顺序和内容都完全相同（指提交的部分），这样才能保证一致性。</p><p>阅读以下内容时请牢记<code>Log replication</code>要解决的本质问题是什么，也就是上面那句话。</p><p><code>Raft</code>维护了两个属性来保证<code>Follower</code>和<code>Leader</code>的日志顺序和内容完全相同（提交的部分）。</p><ul><li>如果两个entry在不同的服务器中，拥有同样的index和term，则保证他们保存了相同的命令</li><li>如果两个entry在不同的服务器中，拥有同样的index和term，则保证在两个entry之前的所有entry都相等。</li></ul><p>第一个属性要保证很简单，leader每次创建entry时，都只会使用新的index，而不会去改写之前index的内容。这也就是在给定index和term的情况下，只会创建一个entry。那么也就保证了相同index和term，相同命令。</p><p>第二个属性需要在每次<code>AppendEntries</code>的时候进行检查。<code>Leader</code>每次发送entry给follower时，会带上前一个entry的index和term。当<code>Follower</code>收到<code>RPC</code>时，会检查最后一个entry的index和term是不是和<code>AppendEntries</code>中的<code>prevIndex</code>和<code>prevTerm</code>相同，不相同则拒绝。若不相同则说明该entry保存的命令和<code>Leader</code>上保存的命令不同，则自然要拒绝。这个也就是所谓的一致性检查<code>（the consistency check）</code>。</p><p>正常情况下（没有机器宕机的情况），follower的日志是和leader同步的，不会有check失败的情况，但是如果考虑宕机的情况，就各种情况都有可能发生，参考下面一张图。</p><p><img src="https://camo.githubusercontent.com/a82fb45bde23f6b51ccca37f9dde7d5c5c547e90/68747470733a2f2f646e2d307830312d696f2e71626f782e6d652f726166742d254535253942254245372e706e67" alt=""></p><p><code>Follower</code>可能会缺少log，也可能会有多余的log，甚至都发生。</p><p>要解决这种情况，<code>Follower</code>需要从最后一次确认的entry之后，删除多余的entry，并且继续追加缺失的entry。</p><p><code>Raft</code>简单的地方在于，<code>Leader</code>从来不会修改自己log，而是让<code>Follower</code>自己去修改log。</p><p>方法就是<code>Leader</code>维护一个<code>nextIndex[i]</code>数组，用来保存下个发给<code>Follower[i]</code>的Index，如果<code>consistency check</code>通过，则<code>nextIndex[i]++</code>，不然的话则<code>nextIndex[i]--</code>，直到双方同步log位置。这个感觉有点类似于<code>tcp</code>传数据时的<code>ack</code>，总是返回下一个期望收到的数据包。</p><p>也就是说这里除了<code>nextIndex</code>的更新之外，<code>Leader</code>不需要做什么额外的动作。这就是<code>Raft</code>可理解的地方了。</p><h2 id="Safety"><a href="#Safety" class="headerlink" title="Safety"></a>Safety</h2><h4 id="选举限制"><a href="#选举限制" class="headerlink" title="选举限制"></a>选举限制</h4><p>那么是不是这样就能保证，<code>Follower</code>和<code>Leader</code>都按顺序执行相同的命令呢？不一定！考虑上面那张图的情况。假设这个时候<code>Leader</code>宕机，<code>Follower(f)</code>被选举成为<code>Leader</code>，那么会发生什么？<code>nextIndex</code>会一直<code>uncheck</code>直到<code>index=4</code>的<code>entry</code>，把2发给每个<code>Follower</code>，但是之前4已经复制到了大部分机器上，已经<code>commit</code>了，这时候会发生覆盖已经<code>commit</code>的<code>entry</code>的情况了！</p><p>所以在选举的时候会加上限制，在<code>RequestVote</code>中加上<code>Candidate</code>的最后一个entry的index以及term。<code>Follower</code>会与自己的最后一个<code>entry</code>的<code>index</code>和<code>term</code>进行比较。假设<code>term</code>不相等，那么只有拥有最新<code>term</code>的<code>Candidate</code>才能获得选票。若假设<code>term</code>相等，则比较<code>index</code>，最长的那个获得选票。</p><p>也就是说只有一个<code>Candidate</code>包含了全部已经<code>commit</code>的<code>entry</code>的情况下，才能获得选票。这就是所谓的<code>at least up-to-date</code>，其实也就是保证<code>term</code>最新，若<code>term</code>相同，则保证<code>log</code>最长。这样选出来的<code>leader</code>肯定包含所有<code>commit</code>的<code>entry</code>。（其实这个命题，同样要加上一点约束才是正确的，也就是下面的<code>commit</code>限制）</p><h4 id="commit限制"><a href="#commit限制" class="headerlink" title="commit限制"></a>commit限制</h4><p>我们先来看下面的图。</p><p><img src="https://camo.githubusercontent.com/14df99e543c71ee75cafd614e1c55c25ac580ec8/68747470733a2f2f646e2d307830312d696f2e71626f782e6d652f726166742d254535253942254245382e706e67" alt="图 8"></p><p>黑框表示为<code>Leader</code>。注意c的时候，2已经拷贝到大部分服务器上，提交以后，s1宕机，然后此时s5仍然能获得s2，s3，s4的选票成为<code>Leader</code>，但是这种情况s5不知道2已经被提交了，那么2就会被3覆盖！</p><p>这里限制的条件就是，在c的时候2无法提交！<code>Leader</code>仅仅只能提交当前<code>Term</code>的<code>entry</code>!这样的话如果没提交，即使被覆盖也没什么。如果到e这种情况，s5已经无法获得选票了。</p><p>通过上述两个限制保证<code>Leader</code>选举成功时一定会包含全部已经<code>commit</code>的<code>entry</code>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>此文大致描述了<code>Raft</code>算法的基本样貌。我觉得理解Raft最重要的还是理解下面五个性质。</p><p><img src="http://7xrsib.com1.z0.glb.clouddn.com/2017-06-11%2021-36-40%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p><p>最后再上一张pass所有test的截图！</p><p><img src="http://7xrsib.com1.z0.glb.clouddn.com/2017-06-11%2021-38-07%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://raft.github.io/raft.pdf" target="_blank" rel="noopener">In Search of an Understandable Consensus Algorithm</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Raft&quot;&gt;&lt;a href=&quot;#Raft&quot; class=&quot;headerlink&quot; title=&quot;Raft&quot;&gt;&lt;/a&gt;Raft&lt;/h2&gt;&lt;p&gt;关于&lt;code&gt;mit 6.824&lt;/code&gt;，这门课在找工作期间，又拾起来继续做了，断断续续的把&lt;code&gt;lab2&lt;/code&gt;做完了，pass掉所有test。完整的实现了&lt;code&gt;Raft&lt;/code&gt;算法，对分布式的了解也算是更进了一步。此文会对&lt;code&gt;Raft&lt;/code&gt;做一个归纳总结，大部分的内容基于&lt;a href=&quot;https://pdos.csail.mit.edu/6.824/papers/raft-extended.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;raft 论文&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Raft&lt;/code&gt;是一个共识算法，目的是为了保证多个副本在多个服务器的情况下数据的一致性，以及保证一定的容错能力。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Raft&lt;/code&gt;的卖点是&lt;code&gt;understandable&lt;/code&gt;，论文中一直在强调可理解（这个可理解对没接触过分布式的人来说，其实也不太好理解…）。这个可理解应该是相对于&lt;code&gt;paxos&lt;/code&gt;来说的。基于&lt;code&gt;understandable&lt;/code&gt;这个目标，&lt;code&gt;Raft&lt;/code&gt;把整个共识的过程分成三块，分别是&lt;code&gt;leader election&lt;/code&gt;， &lt;code&gt;log replication&lt;/code&gt;和&lt;code&gt;safety&lt;/code&gt;，下面我们会一一介绍。&lt;br&gt;
    
    </summary>
    
    
      <category term="Distributed System" scheme="http://threezj.com/tags/Distributed-System/"/>
    
  </entry>
  
  <entry>
    <title>数据库事务与并发控制</title>
    <link href="http://threezj.com/2016/12/30/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"/>
    <id>http://threezj.com/2016/12/30/数据库事务与并发控制/</id>
    <published>2016-12-30T08:20:06.000Z</published>
    <updated>2018-04-17T15:36:00.752Z</updated>
    
    <content type="html"><![CDATA[<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><blockquote><p>数据库事务是<code>DBMS</code>执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。</p></blockquote><p>事务必须要满足<code>ACID</code>四个特性。</p><ul><li><p><code>Atomicity</code>(原子性)</p><p>也就是所谓的<code>all-or-nothing</code>。单个事务有一系列的操作，比如查找，增加，更新等。当事务提交之后事务中所有对数据库的操作必须反映到数据库上。但如果由于某些原因中断，那么所有对数据的操作必须恢复到这个事务开始之前。也就是事务对数据库的操作，要么全部执行，要么都不执行。</p></li><li><p><code>Consistency</code>(一致性)</p><p>事务开始之前数据满足的完整性约束，在事务结束之后也需要满足。其实也就是事务得到了正确的执行。</p></li><li><p><code>Isolation</code>(隔离性)</p><p>每个事务之间是相互独立的。有点类似于进程的概念。因为事务是并发执行的，所以事务之间不能相互影响不然就有可能破坏<code>一致性</code>。</p></li><li><p><code>Durability</code>(持久性)</p><p>已被提交的事务对数据库的修改应该永久保存在数据库中。这里的关键应该在于永久二字，也就是说即使系统崩溃、硬盘损坏等不可控因素发生，也要保证数据仍然存在数据库中。所以备份很重要啊。</p><a id="more"></a></li></ul><h2 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h2><p>考虑一下当多个事务并发执行的情况，是否能保证<code>ACID</code>。如果完全不加控制，因为系统的线程调度是无法预知的，那么多个事务之间的执行顺序也不可控，即破坏了<code>隔离性</code>，随之而来的<code>一致性</code>也无法满足，比如事务可能写入脏数据破坏完整性约束。<code>原子性</code>和<code>持久性</code>需要靠<code>恢复系统</code>来保证，这篇文章不过多讨论<code>恢复系统</code>。</p><p>最简单的能想到的保持<code>隔离性</code>的方式即一次只运行一个事务，也就是说没有并发，<code>串行</code>调度，一个接一个。完全不需要并发控制，可是很明显不现实，因为效率极低。当事务并发执行时，任何调度顺序都是可能的。<code>并发控制</code>的任务是让并发的事务执行结果与串行调度的执行结果相同。这种调度称为<code>可串行化</code>。</p><p>并发控制的目标即<code>可串行化</code>。</p><h4 id="可串行化"><a href="#可串行化" class="headerlink" title="可串行化"></a>可串行化</h4><p>如何检测调度是否为<code>可串行化</code>？有很多方法，这里只说一种<code>冲突可串行化(conflict serializability)</code>。</p><p>先定义<code>冲突</code>，即假设不同事务的两种操作访问同一个对象，如果交换他们的操作顺序，会得到不同的结果，则<code>冲突</code>。</p><p>考虑事务最本质的两种操作，<code>read</code>和<code>write</code>，则总共有四种情况。</p><p><img src="http://7xrsib.com1.z0.glb.clouddn.com/2016-12-28%2023-29-27%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p><p>很明显，只要涉及到<code>write</code>则<code>冲突</code>。那么当交换调度中<code>未冲突操作</code>的顺序，能得到<code>串行</code>的调度，那么原先的调度则称为<code>冲突可串行化</code>。</p><p>好的，那么如何检测<code>冲突可串行化</code>，当然选择去交换<code>未冲突的操作</code>然后判断是否串行，但效率不高。比较高效的做法是通过<code>优先图</code>检测。维护一个<code>图</code>，当符合特定规则时，放入<code>边</code>。假设有两个事务<code>Ti/Tj</code>，一个对象A，规则如下。</p><ol><li>Ti在Tj之前读或者写A</li><li>Ti在Tj读A之前写A</li></ol><p>有些拗口。若无环，则是<code>冲突可串行化</code>，有环则不是，实例如下。</p><p><img src="http://7xrsib.com1.z0.glb.clouddn.com/2016-12-29%2021-04-17%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p><h4 id="可恢复与无级联"><a href="#可恢复与无级联" class="headerlink" title="可恢复与无级联"></a>可恢复与无级联</h4><p>考虑下面一种情况</p><p><img src="http://7xrsib.com1.z0.glb.clouddn.com/2016-12-30%2015-26-46%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p><p>上面这个调度的问题在于，事务2在读取了事务1的数据之后提交了，然而事务2因为某些原因终止了，那么事务2就要进行回滚。但是事务1已经提交了，提交意味着，数据已经被写入磁盘，原有的数据被覆盖，回滚会出错。这种调度则称为<code>不可恢复的调度</code>。若要实现<code>可恢复的调度</code>，则必须让事务2等待事务1提交之后，再进行提交。</p><p>所以<code>可恢复调度</code>即是指，若某事务A读取事务B写入的内容，则需在事务B提交之后，再提交。</p><p><code>可恢复调度</code>同时会带来一定的问题，即<code>级联</code>问题。若T2读了T1写的数据，T3读了T2写的数据，T4读了T3写的数据，以此类推，假设这时T1终止，则需要回滚一系列事务。这样效率是很低的。所以我们希望的是<code>无级联调度</code>，能避免这种情况。</p><p><code>无级联调度</code>即是指，若事务A读取事务B写入的内容，那么事务B需要在事务A读操作之前提交。注意这里的区别，把事务提交提前了。</p><p>并发控制希望做到<code>可串行化</code>，<code>可恢复</code>和<code>无级联</code>。<code>无级联调度</code>必定是<code>可恢复调度</code>。</p><h4 id="两阶段封锁-Two-phase-locking"><a href="#两阶段封锁-Two-phase-locking" class="headerlink" title="两阶段封锁(Two phase locking)"></a>两阶段封锁(Two phase locking)</h4><p><code>Two phase locking</code>是一种可以实现<code>可串行化</code>的协议。此协议把事务分成两个阶段，<code>增长阶段</code>以及<code>缩减阶段</code>。<code>增长阶段</code>是获得锁的阶段，而<code>缩减阶段</code>则反之，是释放锁的阶段。也就说当一个事务一旦释放了一个锁之后就不能继续加锁了。具体定义如下。</p><ul><li><code>增长阶段(growing phase)</code>: 事务可以获得锁，但不能释放锁</li><li><code>缩减阶段(shrinking phase)</code>: 事务可以释放锁，但不能获得锁</li></ul><p><code>两阶段封锁</code>最主要的作用是推迟了锁的释放时间。可以试想下如果在中间就释放锁，那则有可能调度给其他事务读到脏数据。</p><p><code>两阶段封锁</code>可以保证<code>可串行化</code>，这是可以证明的。但是<code>两阶段封锁</code>不保证<code>死锁</code>，所以需要额外的工作来检测或者预防<code>死锁</code>。</p><p><code>两阶段封锁</code>无法保证<code>无级联</code>，我们可以通过<code>严格两阶段封锁</code>来保证，即在<code>两阶段封锁</code>的前提下，约束在事务提交之前不得释放<code>排他锁</code>。也就是说如果事务不提交的话，他写的数据，别的事务就没法读，符合<code>无级联</code>的定义。</p><p>另个一个变种是<code>强两阶段封锁</code>在严格的基础上更进一步，约束事务在提交之前不得释放任何锁。</p><p>还有个问题，假如某个数据在之前很长一段时间都是只读的，到最后才需要写，如果按照目前的规则，事务在一开始就要获得对数据的<code>排他锁</code>，但是之前数据是只读的，这样影响了一定的效率。我们采取了<code>锁升级</code>的策略。可以先获得<code>共享锁</code>，直到需要写入时再获取排他锁，大大提高并发效率。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://db.csail.mit.edu/6.830/lectures/lec12-notes.pdf" target="_blank" rel="noopener">mit 6.830 lec12</a><br>《数据库系统概念》</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;事务&quot;&gt;&lt;a href=&quot;#事务&quot; class=&quot;headerlink&quot; title=&quot;事务&quot;&gt;&lt;/a&gt;事务&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;数据库事务是&lt;code&gt;DBMS&lt;/code&gt;执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;事务必须要满足&lt;code&gt;ACID&lt;/code&gt;四个特性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Atomicity&lt;/code&gt;(原子性)&lt;/p&gt;
&lt;p&gt;也就是所谓的&lt;code&gt;all-or-nothing&lt;/code&gt;。单个事务有一系列的操作，比如查找，增加，更新等。当事务提交之后事务中所有对数据库的操作必须反映到数据库上。但如果由于某些原因中断，那么所有对数据的操作必须恢复到这个事务开始之前。也就是事务对数据库的操作，要么全部执行，要么都不执行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Consistency&lt;/code&gt;(一致性)&lt;/p&gt;
&lt;p&gt;事务开始之前数据满足的完整性约束，在事务结束之后也需要满足。其实也就是事务得到了正确的执行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Isolation&lt;/code&gt;(隔离性)&lt;/p&gt;
&lt;p&gt;每个事务之间是相互独立的。有点类似于进程的概念。因为事务是并发执行的，所以事务之间不能相互影响不然就有可能破坏&lt;code&gt;一致性&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Durability&lt;/code&gt;(持久性)&lt;/p&gt;
&lt;p&gt;已被提交的事务对数据库的修改应该永久保存在数据库中。这里的关键应该在于永久二字，也就是说即使系统崩溃、硬盘损坏等不可控因素发生，也要保证数据仍然存在数据库中。所以备份很重要啊。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Database System" scheme="http://threezj.com/tags/Database-System/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络自顶向下之可靠传输协议的笔记</title>
    <link href="http://threezj.com/2016/12/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E4%B9%8B%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%AC%94%E8%AE%B0/"/>
    <id>http://threezj.com/2016/12/18/计算机网络自顶向下之可靠传输协议的笔记/</id>
    <published>2016-12-18T15:16:06.000Z</published>
    <updated>2018-04-17T15:32:30.010Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>此篇文章是<code>计算机网络 自顶向下方法</code>第三章的简略版笔记，这一章非常精彩。个人认为运输层可以说是计算网络中最重要的一层，分别面向应用层以及网络层。众所周知，网络层是无法保证可靠传输的。所以运输层根本的问题在于<code>如何能够在不可靠的网络层之上进行可靠的网络</code>。</p><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p><code>UDP</code>几乎没有做事情，仅仅只是把应用层的数据加上报文段，然后交付给网络层，虽然<code>UDP</code>有差错检查，但它也只是丢弃这个包而已。应用程序采用<code>UDP</code>的主要是基于效率的考虑。<code>UDP</code>简单，所以效率高。本文不讨论<code>UDP</code>。</p><h2 id="可靠数据传输"><a href="#可靠数据传输" class="headerlink" title="可靠数据传输"></a>可靠数据传输</h2><p>这一节我们从最简单的情况开始，针对各种情况，慢慢完善，最终形成一个可靠的数据传输协议。<code>TCP</code>是一个<code>全双工</code>的协议，双方可以互相发送信息。目前我们只考虑单向的传输。</p><h4 id="假设网络层可靠"><a href="#假设网络层可靠" class="headerlink" title="假设网络层可靠"></a>假设网络层可靠</h4><p>最开始我们先假设网络层是可靠的，也就是说我们交付给网络层的包不会丢失且完好无损，同时假设发送和接受双方速率是一样的。这种情况下我们需要考虑什么？什么都不需要考虑。就像<code>UDP</code>一样，打包好交付给网络层即可。相当于在网络层实现了可靠传输。<br><a id="more"></a></p><h4 id="假设网络层只存在数据损坏的情况"><a href="#假设网络层只存在数据损坏的情况" class="headerlink" title="假设网络层只存在数据损坏的情况"></a>假设网络层只存在数据损坏的情况</h4><p>现在我们假设网络层只存在数据损坏的情况，也就是每个包都能到达目标主机，但是数据正确性却不受控制。这种情况我们需要考虑两个问题。</p><ul><li>如何判断数据损坏？</li><li>如何通知发送方数据损坏？</li></ul><p>其实很容易理解，日常对话中，如果我们听清，最常见的就是让对话再说一遍。所以这里需要做三件事<code>差错检查</code>，<code>反馈给发送方</code>，<code>发送方重传</code>。这里开始是和<code>UDP</code>不同了，<code>UDP</code>进行差错检查后，如果发生错误丢掉这个包就完事了。<code>TCP</code>则会进行重传。</p><ul><li><p>差错检查</p><p>基本原理是用额外的<code>bit</code>来判断数据是否损坏，这里并不多解释。</p></li><li><p>反馈给发送方</p><p>当<code>差错检查</code>发现数据损坏时，我们需要通知发送方。也就是发送<code>ACK数据包</code>，所谓的<code>ACK数据包</code>也就是在报文段把一个标志位改成为1而已。或者发送<code>NAK数据包</code>。<code>ACK</code>表示数据发送成功，<code>NAK</code>表示失败。</p></li><li><p>重传</p><p>当发送方接受到反馈之后，若失败则要进行重传。</p></li></ul><p>现在的情况是这样的，发送方发送数据之后，开始阻塞等待接收方反馈，若得到<code>NAK</code>则进行重传，然后继续阻塞等待反馈。直接接受到<code>ACK</code>则开始发送下一个数据。这里有一个问题就是，当发送一个数据包后，发送方会阻塞，效率很低，这个问题我们下面会解决。</p><p>接收方很简单，接收到数据以后进行<code>差错检查</code>，若错误则进行反馈<code>NAK</code>，反之则发送<code>ACK</code>。</p><h4 id="反馈出错的情况"><a href="#反馈出错的情况" class="headerlink" title="反馈出错的情况"></a>反馈出错的情况</h4><p>新的问题，那就是反馈的<code>ACK</code>或者<code>NAK</code>出错！改如何解决，最先想到的就是发送方再问一遍，也就是再发一个包给接收方，问他刚刚说了什么，那如果这个包再出错的？这个方案显然有问题。另一种方法是当收到错误的<code>ACK</code>或者<code>NAK</code>，则直接进行重发。这种方法的问题是接受方不知道新接收的包是重传还是新发送的包。比如说接收方反馈<code>ACK</code>给发送方，但数据损坏发送方直接进行重发，那么接受方会认为这个新的包是全新的数据，而不是重发的，造成<code>冗余分组</code>。</p><p>解决这种情况一个很巧妙的方法，加入<code>序号</code>。也就是说对需要发送的数据包按顺序编号，那么接受方只需要检查<code>序号</code>即可确实这是否是一个重传的包。即检查新接受的包与上一次正确接受的包的<code>序号</code>进行比对，若相同则是重发，若大与则是新的包。有了<code>序号</code>之后，我们可以不用<code>NAK</code>，只用<code>ACK</code>，也能达到<code>NCK</code>的效果，即重发上一次正确接收的<code>ACK</code>，接收方比对<code>序号</code>可知数据包受损。</p><h4 id="网络层发送数据丢失"><a href="#网络层发送数据丢失" class="headerlink" title="网络层发送数据丢失"></a>网络层发送数据丢失</h4><p>好，新的问题来了。数据包丢失怎么办？按照之前的讨论，发送方会一直等待接收方进行<code>ACK反馈</code>，若数据包丢失，发送方则会一直阻塞。很自然的就想到采用定时器，等待一定时间之后，若发送方没得到反馈，则自动进行重传。但是如何确定等待时间又是个问题。可以确定的是，等待时间一定大于往返时延加上接受端处理数据包的时间。这是个比较复杂的问题，之后再讨论。</p><h4 id="超时处理"><a href="#超时处理" class="headerlink" title="超时处理"></a>超时处理</h4><p>还记得前面提到的，当发送方发送数据之后需要阻塞等待接受确认。这种方式叫做<code>停等协议</code>。可想而知效率很低，几乎大部分的时间都用来等待了。根据<code>计算机网络 自顶向下方法</code>上面的描述，采用<code>停等协议</code>的情况下，发送方只有<code>万分之2.7</code>的时间是在真正工作的！</p><p>之前的方法是一次发送一个数据包，然后进行阻塞等待。现在解决方法是发送多个数据包，然后再进行阻塞等待。注意这里是有本质的区别的。先前都是发一个等一个。现在是发送<code>n</code>个分组，并一起进行等待确认。区别在于发送的数据包的<code>ACK</code>可以在阻塞之前返回，那么则不需要等待之前发送的分组，可以继续向前移动。就好像铺铁路一样，其实并不需要那么长的铁轨，只需要很短一段铁轨就可以让火车绕世界一圈，只要你铺的够快。下面的图更加形象。</p><p><img src="http://7xrsib.com1.z0.glb.clouddn.com/2016-12-13%2023-20-07%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p><p>当遇到数据丢失或的情况，有两种方法可以解决。分别是<code>回退N步</code>和<code>选择重传</code></p><h4 id="回退N步"><a href="#回退N步" class="headerlink" title="回退N步"></a>回退N步</h4><p>发送多个分组且不用等待的数量是有限制的，因为考虑到需要<code>流量控制</code>，所以不能无限制的发送。假设发送<code>N</code>个分组，<code>N</code>通常被称为<code>窗口长度</code>。当<code>N</code>个分组中的<code>序号</code>最小的分组被确认之后，才能继续发送，这就是所谓的<code>滑动窗口协议</code>。</p><p>我们先来看接收方是如何处理的。接收方采用<code>累积确认</code>的方式，接收方只接收按序到达的数据包。接收方会把接收到的数据包与上次确认接收的数据包序号进行比对，若序号正好是按序到达的，则发送<code>ACK</code>确认接受，若不按序，则发送最后一次确认接收的<code>ACK</code>，并且丢弃这个包。注意这里虽然都是<code>ACK</code>，但是<code>ACK</code>包中带的<code>序号</code>是不同的。</p><p>发送方需要维护一个滑动窗口<code>[base,N]</code>，我们用<code>nextseq</code>表示下一个可以发送的序号。那么<code>[base, nextseq)</code>表示已经发送但未被确认,<code>[nextseq,N]</code>表示可以发送但是还未发送。<code>base</code>之前的则表示已经发送且确认的。<code>N</code>之后的则表示还不能发送的。若<code>base</code>被确认，则窗口向前移动。<code>回退N步</code>的主要动作在于数据丢失，定时器超时的情况，这个时候会重传所有已经发送但未被确认的<code>数据包</code>。因为上面接收方会把所有未按序到达的数据包丢弃。</p><p><img src="http://7xrsib.com1.z0.glb.clouddn.com/2016-12-14%2014-30-16%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p><h4 id="选择重传"><a href="#选择重传" class="headerlink" title="选择重传"></a>选择重传</h4><p><code>选择重传</code>解决了<code>回退N步</code>的效率问题，<code>回退N步</code>虽然实现简单，但是效率不高，在某些情况下需要重传大量分组。</p><p><code>选择重传</code>在接收方也维护了滑动窗口来缓存<code>正确到达但是乱序的分组</code>，而不是简单的丢弃。接收方分两种情况，如果是按序到达，则返回<code>ACK</code>确认这个包，并且一起交付与之相连续的之前缓存的数据包，同时滑动窗口向前移动。若未按序到达，则缓存这个<code>数据包</code>，并且返回<code>ACK</code>确认到达。</p><p>在发送方，和之前差不多，但是不会重发之前正确发送但是乱序的分组，而是只发送未确认的分组。</p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>终于轮到<code>TCP</code>了，但核心在上面。<code>TCP</code>用到了上述的所有原理比如<code>差错检查</code>，<code>累计确认</code>，<code>重传</code>，<code>定时器</code>等。<code>TCP</code>是面向连接的全双工运输层协议。也就是说<code>TCP</code>在通信之前，必须要建立一条可靠的连接，通过这条连接来进行通信。这点在使用<code>socket</code>编程的时候，十分明显。当客户端想发送消息给服务端时，必须先调用<code>connect</code>函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self.socket.connect((self.address, self.port))</span><br><span class="line">self.send(self.name)</span><br></pre></td></tr></table></figure><p><code>socket</code>是操作系统对<code>TCP</code>的一层抽象，提供接口让应用更加方便的使用<code>TCP</code>。</p><h4 id="TCP报文段"><a href="#TCP报文段" class="headerlink" title="TCP报文段"></a>TCP报文段</h4><p><img src="http://www.nosa.me/wp-content/uploads/2015/08/C9FBBF9A-04FE-4F2B-81E8-559391153C73.jpg" alt=""></p><ul><li><p>源端口号和目标端口号</p><p>各占用<code>16</code>位，源端口号和目标端口号再加上源地址和目的地址构成<code>socket</code>的唯一标识。</p></li><li><p>顺序号和确认号</p><p>这里就用到了上面的原理，即采用<code>序号</code>编码。<code>顺序号</code>标示当前数据包的<code>序号</code>，<code>确认号</code>表示期望收到的下一个数据包的<code>序号</code>。</p></li><li><p>头部长度</p><p>表明<code>TCP</code>首部的长度，因为可选项的存在，所以首部的长度是可变的。</p></li><li><p>控制位</p><p>设置为<code>1</code>时有效，作用如下图。</p><p><img src="http://www.nosa.me/wp-content/uploads/2015/08/AED89D8A-403B-42F4-AA2E-3EC23D20FAB7.jpg" alt=""></p></li><li><p>窗口大小</p><p>即滑动窗口的长度，用于<code>累积确认</code>以及<code>拥塞控制</code>。</p></li><li><p>校验和</p><p>用于差错检查</p></li><li><p>紧急指针</p><p>只有控制位的<code>URG</code>设置为<code>1</code>才有用，表示数据要优先处理，代表紧急数据最后一个字节的序号。</p></li><li><p>选项</p><p>这里可以填<code>MSS</code>之类的数据。</p></li></ul><h4 id="TCP的三次握手"><a href="#TCP的三次握手" class="headerlink" title="TCP的三次握手"></a>TCP的三次握手</h4><p>先来讨论下<code>TCP</code>的链接建立，为了建立可靠的通信链接，<code>TCP</code>需要发送三个分组，前两个分组不能携带数据，最后一个是可以携带数据的。也就是所谓的三次握手了。</p><ul><li><p>第一次</p><p>客户端向服务端发送<code>TCP</code>报文段，注意这里是不能包含有效数据的。报文段首部的控制位中<code>SYN</code>位会设置成<code>1</code>，表明这是连接请求报文段。还有就是初始化客户端的<code>起始序号</code>放在<code>顺序位</code>中，一般是随机选的。</p></li><li><p>第二次</p><p>当服务端收到<code>SYN报文段</code>之后，会回发一个报文段，表示允许链接，并且依旧不能携带数据。同样的<code>SYN</code>控制位设为<code>1</code>，并且初始化服务端的<code>起始序号</code>和缓存空间。另外<code>确认号</code>设置为<code>客户端的起始序号加1</code>，并且<code>ACK</code>的控制位设为<code>1</code>。</p></li><li><p>第三次</p><p>客户端收到服务端的允许连接报文之后，可以开始初始化客户端的缓存空间，并且回发一个报文段，这个报文段可以携带数据。这个报文段的确认号设置为<code>服务端的起始序号加1</code>。</p></li></ul><p>到这里不得不谈网上经典的面试题，<code>TCP建立连接为什么需要三次握手？</code>。让我们回到<code>TCP</code>的目的，是为了在不可靠的网络层之上建立可靠的运输协议。那么从这个角度来考虑，如果客户端不确认服务端的允许连接报文会发生什么？假设现在<code>TCP</code>经过服务端允许连接以后，连接就已经建立了。如果现在有一个无效的<code>TCP</code>请求连接发送到服务端，有可能是因为网络阻塞等原因。服务端则会认为这是一个客户端的新的连接请求，因为不需要客户端确认，则直接建立连接，然而这个连接其实是不需要的，白白浪费资源。如果加上第三次，客户端会确认这个请求是失效的，则不会建立连接。</p><h4 id="TCP的数据传输"><a href="#TCP的数据传输" class="headerlink" title="TCP的数据传输"></a>TCP的数据传输</h4><p><code>TCP</code>的可靠数据传输基本原理可以说已经包含在上半部分的介绍当中了。主要是三大原理<code>序号</code>，<code>累计确认</code>和<code>超时重传</code>。但是<code>TCP</code>根据实际情况加入了一些比较有趣的东西，比如<code>快速重传</code>，<code>冗余确认</code>等。</p><h4 id="简化版的TCP传输"><a href="#简化版的TCP传输" class="headerlink" title="简化版的TCP传输"></a>简化版的TCP传输</h4><p><img src="http://7xrsib.com1.z0.glb.clouddn.com/2016-12-14%2023-16-55%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p><p>首先初始化序号位，以及<code>sendBase</code>(也就是第一位未被确认的序号或者说下一个需要发送的序号)。比如说发送<code>seq=1</code>，<code>seq=2</code>,<code>seq=3</code>都未被确认，那么<code>sendBase</code>就为<code>1</code>，然后之后得到一个<code>seq=3</code>的<code>ACK=4</code>，那么则认为<code>seq=1</code>和<code>seq=2</code>都被收到了，则<code>sendBase</code>变为<code>4</code>。避免了重传，原因是接收方采用了<code>累积确认</code>。</p><p>考虑到实际使用中的情况，<code>TCP</code>增加了一些功能。</p><h4 id="超时加倍等待时间"><a href="#超时加倍等待时间" class="headerlink" title="超时加倍等待时间"></a>超时加倍等待时间</h4><p>这种方法其实很好理解，一旦发生超时事件，其实就说明网络拥堵，那么就加倍定时器的等待时间，让<code>TCP</code>发的慢一点以缓解网络拥塞。</p><h4 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h4><p>快速重传是当<code>TCP</code>连续收到<code>3</code>个<code>冗余ACK</code>会触发，即立刻重传未被确认的报文段(不等定时器超时)。所谓的<code>冗余ACK</code>其实也很明了，就是说明之前发送的报文段一直未被客户端收到，所以客户端一直重发期望收到的下一个报文段。</p><h4 id="选择重传还是回退N步"><a href="#选择重传还是回退N步" class="headerlink" title="选择重传还是回退N步"></a>选择重传还是回退N步</h4><p>答案是混合体！因为是<code>TCP</code>是<code>累计确认</code>的，从这一点来看<code>TCP</code>是<code>回退N步</code>的。但是<code>TCP</code>不重传<code>已经发送但未被确认</code>的数据，这一点又和<code>选择重传</code>很像。这里有个问题，既然<code>TCP</code>是<code>累计确认</code>的，那么如何保证那些<code>已经发送但未被确认</code>的数据已经到达接收方了呢？答案是<code>TCP</code>会缓存这些数据包，但是不会发送确认到达。直到<code>TCP</code>收到那个丢失的包后，会重排序缓存的包，并发送<code>ACK</code>。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>《计算机网络 自顶向下方法》</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;此篇文章是&lt;code&gt;计算机网络 自顶向下方法&lt;/code&gt;第三章的简略版笔记，这一章非常精彩。个人认为运输层可以说是计算网络中最重要的一层，分别面向应用层以及网络层。众所周知，网络层是无法保证可靠传输的。所以运输层根本的问题在于&lt;code&gt;如何能够在不可靠的网络层之上进行可靠的网络&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;UDP&quot;&gt;&lt;a href=&quot;#UDP&quot; class=&quot;headerlink&quot; title=&quot;UDP&quot;&gt;&lt;/a&gt;UDP&lt;/h2&gt;&lt;p&gt;&lt;code&gt;UDP&lt;/code&gt;几乎没有做事情，仅仅只是把应用层的数据加上报文段，然后交付给网络层，虽然&lt;code&gt;UDP&lt;/code&gt;有差错检查，但它也只是丢弃这个包而已。应用程序采用&lt;code&gt;UDP&lt;/code&gt;的主要是基于效率的考虑。&lt;code&gt;UDP&lt;/code&gt;简单，所以效率高。本文不讨论&lt;code&gt;UDP&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;可靠数据传输&quot;&gt;&lt;a href=&quot;#可靠数据传输&quot; class=&quot;headerlink&quot; title=&quot;可靠数据传输&quot;&gt;&lt;/a&gt;可靠数据传输&lt;/h2&gt;&lt;p&gt;这一节我们从最简单的情况开始，针对各种情况，慢慢完善，最终形成一个可靠的数据传输协议。&lt;code&gt;TCP&lt;/code&gt;是一个&lt;code&gt;全双工&lt;/code&gt;的协议，双方可以互相发送信息。目前我们只考虑单向的传输。&lt;/p&gt;
&lt;h4 id=&quot;假设网络层可靠&quot;&gt;&lt;a href=&quot;#假设网络层可靠&quot; class=&quot;headerlink&quot; title=&quot;假设网络层可靠&quot;&gt;&lt;/a&gt;假设网络层可靠&lt;/h4&gt;&lt;p&gt;最开始我们先假设网络层是可靠的，也就是说我们交付给网络层的包不会丢失且完好无损，同时假设发送和接受双方速率是一样的。这种情况下我们需要考虑什么？什么都不需要考虑。就像&lt;code&gt;UDP&lt;/code&gt;一样，打包好交付给网络层即可。相当于在网络层实现了可靠传输。&lt;br&gt;
    
    </summary>
    
    
      <category term="Computer Network" scheme="http://threezj.com/tags/Computer-Network/"/>
    
  </entry>
  
  <entry>
    <title>MIT 6.828 lab5</title>
    <link href="http://threezj.com/2016/12/07/MIT%206.828%20lab5/"/>
    <id>http://threezj.com/2016/12/07/MIT 6.828 lab5/</id>
    <published>2016-12-07T08:03:06.000Z</published>
    <updated>2018-04-17T15:40:27.885Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>lab5</code>比较简单，相对于之前的<code>lab</code>来说。主要就是完成简单的文件系统。大部分代码<code>mit</code>都已经帮你搭好了。</p><h2 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise 1"></a>Exercise 1</h2><blockquote><p><code>i386_init</code> identifies the file system environment by passing the type <code>ENV_TYPE_FS</code> to your environment creation function, <code>env_create</code>. Modify <code>env_create</code> in env.c, so that it gives the file system environment I/O privilege, but never gives that privilege to any other environment</p></blockquote><p>启动<code>IO</code>驱动器，设置一下标志位即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(type == ENV_TYPE_FS)&#123;</span><br><span class="line">       e-&gt;env_tf.tf_eflags |= FL_IOPL_3;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="Question-1"><a href="#Question-1" class="headerlink" title="Question 1"></a>Question 1</h4><blockquote><p>Do you have to do anything else to ensure that this I/O privilege setting is saved and restored properly when you subsequently switch from one environment to another? Why?</p></blockquote><p>不需要。因为进程切换时会保存<code>Trapframe</code>。</p><h2 id="Exercise-2"><a href="#Exercise-2" class="headerlink" title="Exercise 2"></a>Exercise 2</h2><blockquote><p>Implement the <code>bc_pgfault</code> and <code>flush_block</code> functions in fs/bc.c. <code>bc_pgfault</code> is a page fault handler, just like the one your wrote in the previous lab for copy-on-write fork, except that its job is to load pages in from the disk in response to a page fault. When writing this, keep in mind that (1) <code>addr</code> may not be aligned to a block boundary and (2) <code>ide_read</code> operates in sectors, not blocks.</p></blockquote><p>我们用<code>3G</code>的内存地址来映射磁盘。从<code>DISKMAP</code>至<code>DISKMAP+DISKMAX</code>。但是不可能把整块磁盘的内容都加载到内存中来。所以我们采用类似于<code>COW</code>的方式，延迟到<code>page fault</code>时，再从磁盘中读取，这种方式抽象了整个磁盘都在内存中的假象，并且以有限的内存空间，支持更大的磁盘读取。</p><p><code>bc_pgfault</code> 当产生<code>page fault</code>，说明这一页还未读取到内存中，则先分配一页，然后进行读取。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">addr = ROUNDDOWN(addr, PGSIZE);</span><br><span class="line">   r = sys_page_alloc(<span class="number">0</span>, addr, PTE_P | PTE_U | PTE_W);</span><br><span class="line">   <span class="keyword">if</span>(r != <span class="number">0</span>)</span><br><span class="line">       panic(<span class="string">"bc.c: paga_alloc failed %e"</span>, r);</span><br><span class="line">   r = ide_read(blockno * BLKSECTS, addr, BLKSECTS);</span><br><span class="line">   <span class="keyword">if</span>(r != <span class="number">0</span>)</span><br><span class="line">       panic(<span class="string">"bc.c: ide_read failed %e"</span>, r);</span><br></pre></td></tr></table></figure><p><code>flush_block</code> 内存中的内容被修改之后，需要写回到磁盘中。因为本质上它就是一块<code>Cache</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flush_block</span><span class="params">(<span class="keyword">void</span> *addr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> blockno = ((<span class="keyword">uint32_t</span>)addr - DISKMAP) / BLKSIZE;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">if</span> (addr &lt; (<span class="keyword">void</span>*)DISKMAP || addr &gt;= (<span class="keyword">void</span>*)(DISKMAP + DISKSIZE))</span><br><span class="line">        panic(<span class="string">"flush_block of bad va %08x"</span>, addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(va_is_mapped(addr) &amp;&amp; va_is_dirty(addr)))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    addr = ROUNDDOWN(addr, PGSIZE);</span><br><span class="line">    <span class="keyword">if</span>(va_is_mapped(addr) &amp;&amp; va_is_dirty(addr))&#123;</span><br><span class="line">        r = ide_write(blockno * BLKSECTS, addr, BLKSECTS);</span><br><span class="line">        <span class="keyword">if</span>(r != <span class="number">0</span>)</span><br><span class="line">            panic(<span class="string">"flush_block: ide_write failed %e"</span>, r);</span><br><span class="line">        r = sys_page_map(<span class="number">0</span>, addr, <span class="number">0</span>, addr, uvpt[PGNUM(addr)] &amp; PTE_SYSCALL);</span><br><span class="line">        <span class="keyword">if</span>(r != <span class="number">0</span>)</span><br><span class="line">            panic(<span class="string">"flush_block: sys_page_map failed %e"</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise 3"></a>Exercise 3</h2><blockquote><p>Use <code>free_block</code> as a model to implement <code>alloc_block</code> in fs/fs.c, which should find a free disk block in the bitmap, mark it used, and return the number of that block. When you allocate a block, you should immediately flush the changed bitmap block to disk with <code>flush_block</code>, to help file system consistency.</p></blockquote><p><code>Jos</code>用<code>bitmap</code>来跟踪空闲块，这里比较简单，模仿<code>block_is_free</code>写即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">alloc_block</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; super-&gt;s_nblocks; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (block_is_free(i)) &#123;</span><br><span class="line">            bitmap[i / <span class="number">32</span>] &amp;= ~(<span class="number">1</span> &lt;&lt; ( i %<span class="number">32</span>));</span><br><span class="line">            flush_block(diskaddr(i + <span class="number">2</span>));</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -E_NO_DISK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise 4"></a>Exercise 4</h2><blockquote><p>Implement <code>file_block_walk</code> and <code>file_get_block</code>. <code>file_block_walk</code> maps from a block offset within a file to the pointer for that block in the <code>struct File</code> or the indirect block, very much like what <code>pgdir_walk</code> did for page tables. <code>file_get_block</code> goes one step further and maps to the actual disk block, allocating a new one if necessary.</p></blockquote><p><code>file_block_walk</code>查找文件的磁盘块。分为两种情况，一种是<code>direct blocks</code>，也就是前十个块，是直接存在<code>File</code>数据结构中的，而<code>indirect block</code>，是一个指针指向额外的数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">file_block_walk(struct File *f, <span class="keyword">uint32_t</span> filebno, <span class="keyword">uint32_t</span> **ppdiskbno, <span class="keyword">bool</span> alloc) &#123;</span><br><span class="line">    <span class="keyword">int</span> blockno;</span><br><span class="line">    <span class="keyword">if</span> (filebno &gt; NDIRECT + NINDIRECT)</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    <span class="keyword">if</span>(filebno &lt; NDIRECT)</span><br><span class="line">        *ppdiskbno = &amp;f-&gt;f_direct[filebno];</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!f-&gt;f_indirect) &#123;</span><br><span class="line">            <span class="keyword">if</span>(alloc)&#123;</span><br><span class="line">                blockno = alloc_block();</span><br><span class="line">                <span class="keyword">if</span>(blockno &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> -E_NO_DISK;</span><br><span class="line">                <span class="built_in">memset</span>(diskaddr(blockno), <span class="number">0</span>, BLKSIZE);</span><br><span class="line">                f-&gt;f_indirect = blockno;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> -E_NOT_FOUND;</span><br><span class="line">        &#125;</span><br><span class="line">        *ppdiskbno = &amp;((<span class="keyword">uintptr_t</span> *) diskaddr(f-&gt;f_indirect))[filebno - NDIRECT];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>file_get_block</code> 是对<code>file_block_walk</code>的调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">file_get_block(struct File *f, <span class="keyword">uint32_t</span> filebno, <span class="keyword">char</span> **blk) &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> *ppdiskbno;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    r = file_block_walk(f, filebno, &amp;ppdiskbno, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(r &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    <span class="keyword">if</span>(! (*ppdiskbno))&#123;</span><br><span class="line">        r = alloc_block();</span><br><span class="line">        <span class="keyword">if</span>(r &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -E_NO_DISK;</span><br><span class="line">        *ppdiskbno = r;</span><br><span class="line">    &#125;</span><br><span class="line">    *blk = diskaddr(*ppdiskbno);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Exercise-5"><a href="#Exercise-5" class="headerlink" title="Exercise 5"></a>Exercise 5</h2><blockquote><p>Implement <code>serve_read</code> in fs/serv.c。</p></blockquote><p>本质上所谓的文件系统，其实就是一个独立的进程负责读写磁盘。所以当其他进程想要通过文件系统来进行读写，那么只能通过<code>IPC</code>。更详细的过程，<code>MIT</code>讲义上写的很清楚。</p><p><code>serve_read</code>没什么难度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">serve_read(<span class="keyword">envid_t</span> envid, <span class="keyword">union</span> Fsipc *ipc) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_read</span> *<span class="title">req</span> = &amp;<span class="title">ipc</span>-&gt;<span class="title">read</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Fsret_read</span> *<span class="title">ret</span> = &amp;<span class="title">ipc</span>-&gt;<span class="title">readRet</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (debug)</span><br><span class="line">        cprintf(<span class="string">"serve_read %08x %08x %08x\n"</span>, envid, req-&gt;req_fileid, req-&gt;req_n);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">OpenFile</span> *<span class="title">o</span>;</span></span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">if</span> ((r = openfile_lookup(envid, req-&gt;req_fileid, &amp;o)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    r = file_read(o-&gt;o_file, ret-&gt;ret_buf, req-&gt;req_n, o-&gt;o_fd-&gt;fd_offset);</span><br><span class="line">    <span class="keyword">if</span>(r &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    o-&gt;o_fd-&gt;fd_offset += r;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Exercise-6"><a href="#Exercise-6" class="headerlink" title="Exercise 6"></a>Exercise 6</h2><blockquote><p>Implement <code>serve_write</code> in fs/serv.c and <code>devfile_write</code> in lib/file.c.</p></blockquote><p><code>serve_write</code> 参照着<code>serve_read</code>写就行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">serve_write(<span class="keyword">envid_t</span> envid, struct Fsreq_write *req) &#123;</span><br><span class="line">    <span class="keyword">if</span> (debug)</span><br><span class="line">        cprintf(<span class="string">"serve_write %08x %08x %08x\n"</span>, envid, req-&gt;req_fileid, req-&gt;req_n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LAB 5: Your code here.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">OpenFile</span> *<span class="title">o</span>;</span></span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">if</span> ((r = openfile_lookup(envid, req-&gt;req_fileid, &amp;o)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    r = file_write(o-&gt;o_file, req-&gt;req_buf, req-&gt;req_n, o-&gt;o_fd-&gt;fd_offset);</span><br><span class="line">    <span class="keyword">if</span>(r &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    o-&gt;o_fd-&gt;fd_offset += r;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>devfile_write</code>也一样。注意<code>fsipcbuf</code>是存放各种读写操作的联合体。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static ssize_t</span><br><span class="line">devfile_write(struct Fd *fd, const void *buf, size_t n) &#123;</span><br><span class="line">    int r;</span><br><span class="line"></span><br><span class="line">    fsipcbuf.write.req_fileid = fd-&gt;fd_file.id;</span><br><span class="line">    fsipcbuf.write.req_n = n &lt; PGSIZE ? n: PGSIZE;</span><br><span class="line">    memmove(fsipcbuf.write.req_buf, buf, fsipcbuf.write.req_n);</span><br><span class="line">    r = fsipc(FSREQ_WRITE, NULL);</span><br><span class="line">    return r;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Exercise-7"><a href="#Exercise-7" class="headerlink" title="Exercise 7"></a>Exercise 7</h2><blockquote><p><code>spawn</code> relies on the new syscall <code>sys_env_set_trapframe</code> to initialize the state of the newly created environment. Implement <code>sys_env_set_trapframe</code> in kern/syscall.c(don’t forget to dispatch the new system call in <code>syscall()</code>).</p></blockquote><p>这里我们简单来看下<code>spawn</code>函数，它的主要工作就是把从磁盘上加载用户与程序，并运行它。相当于把<code>fork</code>和<code>exec</code>结合到一个函数。</p><ol><li>打开文件，获取<code>Fd</code></li><li>读取<code>ELF</code>头，这一步和<code>load_icode</code>，只不过这里是从磁盘中读</li><li>创建子进程</li><li>把子进程的<code>eip</code>设置到程序的入口点</li><li>初始化栈</li><li>把所有需要加载的程序段加载到子程序的地址空间。到这里，文件操作完毕。</li><li>初始化进程状态</li></ol><p>更详细的大家去看代码，这里不赘述。</p><p> <code>sys_env_set_trapframe</code>很简单</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_env_set_trapframe(<span class="keyword">envid_t</span> envid, struct Trapframe *tf) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line">    <span class="keyword">int</span> r = envid2env(envid, &amp;env, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(r!=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    env-&gt;env_tf = *tf;</span><br><span class="line">    env-&gt;env_tf.tf_eflags |= FL_IF;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Exercise-8"><a href="#Exercise-8" class="headerlink" title="Exercise 8"></a>Exercise 8</h2><blockquote><p>Change <code>duppage</code> in lib/fork.c to follow the new convention. If the page table entry has the <code>PTE_SHARE</code> bit set, just copy the mapping directly. (You should use<code>PTE_SYSCALL</code>, not <code>0xfff</code>, to mask out the relevant bits from the page table entry. <code>0xfff</code> picks up the accessed and dirty bits as well.)</p><p>Likewise, implement <code>copy_shared_pages</code> in lib/spawn.c. It should loop through all page table entries in the current process (just like <code>fork</code> did), copying any page mappings that have the <code>PTE_SHARE</code> bit set into the child process.</p></blockquote><p>这里需要让<code>Fd</code>在进程之间共享。多添加了一个标志位，使其在<code>fork</code>时并不进行<code>COW</code>映射，而是直接映射，所以当<code>page fault</code>时，也不会进行<code>copy</code>.</p><p><code>duppage</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(uvpt[pn] &amp; PTE_SHARE)&#123;</span><br><span class="line">       <span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, addr, envid, addr, uvpt[pn] &amp; PTE_SYSCALL)) &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span> r;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><code>copy_shared_pages</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">copy_shared_pages(<span class="keyword">envid_t</span> child) &#123;</span><br><span class="line">    <span class="keyword">uintptr_t</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; USTACKTOP; i += PGSIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((uvpd[PDX(i)] &amp; PTE_P) &amp;&amp;</span><br><span class="line">            (uvpt[PGNUM(i)] &amp; PTE_P) &amp;&amp;</span><br><span class="line">            (uvpt[PGNUM(i)] &amp; PTE_SHARE))</span><br><span class="line">        &#123;</span><br><span class="line">            sys_page_map(<span class="number">0</span>, (<span class="keyword">void</span>*)i,</span><br><span class="line">                     child, (<span class="keyword">void</span>*)i,</span><br><span class="line">                     (uvpt[PGNUM(i)] &amp; PTE_SYSCALL));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Exercise-9"><a href="#Exercise-9" class="headerlink" title="Exercise 9"></a>Exercise 9</h2><blockquote><p>In your kern/trap.c, call <code>kbd_intr</code> to handle trap <code>IRQ_OFFSET+IRQ_KBD</code> and <code>serial_intr</code> to handle trap <code>IRQ_OFFSET+IRQ_SERIAL</code>.</p></blockquote><p>不解释</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (tf-&gt;tf_trapno == IRQ_OFFSET + IRQ_KBD) &#123;</span><br><span class="line">       kbd_intr();</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (tf-&gt;tf_trapno == IRQ_OFFSET + IRQ_SERIAL) &#123;</span><br><span class="line">       serial_intr();</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="Exercise-10"><a href="#Exercise-10" class="headerlink" title="Exercise 10"></a>Exercise 10</h2><blockquote><p>The shell doesn’t support I/O redirection. It would be nice to run sh &lt;script instead of having to type in all the commands in the script by hand, as you did above. Add I/O redirection for &lt; to <code>user/sh.c</code>.</p></blockquote><p>这个也不解释，在<code>xv6</code>那本书第一章中就有提到过实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((fd = open(t, O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           cprintf(<span class="string">"open %s for read: %e"</span>, t, fd);</span><br><span class="line">           <span class="built_in">exit</span>();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (fd != <span class="number">0</span>) &#123;</span><br><span class="line">           dup(fd, <span class="number">0</span>);</span><br><span class="line">           close(fd);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;lab5&lt;/code&gt;比较简单，相对于之前的&lt;code&gt;lab&lt;/code&gt;来说。主要就是完成简单的文件系统。大部分代码&lt;code&gt;mit&lt;/code&gt;都已经帮你搭好了。&lt;/p&gt;
&lt;h2 id=&quot;Exercise-1&quot;&gt;&lt;a href=&quot;#Exercise-1&quot; class=&quot;headerlink&quot; title=&quot;Exercise 1&quot;&gt;&lt;/a&gt;Exercise 1&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;i386_init&lt;/code&gt; identifies the file system environment by passing the type &lt;code&gt;ENV_TYPE_FS&lt;/code&gt; to your environment creation function, &lt;code&gt;env_create&lt;/code&gt;. Modify &lt;code&gt;env_create&lt;/code&gt; in env.c, so that it gives the file system environment I/O privilege, but never gives that privilege to any other environment&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;启动&lt;code&gt;IO&lt;/code&gt;驱动器，设置一下标志位即可。&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(type == ENV_TYPE_FS)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       e-&amp;gt;env_tf.tf_eflags |= FL_IOPL_3;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;Question-1&quot;&gt;&lt;a href=&quot;#Question-1&quot; class=&quot;headerlink&quot; title=&quot;Question 1&quot;&gt;&lt;/a&gt;Question 1&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;Do you have to do anything else to ensure that this I/O privilege setting is saved and restored properly when you subsequently switch from one environment to another? Why?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不需要。因为进程切换时会保存&lt;code&gt;Trapframe&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;Exercise-2&quot;&gt;&lt;a href=&quot;#Exercise-2&quot; class=&quot;headerlink&quot; title=&quot;Exercise 2&quot;&gt;&lt;/a&gt;Exercise 2&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Implement the &lt;code&gt;bc_pgfault&lt;/code&gt; and &lt;code&gt;flush_block&lt;/code&gt; functions in fs/bc.c. &lt;code&gt;bc_pgfault&lt;/code&gt; is a page fault handler, just like the one your wrote in the previous lab for copy-on-write fork, except that its job is to load pages in from the disk in response to a page fault. When writing this, keep in mind that (1) &lt;code&gt;addr&lt;/code&gt; may not be aligned to a block boundary and (2) &lt;code&gt;ide_read&lt;/code&gt; operates in sectors, not blocks.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们用&lt;code&gt;3G&lt;/code&gt;的内存地址来映射磁盘。从&lt;code&gt;DISKMAP&lt;/code&gt;至&lt;code&gt;DISKMAP+DISKMAX&lt;/code&gt;。但是不可能把整块磁盘的内容都加载到内存中来。所以我们采用类似于&lt;code&gt;COW&lt;/code&gt;的方式，延迟到&lt;code&gt;page fault&lt;/code&gt;时，再从磁盘中读取，这种方式抽象了整个磁盘都在内存中的假象，并且以有限的内存空间，支持更大的磁盘读取。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bc_pgfault&lt;/code&gt; 当产生&lt;code&gt;page fault&lt;/code&gt;，说明这一页还未读取到内存中，则先分配一页，然后进行读取。&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;addr = ROUNDDOWN(addr, PGSIZE);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   r = sys_page_alloc(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, addr, PTE_P | PTE_U | PTE_W);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(r != &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       panic(&lt;span class=&quot;string&quot;&gt;&quot;bc.c: paga_alloc failed %e&quot;&lt;/span&gt;, r);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   r = ide_read(blockno * BLKSECTS, addr, BLKSECTS);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(r != &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       panic(&lt;span class=&quot;string&quot;&gt;&quot;bc.c: ide_read failed %e&quot;&lt;/span&gt;, r);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;flush_block&lt;/code&gt; 内存中的内容被修改之后，需要写回到磁盘中。因为本质上它就是一块&lt;code&gt;Cache&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;flush_block&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *addr)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;uint32_t&lt;/span&gt; blockno = ((&lt;span class=&quot;keyword&quot;&gt;uint32_t&lt;/span&gt;)addr - DISKMAP) / BLKSIZE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; r;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (addr &amp;lt; (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;*)DISKMAP || addr &amp;gt;= (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;*)(DISKMAP + DISKSIZE))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        panic(&lt;span class=&quot;string&quot;&gt;&quot;flush_block of bad va %08x&quot;&lt;/span&gt;, addr);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!(va_is_mapped(addr) &amp;amp;&amp;amp; va_is_dirty(addr)))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    addr = ROUNDDOWN(addr, PGSIZE);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(va_is_mapped(addr) &amp;amp;&amp;amp; va_is_dirty(addr))&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        r = ide_write(blockno * BLKSECTS, addr, BLKSECTS);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(r != &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            panic(&lt;span class=&quot;string&quot;&gt;&quot;flush_block: ide_write failed %e&quot;&lt;/span&gt;, r);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        r = sys_page_map(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, addr, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, addr, uvpt[PGNUM(addr)] &amp;amp; PTE_SYSCALL);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(r != &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            panic(&lt;span class=&quot;string&quot;&gt;&quot;flush_block: sys_page_map failed %e&quot;&lt;/span&gt;, r);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Operating system" scheme="http://threezj.com/tags/Operating-system/"/>
    
      <category term="MIT 6.828" scheme="http://threezj.com/tags/MIT-6-828/"/>
    
  </entry>
  
  <entry>
    <title>MIT 6.828 lab4</title>
    <link href="http://threezj.com/2016/12/02/MIT%206.828%20lab4/"/>
    <id>http://threezj.com/2016/12/02/MIT 6.828 lab4/</id>
    <published>2016-12-02T15:04:06.000Z</published>
    <updated>2018-04-17T15:41:46.389Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>lab4</code>终于完成了。<code>lab4</code>是到目前为止，比较复杂而且代码最多的<code>lab</code>。总共需要完成三个部分。<code>part A</code>添加多核支持，实现<code>RR</code>调度。<code>part B</code>实现<code>Copy-On-Write fork</code>。<code>part C</code> 实现时钟中断以及支持基本的<code>IPC</code>。</p><h2 id="Part-A"><a href="#Part-A" class="headerlink" title="Part A"></a>Part A</h2><h4 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise 1"></a>Exercise 1</h4><blockquote><p>Implement <code>mmio_map_region</code> in kern/pmap.c. To see how this is used, look at the beginning of <code>lapic_init</code> in kern/lapic.c. You’ll have to do the next exercise, too, before the tests for <code>mmio_map_region</code> will run.</p></blockquote><p>实现需要让<code>Jos</code>支持<code>symmetric multiprocessing</code>，也就是所有的<code>cpu</code>都拥有相同的权限去访问资源。<code>Jos</code>使用<code>LAPIC</code>来分发中断，以及通过它来知道当前使用的<code>cpu</code>。而处理器访问<code>LAPIC</code>，需要使用<code>MMIO</code>。所以我们需要对<code>MMIO</code>进行内存映射，这个函数比较简单。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line">mmio_map_region(<span class="keyword">physaddr_t</span> pa, <span class="keyword">size_t</span> size) &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">uintptr_t</span> base = MMIOBASE;</span><br><span class="line"></span><br><span class="line">    size = ROUNDUP(size, PGSIZE);</span><br><span class="line">    <span class="keyword">if</span>(base + size &gt; MMIOLIM)&#123;</span><br><span class="line">        panic(<span class="string">"mmio_map_region: reservation mem overflow"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    boot_map_region(kern_pgdir, base, size, pa, PTE_W | PTE_PCD | PTE_P);</span><br><span class="line">    <span class="keyword">uintptr_t</span> b = base;</span><br><span class="line">    base += size;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span> *) b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="Exercise-2"><a href="#Exercise-2" class="headerlink" title="Exercise 2"></a>Exercise 2</h4><blockquote><p>Read <code>boot_aps()</code> and <code>mp_main()</code> in kern/init.c, and the assembly code in kern/mpentry.S. Make sure you understand the control flow transfer during the bootstrap of APs. Then modify your implementation of <code>page_init()</code> in kern/pmap.c to avoid adding the page at <code>MPENTRY_PADDR</code> to the free list, so that we can safely copy and run AP bootstrap code at that physical address. Your code should pass the updated <code>check_page_free_list()</code> test (but might fail the updated <code>check_kern_pgdir()</code> test, which we will fix soon).</p></blockquote><p><code>boot_aps()</code>首先把<code>mpentry.S</code>的代码复制到内存<code>MPENTRY_PADDR</code>中。然后对每个<code>cpu</code>都启动一个进程，也就是<code>APS</code>，进程栈保存在<code>percpu_kstacks</code>。最后通过<code>lapic_startap</code>发生中断跳到<code>mpentry.S</code>去执行。然后进行死循环等待<code>cpu进程</code>启动。<code>mpentry.S</code>的功能与<code>bootloader</code>类似，最后会跳转到<code>mp_main</code>。然后就是进行一些初始化，改变<code>cpu</code>状态为启动，通知<code>boot_aps()</code>可以进行<code>boot</code>下一个进程了。</p><p>所以这里我门需要为<code>MPENTRY_PADDR</code>留出一块空间来放<code>mpentry.S</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mpentry_i = PGNUM(MPENTRY_PADDR);</span><br><span class="line">   pages[mpentry_i + <span class="number">1</span>].pp_link = pages[mpentry_i].pp_link;</span><br><span class="line">   pages[mpentry_i].pp_link = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><h4 id="Question-1"><a href="#Question-1" class="headerlink" title="Question 1"></a>Question 1</h4><blockquote><p>Compare kern/mpentry.S side by side with boot/boot.S. Bearing in mind that kern/mpentry.S is compiled and linked to run above <code>KERNBASE</code> just like everything else in the kernel, what is the purpose of macro <code>MPBOOTPHYS</code>? Why is it necessary in kern/mpentry.S but not in boot/boot.S? In other words, what could go wrong if it were omitted in kern/mpentry.S?<br>Hint: recall the differences between the link address and the load address that we have discussed in Lab 1.</p></blockquote><p><code>MPBOOTPHYS</code>的作用是将高地址变为地址。因为根据注释上的说明，此次还处于实模式，但是代码中的地址已经经过重定位，所以需要进行地址翻译。</p><h4 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise 3"></a>Exercise 3</h4><blockquote><p>Modify <code>mem_init_mp()</code> (in kern/pmap.c) to map per-CPU stacks starting at <code>KSTACKTOP</code>, as shown in inc/memlayout.h. The size of each stack is <code>KSTKSIZE</code> bytes plus<code>KSTKGAP</code> bytes of unmapped guard pages. Your code should pass the new check in <code>check_kern_pgdir()</code>.</p></blockquote><p>为每个cpu栈分配内存，比较简单，按照<code>memlayout</code>来就行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">mem_init_mp(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="keyword">uintptr_t</span> kstacktop_i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NCPU; i++)&#123;</span><br><span class="line">        kstacktop_i = KSTACKTOP - i * (KSTKSIZE + KSTKGAP);</span><br><span class="line">        boot_map_region(kern_pgdir, kstacktop_i - KSTKSIZE, KSTKSIZE,</span><br><span class="line">        PADDR(percpu_kstacks[i]), PTE_W);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise 4"></a>Exercise 4</h4><blockquote><p>The code in <code>trap_init_percpu()</code> (kern/trap.c) initializes the TSS and TSS descriptor for the BSP. It worked in Lab 3, but is incorrect when running on other CPUs. Change the code so that it can work on all CPUs. (Note: your new code should not use the global <code>ts</code> variable any more.)</p></blockquote><p>初始化每个cpu进程，这里也没什么好说的，照着注释写即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">trap_init_percpu(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> i = cpunum();</span><br><span class="line">    <span class="comment">// Setup a TSS so that we get the right stack</span></span><br><span class="line">    <span class="comment">// when we trap to the kernel.</span></span><br><span class="line">    thiscpu-&gt;cpu_ts.ts_esp0 = (<span class="keyword">uintptr_t</span>)percpu_kstacks[i];</span><br><span class="line">    <span class="comment">//thiscpu-&gt;cpu_ts.ts_esp0 = KSTACKTOP - i * (KSTKSIZE + KSTKGAP);</span></span><br><span class="line">    thiscpu-&gt;cpu_ts.ts_ss0 = GD_KD;</span><br><span class="line">    thiscpu-&gt;cpu_ts.ts_iomb = <span class="keyword">sizeof</span>(struct Taskstate);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize the TSS slot of the gdt.</span></span><br><span class="line">    gdt[(GD_TSS0 &gt;&gt; <span class="number">3</span>) + i] = SEG16(STS_T32A, (<span class="keyword">uint32_t</span>) (&amp;thiscpu-&gt;cpu_ts),</span><br><span class="line">                    <span class="keyword">sizeof</span>(struct Taskstate) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    gdt[(GD_TSS0 &gt;&gt; <span class="number">3</span>) + i].sd_s = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Load the TSS selector (like other segment selectors, the</span></span><br><span class="line">    <span class="comment">// bottom three bits are special; we leave them 0)</span></span><br><span class="line">    ltr(GD_TSS0 + (i &lt;&lt; <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Load the IDT</span></span><br><span class="line">    lidt(&amp;idt_pd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Exercise-5"><a href="#Exercise-5" class="headerlink" title="Exercise 5"></a>Exercise 5</h4><blockquote><p>Apply the big kernel lock as described above, by calling <code>lock_kernel()</code> and <code>unlock_kernel()</code> at the proper locations.</p></blockquote><p>现在有多个<code>cpu</code>进程都能运行<code>kernel</code>，所以现在必须要解决进程间资源竞争的问题，这里直接套了一个大锁，进程进入<code>kernel</code>的时候上锁，退出的时候释放。。。略邪恶。这里需要贴的地方比较多，但代码比较简单，我就不放了。需要的可以去<code>github</code>上找。</p><h4 id="Question-2"><a href="#Question-2" class="headerlink" title="Question 2"></a>Question 2</h4><blockquote><p>It seems that using the big kernel lock guarantees that only one CPU can run the kernel code at a time. Why do we still need separate kernel stacks for each CPU? Describe a scenario in which using a shared kernel stack will go wrong, even with the protection of the big kernel lock.</p></blockquote><p>这个问题采用了<a href="https://github.com/Al--Zn/JOS/tree/lab4" target="_blank" rel="noopener">AL–Zn</a>的回答。中断发生时会自动压栈，而这时候还没有取得锁，若多个CPU同时发生中断，共享内核栈将会出错。</p><h4 id="Exercise-6"><a href="#Exercise-6" class="headerlink" title="Exercise 6"></a>Exercise 6</h4><blockquote><p>Implement round-robin scheduling in <code>sched_yield()</code> as described above. Don’t forget to modify <code>syscall()</code> to dispatch <code>sys_yield()</code>.<br>Make sure to invoke <code>sched_yield()</code> in <code>mp_main</code>.<br>Modify <code>kern/init.c</code> to create three (or more!) environments that all run the program <code>user/yield.c</code></p></blockquote><p>实现<code>RR</code>调度。顺序循环进行遍历进程，从当前进程开始找，直到找到第一个<code>ENV_RUNNABLE</code>的进程，并运行它。具体细节参照注释。实现如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">sched_yield(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> cur_idx;</span><br><span class="line">    <span class="keyword">if</span> (curenv)</span><br><span class="line">        cur_idx = ENVX(curenv-&gt;env_id);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cur_idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(envs[cur_idx].env_status == ENV_RUNNABLE)&#123;</span><br><span class="line">        env_run(&amp;envs[cur_idx]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = cur_idx + <span class="number">1</span>; i != cur_idx; i = (i + <span class="number">1</span>) % NENV)&#123;</span><br><span class="line">        <span class="keyword">if</span>(envs[i].env_status == ENV_RUNNABLE)&#123;</span><br><span class="line">            env_run(&amp;envs[i]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(curenv &amp;&amp; curenv-&gt;env_status == ENV_RUNNING) &#123;</span><br><span class="line">        env_run(curenv);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sched_halt never returns</span></span><br><span class="line">    sched_halt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Question-3"><a href="#Question-3" class="headerlink" title="Question 3"></a>Question 3</h4><blockquote><p>In your implementation of <code>env_run()</code> you should have called <code>lcr3()</code>. Before and after the call to <code>lcr3()</code>, your code makes references (at least it should) to the variable<code>e</code>, the argument to <code>env_run</code>. Upon loading the <code>%cr3</code> register, the addressing context used by the MMU is instantly changed. But a virtual address (namely <code>e</code>) has meaning relative to a given address context–the address context specifies the physical address to which the virtual address maps. Why can the pointer <code>e</code> be dereferenced both before and after the addressing switch?</p></blockquote><p>因为<code>mem_init()</code>时是以<code>kernel pgdir</code>为模板的</p><h4 id="Question-4"><a href="#Question-4" class="headerlink" title="Question 4"></a>Question 4</h4><blockquote><p>Whenever the kernel switches from one environment to another, it must ensure the old environment’s registers are saved so they can be restored properly later. Why? Where does this happen?</p></blockquote><p>当然需要保存。不然进程切换时无法恢复啊。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy trap frame (which is currently on the stack)</span></span><br><span class="line"><span class="comment">// into 'curenv-&gt;env_tf', so that running the environment</span></span><br><span class="line">   <span class="comment">// will restart at the trap point.</span></span><br><span class="line">   curenv-&gt;env_tf = *tf;</span><br></pre></td></tr></table></figure><h4 id="Exercise-7"><a href="#Exercise-7" class="headerlink" title="Exercise 7"></a>Exercise 7</h4><blockquote><p>Implement the system calls described above in kern/syscall.c. You will need to use various functions in kern/pmap.c and kern/env.c, particularly <code>envid2env()</code>. For now, whenever you call <code>envid2env()</code>, pass 1 in the <code>checkperm</code> parameter. Be sure you check for any invalid system call arguments, returning <code>-E_INVAL</code> in that case. Test your JOS kernel with user/dumbfork and make sure it works before proceeding.</p></blockquote><p>这里虽然看起来需要实现的代码很多，其实并不难，因为注释很详细，需要完成的任务也简单。</p><p><code>sys_exofork</code>这里的<code>fork</code>，只是单纯分配了一块地址空间给进程，但里面是空的，所以目前进程还是不可运行。具体做法也很直观，下面是实现，注意要把子进程返回值的寄存器设为0.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">envid_t</span></span><br><span class="line">sys_exofork(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">child_env</span>;</span></span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    r = env_alloc(&amp;child_env, curenv-&gt;env_id);</span><br><span class="line">    <span class="keyword">if</span>(r!=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    child_env-&gt;env_status = ENV_NOT_RUNNABLE;</span><br><span class="line">    child_env-&gt;env_tf = curenv-&gt;env_tf;</span><br><span class="line">    child_env-&gt;env_tf.tf_regs.reg_eax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> child_env-&gt;env_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sys_env_set_status</code>设置状态，不多说。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_env_set_status(<span class="keyword">envid_t</span> envid, <span class="keyword">int</span> status) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line">    <span class="keyword">int</span> r = envid2env(envid, &amp;env, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(r!=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    <span class="keyword">if</span>(env-&gt;env_status == ENV_RUNNABLE || env-&gt;env_status == ENV_NOT_RUNNABLE)&#123;</span><br><span class="line">        env-&gt;env_status = status;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sys_page_alloc</code> 分配页的系统调用，不难，比较烦的是权限检查。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_page_alloc(<span class="keyword">envid_t</span> envid, <span class="keyword">void</span> *va, <span class="keyword">int</span> perm) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line">    <span class="keyword">int</span> r = envid2env(envid, &amp;env, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(r!=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    <span class="keyword">if</span> (va &gt; (<span class="keyword">void</span> *) UTOP || va != ROUNDDOWN(va, PGSIZE))</span><br><span class="line">       <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    <span class="keyword">int</span> flag = PTE_U | PTE_P;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((perm &amp; flag) != flag)</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (perm &amp; (~(PTE_U | PTE_P | PTE_AVAIL | PTE_W)))</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp</span> = <span class="title">page_alloc</span>(1);</span></span><br><span class="line">    <span class="keyword">if</span>(pp == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">    pp-&gt;pp_ref ++;</span><br><span class="line">    r = page_insert(env-&gt;env_pgdir, pp, va, perm);</span><br><span class="line">    <span class="keyword">if</span>(r!=<span class="number">0</span>)&#123;</span><br><span class="line">        page_free(pp);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sys_page_map</code>，页的映射，用来两个进程通信时使用，使两块地址空间的部分内容映射到同一块物理地址。也不难。。还是烦在地址检查。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_page_map(<span class="keyword">envid_t</span> srcenvid, <span class="keyword">void</span> *srcva,</span><br><span class="line">         <span class="keyword">envid_t</span> dstenvid, <span class="keyword">void</span> *dstva, <span class="keyword">int</span> perm) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">srcenv</span>, *<span class="title">dstenv</span>;</span></span><br><span class="line">    <span class="keyword">int</span> r = envid2env(srcenvid, &amp;srcenv, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(r!=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    r = envid2env(dstenvid, &amp;dstenv, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(r!=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (srcva &gt;= (<span class="keyword">void</span> *) UTOP || dstva &gt;= (<span class="keyword">void</span> *) UTOP ||</span><br><span class="line">        srcva != ROUNDDOWN(srcva, PGSIZE) || dstva != ROUNDDOWN(dstva, PGSIZE))</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pte_t</span> *pte;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp</span> = <span class="title">page_lookup</span>(<span class="title">srcenv</span>-&gt;<span class="title">env_pgdir</span>, <span class="title">srcva</span>, &amp;<span class="title">pte</span>);</span></span><br><span class="line">    <span class="keyword">if</span>(pp == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((!(perm &amp; (PTE_U | PTE_P))) || (perm &amp; (~(PTE_U | PTE_P | PTE_AVAIL | PTE_W))))</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((perm &amp; PTE_W) &amp;&amp; !(*pte &amp; PTE_W))</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line"></span><br><span class="line">    r = page_insert(dstenv-&gt;env_pgdir, pp, dstva, perm);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sys_page_unmap</code>不多说</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_page_unmap(<span class="keyword">envid_t</span> envid, <span class="keyword">void</span> *va) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line">    <span class="keyword">int</span> r = envid2env(envid, &amp;env, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(r!=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    <span class="keyword">if</span> (va &gt; (<span class="keyword">void</span> *)UTOP || va != ROUNDDOWN(va, PGSIZE))</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line"></span><br><span class="line">    page_remove(env-&gt;env_pgdir, va);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Part-B"><a href="#Part-B" class="headerlink" title="Part B"></a>Part B</h2><p><code>Part B</code>的任务主要是实现<code>Copy-on-Write Fork</code>，也就是所谓的写时拷贝技术。传统的<code>fork</code>函数，调用时会直接将父进程的内存内容拷贝到子进程当中了，但是大多数是程序，当<code>fork</code>之后就直接调用<code>exec()</code>填充新的内存内容了。所以拷贝这一步很浪费时间。所以现在采用的做法是<code>COW fork</code>，也就是把拷贝的时间推迟到子进程需要写入的时候。这种做法用的很多，比如<code>cache</code>更新的情况。</p><p>具体做法是，当<code>fork</code>调用时，把子进程的用户空间的地址都映射到父进程时，并且设置权限位，直到子进程需要写内存的时候，权限判断失败，并触发<code>page fault</code>，然后进行系统分配页，把需要写入的那一页内存<code>copy</code>出来，并分配到子进程的地址空间中。</p><p>所以在写<code>COW Fork</code>之前，首先需要处理在用户空间<code>page fault</code>的情况。</p><h4 id="Exercise-8"><a href="#Exercise-8" class="headerlink" title="Exercise 8"></a>Exercise 8</h4><blockquote><p>Implement the <code>sys_env_set_pgfault_upcall</code> system call. Be sure to enable permission checking when looking up the environment ID of the target environment, since this is a “dangerous” system call</p></blockquote><p>这个很简单了，就是设置<code>pgfault</code>时需要调用的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_env_set_pgfault_upcall(<span class="keyword">envid_t</span> envid, <span class="keyword">void</span> *func) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line">    <span class="keyword">int</span> r = envid2env(envid, &amp;env, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(r!=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    env-&gt;env_pgfault_upcall = func;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Exercise-9"><a href="#Exercise-9" class="headerlink" title="Exercise 9"></a>Exercise 9</h4><blockquote><p>Implement the code in <code>page_fault_handler</code> in kern/trap.c required to dispatch page faults to the user-mode handler. Be sure to take appropriate precautions when writing into the exception stack. (What happens if the user environment runs out of space on the exception stack?)</p></blockquote><p>这个函数比较复杂。因为这里涉及到栈的切换。当<code>kernel</code>处理<code>page_fault</code>时，并不是在<code>kernel栈</code>或者<code>用户栈</code>处理，而是启用了一个新的栈，<code>用户异常栈</code>。并且使用一个新的数据结构<code>UTrapframe</code>来保存触发<code>page_fault</code>的进程信息。所以现在用户空间的缺页流程是这样的的，用户空间发生缺页，产生中断，陷入到内核中，分发到<code>page_fault_handler</code>中，在<code>用户异常栈</code>保存错误进程的信息，以及错误地址(保存到<code>UTrapframe</code>中)，切换到<code>用户异常栈</code>，然后调用用户自定义的<code>pgfault_upcall</code>，最后再切换到原来错误的地方继续运行。</p><p>栈的切换分成两种情况。</p><ul><li>用户进程发生<code>page_fault</code>。<code>用户栈</code> -&gt; <code>kernel栈</code> -&gt; <code>用户异常栈</code></li><li>在<code>page_fault</code>处理时又发生<code>page_fault</code>。虽然已经在用户异常栈了，但还是会继续陷入到内核中，重走一遍上面的流程，这里需要注意，压入<code>UTrapframe</code>时，需要空<code>4</code>个字节。所以栈切换顺序为，<code>用户异常栈</code> -&gt; <code>kernel栈</code> -&gt; <code>用户异常栈</code></li></ul><p>好，现在情况应该比较清楚了。所以目前这个函数需要做的就是在<code>用户异常栈</code>中压入<code>UTrapframe</code>数据结构，并保存错误进程的信息，以便之后恢复重新运行。这里有一点要注意，就是有可能发生上面说的第二种情况，所以需要判断进程的栈地址是不是已经在<code>用户异常栈</code>了，然后需要多压<code>4字节</code>，另外别忘了检查地址用完的情况。代码如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(curenv-&gt;env_pgfault_upcall!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">UTrapframe</span> *<span class="title">utf</span>;</span></span><br><span class="line">       <span class="keyword">uintptr_t</span> utf_addr;</span><br><span class="line">       <span class="keyword">if</span>(tf-&gt;tf_esp &gt;= UXSTACKTOP - PGSIZE &amp;&amp; tf-&gt;tf_esp &lt; UXSTACKTOP)&#123;</span><br><span class="line">           utf_addr = tf-&gt;tf_esp - <span class="keyword">sizeof</span>(struct UTrapframe) - <span class="number">4</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span>&#123;</span><br><span class="line">           utf_addr = UXSTACKTOP - <span class="keyword">sizeof</span>(struct UTrapframe);</span><br><span class="line">       &#125;</span><br><span class="line">       user_mem_assert(curenv, (<span class="keyword">void</span> *) utf_addr, <span class="keyword">sizeof</span>(struct UTrapframe), PTE_W);</span><br><span class="line"></span><br><span class="line">       utf = (struct UTrapframe *) utf_addr;</span><br><span class="line">       utf-&gt;utf_fault_va = fault_va;</span><br><span class="line">       utf-&gt;utf_err = tf-&gt;tf_err;</span><br><span class="line">       utf-&gt;utf_regs = tf-&gt;tf_regs;</span><br><span class="line">       utf-&gt;utf_eip = tf-&gt;tf_eip;</span><br><span class="line">       utf-&gt;utf_eflags = tf-&gt;tf_eflags;</span><br><span class="line">       utf-&gt;utf_esp = tf-&gt;tf_esp;</span><br><span class="line"></span><br><span class="line">       tf-&gt;tf_eip = (<span class="keyword">uintptr_t</span>) curenv-&gt;env_pgfault_upcall;</span><br><span class="line">       tf-&gt;tf_esp = utf_addr;</span><br><span class="line">       env_run(curenv);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="Exercise-10"><a href="#Exercise-10" class="headerlink" title="Exercise 10"></a>Exercise 10</h4><blockquote><p>Implement the <code>_pgfault_upcall</code> routine in lib/pfentry.S. The interesting part is returning to the original point in the user code that caused the page fault. You’ll return directly there, without going back through the kernel. The hard part is simultaneously switching stacks and re-loading the EIP.</p></blockquote><p>这是我最头疼的部分。这段汇编先调用了用户自定义的<code>page_handler</code>函数，然后需要根据之前压入的<code>UTrapframe</code>来切换为发生的错误的进程继续运行。这里我用了<code>PKU张弛</code>的代码。。他貌似也是用了别人的代码。。。我没有过多去纠结这段代码。大致是把返回的错误地址填到之前空的<code>4</code>个字节处，再加点<code>trick</code>，就可以同时切换<code>esp</code>和<code>eip</code>。下面是代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">movl 0x28(%esp), %eax</span><br><span class="line">subl $0x4, 0x30(%esp)</span><br><span class="line">movl 0x30(%esp), %edx</span><br><span class="line">movl %eax, (%edx)</span><br><span class="line">addl $0x8, %esp</span><br><span class="line"></span><br><span class="line">// Restore the trap-time registers.  After you do this, you</span><br><span class="line">// can no longer modify any general-purpose registers.</span><br><span class="line">popal</span><br><span class="line"></span><br><span class="line">// Restore eflags from the stack.  After you do this, you can</span><br><span class="line">// no longer use arithmetic operations or anything else that</span><br><span class="line">// modifies eflags.</span><br><span class="line">addl $0x4, %esp</span><br><span class="line">popfl</span><br><span class="line">// Switch back to the adjusted trap-time stack.</span><br><span class="line">// LAB 4: Your code here.</span><br><span class="line">popl %esp</span><br><span class="line">// Return to re-execute the instruction that faulted.</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><h4 id="Exercise-11"><a href="#Exercise-11" class="headerlink" title="Exercise 11"></a>Exercise 11</h4><blockquote><p>Finish <code>set_pgfault_handler()</code> in lib/pgfault.c.</p></blockquote><p>最后就简单了，为<code>用户异常栈</code>分配页，已经设置<code>upcall</code>调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">set_pgfault_handler(<span class="keyword">void</span> (*handler)(struct UTrapframe *utf)) &#123;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">if</span> (_pgfault_handler == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(sys_page_alloc(thisenv-&gt;env_id,</span><br><span class="line">                          (<span class="keyword">void</span> *) (UXSTACKTOP - PGSIZE), PTE_U|PTE_P|PTE_W) != <span class="number">0</span>)&#123;</span><br><span class="line">            panic(<span class="string">"set_pgfault_handler: sys_page_alloc failed"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sys_env_set_pgfault_upcall(thisenv-&gt;env_id, _pgfault_upcall) != <span class="number">0</span>)&#123;</span><br><span class="line">            panic(<span class="string">"set_pgfault_handler: sys_env_set_pgfault_upcall failed"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Save handler pointer for assembly to call.</span></span><br><span class="line">    _pgfault_handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个个过程非常<code>trick</code>，十分有趣。其实绕这么一大圈，最终的目的还是为了保护<code>kernel</code>！</p><h4 id="Exercise-12"><a href="#Exercise-12" class="headerlink" title="Exercise 12"></a>Exercise 12</h4><blockquote><p>Implement <code>fork</code>, <code>duppage</code> and <code>pgfault</code> in lib/fork.c.</p></blockquote><p>还没完。。。高潮才刚刚到来。前面搞了这么多，都只是为了实现<code>COW Fork</code>！。因为我门需要把<code>COW Fork</code>作为自定义函数库来实现。所以前面弄了这么多，只有一个目的，那就是在用户进程中<code>handle page fault</code>。</p><p>关与具体实现，其实<code>mit</code>的讲义上已经很清楚了。大致就是说把<code>UTOP</code>以下的地址都通过<code>duppage</code>进行映射到同一块物理地址上，当子进程发生缺页时，才通过<code>pgfault</code>来分配页。具体细节不赘述。</p><p>下面是代码。</p><p><code>fork</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">envid_t</span> fork(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="keyword">envid_t</span> envid;</span><br><span class="line">    <span class="keyword">uintptr_t</span> addr;</span><br><span class="line"></span><br><span class="line">    set_pgfault_handler(&amp;pgfault);</span><br><span class="line">    envid = sys_exofork();</span><br><span class="line">    <span class="keyword">if</span>(envid &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">"fork: sys_exofork failed"</span>);</span><br><span class="line">    <span class="keyword">if</span>(envid == <span class="number">0</span>)&#123;</span><br><span class="line">        thisenv = &amp;envs[ENVX(sys_getenvid())];</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (addr = <span class="number">0</span>; addr &lt; USTACKTOP; addr += PGSIZE) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((uvpd[PDX(addr)] &amp; PTE_P) &amp;&amp; (uvpt[PGNUM(addr)] &amp; PTE_P))</span><br><span class="line">            duppage(envid, PGNUM(addr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sys_page_alloc(envid, (<span class="keyword">void</span> *) (UXSTACKTOP - PGSIZE),</span><br><span class="line">                    PTE_P | PTE_U | PTE_W) &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">"fork: sys_page_alloc failed"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">void</span> _pgfault_upcall();</span><br><span class="line">    sys_env_set_pgfault_upcall(envid, _pgfault_upcall);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sys_env_set_status(envid, ENV_RUNNABLE) != <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">"fork: sys_env_set_status"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> envid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>duppage</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">duppage</span><span class="params">(<span class="keyword">envid_t</span> envid, <span class="keyword">unsigned</span> pn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">void</span> *addr = (<span class="keyword">void</span> *)(pn * PGSIZE);</span><br><span class="line">    <span class="keyword">if</span> ((uvpt[pn] &amp; PTE_W) || (uvpt[pn] &amp; PTE_COW)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, addr, envid, addr, PTE_P | PTE_U | PTE_COW)) &lt; <span class="number">0</span>)</span><br><span class="line">            panic(<span class="string">"duppage: %e"</span>, r);</span><br><span class="line">        <span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, addr, <span class="number">0</span>, addr, PTE_P | PTE_U | PTE_COW)) &lt; <span class="number">0</span>)</span><br><span class="line">            panic(<span class="string">"duppage: %e"</span>, r);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, addr, envid, addr, PTE_P | PTE_U)) &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">"duppage: %e"</span>, r);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>pafault</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">pgfault(struct UTrapframe *utf) &#123;</span><br><span class="line">    <span class="keyword">void</span> *addr = (<span class="keyword">void</span> *) utf-&gt;utf_fault_va;</span><br><span class="line">    <span class="keyword">uint32_t</span> err = utf-&gt;utf_err;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pte_t</span> pte = ((<span class="keyword">pte_t</span> *) uvpt)[PGNUM(addr)];</span><br><span class="line">    <span class="keyword">if</span>(!( (err &amp; FEC_WR) != <span class="number">0</span> &amp;&amp; (pte &amp; PTE_COW)!=<span class="number">0</span> ))&#123;</span><br><span class="line">        panic(<span class="string">"pgfault: not write and not a COW page"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addr = ROUNDDOWN(addr, PGSIZE);</span><br><span class="line">    <span class="keyword">envid_t</span> envid = sys_getenvid();</span><br><span class="line">    <span class="keyword">if</span> ((r = sys_page_alloc(envid, PFTEMP, PTE_P | PTE_U | PTE_W)) &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">"pgfault: %e"</span>, r);</span><br><span class="line">    <span class="built_in">memcpy</span>(PFTEMP, addr, PGSIZE);</span><br><span class="line">    <span class="keyword">if</span> ((r = sys_page_map(envid, PFTEMP, envid, addr, PTE_P | PTE_U | PTE_W)) &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">"pgfault: %e"</span>, r);</span><br><span class="line">    <span class="keyword">if</span> ((r = sys_page_unmap(envid, PFTEMP)) &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">"pgfault: %e"</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>精彩的<code>Part B</code>！</p><h2 id="Part-C"><a href="#Part-C" class="headerlink" title="Part C"></a>Part C</h2><p>实现基本的IPC通信，这部分代码还比较简单。</p><h4 id="Exercise-13"><a href="#Exercise-13" class="headerlink" title="Exercise 13"></a>Exercise 13</h4><blockquote><p>Modify kern/trapentry.S and kern/trap.c to initialize the appropriate entries in the IDT and provide handlers for IRQs 0 through 15. Then modify the code in<code>env_alloc()</code> in kern/env.c to ensure that user environments are always run with interrupts enabled.</p></blockquote><p>很简单，像之前注册中断门，这里需要参考<code>intel</code>手册注册相应的IPC门。代码略去。</p><p>完成之后，<code>Jos</code>就能进行时钟中断了。</p><h4 id="Exercise-14"><a href="#Exercise-14" class="headerlink" title="Exercise 14"></a>Exercise 14</h4><blockquote><p>Modify the kernel’s <code>trap_dispatch()</code> function so that it calls <code>sched_yield()</code> to find and run a different environment whenever a clock interrupt takes place.</p><p>You should now be able to get the user/spin test to work: the parent environment should fork off the child, <code>sys_yield()</code> to it a couple times but in each case regain control of the CPU after one time slice, and finally kill the child environment and terminate gracefully.</p></blockquote><p>处理时钟中断。防止进程死循环一直霸占<code>cpu</code>，所以需要在时钟中断处，重新调度进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (tf-&gt;tf_trapno == IRQ_OFFSET + IRQ_TIMER) &#123;</span><br><span class="line">       lapic_eoi();</span><br><span class="line">       sched_yield();</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="Exercise-15"><a href="#Exercise-15" class="headerlink" title="Exercise 15"></a>Exercise 15</h4><blockquote><p>Implement <code>sys_ipc_recv</code> and <code>sys_ipc_try_send</code> in kern/syscall.c. Read the comments on both before implementing them, since they have to work together. When you call <code>envid2env</code> in these routines, you should set the <code>checkperm</code> flag to 0, meaning that any environment is allowed to send IPC messages to any other environment, and the kernel does no special permission checking other than verifying that the target envid is valid.</p><p>Then implement the <code>ipc_recv</code> and <code>ipc_send</code> functions in lib/ipc.c.</p></blockquote><p>这几个函数都很好写，因为注释很详细！</p><p><code>sys_ipc_recv</code>，这里等待接受信息，只需要改变进程状态，直接调度就会阻塞了。我一开始没反应过来还弄了死循环。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_ipc_recv(<span class="keyword">void</span> *dstva) &#123;</span><br><span class="line">    <span class="keyword">if</span>(dstva &lt; (<span class="keyword">void</span> *)UTOP &amp;&amp; dstva != ROUNDDOWN(dstva, PGSIZE))&#123;</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    curenv-&gt;env_ipc_recving =<span class="literal">true</span>;</span><br><span class="line">    curenv-&gt;env_ipc_dstva = dstva;</span><br><span class="line">    curenv-&gt;env_status = ENV_NOT_RUNNABLE;</span><br><span class="line">    sys_yield();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sys_ipc_try_send</code>需要注意一点就是共享内存时，不能直接使用<code>sys_page_map</code>，因为<code>sys_page_map</code>查找<code>env</code>时会检查权限。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_ipc_try_send(<span class="keyword">envid_t</span> envid, <span class="keyword">uint32_t</span> value, <span class="keyword">void</span> *srcva, <span class="keyword">unsigned</span> perm) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line">    <span class="keyword">int</span> r = envid2env(envid, &amp;env, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> flag = PTE_U | PTE_P;</span><br><span class="line">    <span class="keyword">if</span>(r!=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    <span class="keyword">if</span>(!env-&gt;env_ipc_recving)</span><br><span class="line">        <span class="keyword">return</span> -E_IPC_NOT_RECV;</span><br><span class="line">    <span class="keyword">if</span>(srcva &lt; (<span class="keyword">void</span> *) UTOP)&#123;</span><br><span class="line">        <span class="keyword">if</span>(srcva != ROUNDUP(srcva, PGSIZE))</span><br><span class="line">            <span class="keyword">return</span> -E_INVAL;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">pte_t</span> *pte;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp</span> = <span class="title">page_lookup</span>(<span class="title">curenv</span>-&gt;<span class="title">env_pgdir</span>, <span class="title">srcva</span>, &amp;<span class="title">pte</span>);</span></span><br><span class="line">        <span class="keyword">if</span>(pp == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> -E_INVAL;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((!(perm &amp; (PTE_U | PTE_P))) ||</span><br><span class="line">            (perm &amp; (~(PTE_U | PTE_P | PTE_AVAIL | PTE_W))))</span><br><span class="line">            <span class="keyword">return</span> -E_INVAL;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((perm &amp; PTE_W) &amp;&amp; !(*pte &amp; PTE_W))</span><br><span class="line">            <span class="keyword">return</span> -E_INVAL;</span><br><span class="line"></span><br><span class="line">        r = page_insert(env-&gt;env_pgdir, pp, env-&gt;env_ipc_dstva, perm);</span><br><span class="line">        <span class="keyword">if</span>(r!=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    env-&gt;env_ipc_value = value;</span><br><span class="line">    env-&gt;env_ipc_recving = <span class="literal">false</span>;</span><br><span class="line">    env-&gt;env_ipc_from = curenv-&gt;env_id;</span><br><span class="line">    env-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line">    env-&gt;env_tf.tf_regs.reg_eax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是函数库的两个函数，是对上面两个系统调用的包装，让用户使用更为方便。没啥可说的，看代码把。</p><p><code>ipc_recv</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int32_t</span></span><br><span class="line">ipc_recv(<span class="keyword">envid_t</span> *from_env_store, <span class="keyword">void</span> *pg, <span class="keyword">int</span> *perm_store) &#123;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">if</span>(!pg)&#123;</span><br><span class="line">        pg = (<span class="keyword">void</span> *) <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    r = sys_ipc_recv(pg);</span><br><span class="line">    <span class="keyword">if</span>(r==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(from_env_store)</span><br><span class="line">            *from_env_store = thisenv-&gt;env_ipc_from;</span><br><span class="line">        <span class="keyword">if</span>(perm_store)</span><br><span class="line">            *perm_store = thisenv-&gt;env_ipc_perm;</span><br><span class="line">        <span class="keyword">return</span> thisenv-&gt;env_ipc_value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        *from_env_store = <span class="number">0</span>;</span><br><span class="line">        *perm_store = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ipc_send</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">ipc_send(<span class="keyword">envid_t</span> to_env, <span class="keyword">uint32_t</span> val, <span class="keyword">void</span> *pg, <span class="keyword">int</span> perm) &#123;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">if</span>(!pg)</span><br><span class="line">        pg = (<span class="keyword">void</span> *) <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        r = sys_ipc_try_send(to_env, val, pg, perm);</span><br><span class="line">        <span class="keyword">if</span>(r == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(r != -E_IPC_NOT_RECV)</span><br><span class="line">            panic(<span class="string">"ipc_send:%e"</span>, r);</span><br><span class="line">        sys_yield();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>lab4</code>完。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;lab4&lt;/code&gt;终于完成了。&lt;code&gt;lab4&lt;/code&gt;是到目前为止，比较复杂而且代码最多的&lt;code&gt;lab&lt;/code&gt;。总共需要完成三个部分。&lt;code&gt;part A&lt;/code&gt;添加多核支持，实现&lt;code&gt;RR&lt;/code&gt;调度。&lt;code&gt;part B&lt;/code&gt;实现&lt;code&gt;Copy-On-Write fork&lt;/code&gt;。&lt;code&gt;part C&lt;/code&gt; 实现时钟中断以及支持基本的&lt;code&gt;IPC&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;Part-A&quot;&gt;&lt;a href=&quot;#Part-A&quot; class=&quot;headerlink&quot; title=&quot;Part A&quot;&gt;&lt;/a&gt;Part A&lt;/h2&gt;&lt;h4 id=&quot;Exercise-1&quot;&gt;&lt;a href=&quot;#Exercise-1&quot; class=&quot;headerlink&quot; title=&quot;Exercise 1&quot;&gt;&lt;/a&gt;Exercise 1&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;Implement &lt;code&gt;mmio_map_region&lt;/code&gt; in kern/pmap.c. To see how this is used, look at the beginning of &lt;code&gt;lapic_init&lt;/code&gt; in kern/lapic.c. You’ll have to do the next exercise, too, before the tests for &lt;code&gt;mmio_map_region&lt;/code&gt; will run.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;实现需要让&lt;code&gt;Jos&lt;/code&gt;支持&lt;code&gt;symmetric multiprocessing&lt;/code&gt;，也就是所有的&lt;code&gt;cpu&lt;/code&gt;都拥有相同的权限去访问资源。&lt;code&gt;Jos&lt;/code&gt;使用&lt;code&gt;LAPIC&lt;/code&gt;来分发中断，以及通过它来知道当前使用的&lt;code&gt;cpu&lt;/code&gt;。而处理器访问&lt;code&gt;LAPIC&lt;/code&gt;，需要使用&lt;code&gt;MMIO&lt;/code&gt;。所以我们需要对&lt;code&gt;MMIO&lt;/code&gt;进行内存映射，这个函数比较简单。&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mmio_map_region(&lt;span class=&quot;keyword&quot;&gt;physaddr_t&lt;/span&gt; pa, &lt;span class=&quot;keyword&quot;&gt;size_t&lt;/span&gt; size) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;uintptr_t&lt;/span&gt; base = MMIOBASE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    size = ROUNDUP(size, PGSIZE);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(base + size &amp;gt; MMIOLIM)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        panic(&lt;span class=&quot;string&quot;&gt;&quot;mmio_map_region: reservation mem overflow&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    boot_map_region(kern_pgdir, base, size, pa, PTE_W | PTE_PCD | PTE_P);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;uintptr_t&lt;/span&gt; b = base;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    base += size;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *) b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Operating system" scheme="http://threezj.com/tags/Operating-system/"/>
    
      <category term="MIT 6.828" scheme="http://threezj.com/tags/MIT-6-828/"/>
    
  </entry>
  
  <entry>
    <title>MIT 6.828 lab3</title>
    <link href="http://threezj.com/2016/11/22/MIT%206.828%20lab3/"/>
    <id>http://threezj.com/2016/11/22/MIT 6.828 lab3/</id>
    <published>2016-11-22T15:03:06.000Z</published>
    <updated>2018-04-17T15:42:23.133Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这次<code>lab</code>的<code>Part A</code>让操作系统支持进程(单进程)，<code>Part B</code>处理了异常中断，使其能在<code>kernel态</code>和<code>用户态</code>进行切换。我觉得这次lab不算很难，可能是因为经过了前面两个lab洗礼的缘故。但还是在中断跳转那里卡了好一会，不会写汇编啊。</p><h2 id="Part-A"><a href="#Part-A" class="headerlink" title="Part A"></a>Part A</h2><p>在<code>Jos</code>中 我们用<code>Env</code>结构体来描述进程，关于Env，讲义中已经很清楚了，这里不赘述。关键点是通过<code>envs</code>数组和<code>env_free_list</code>来维护数组，这里需要注意的是<code>env_free_list</code>，不是像之前<code>free_page_list</code>那样是反向。这里需要和<code>envs</code>的顺序相同。</p><h4 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise 1"></a>Exercise 1</h4><blockquote><p>Modify <code>mem_init()</code> in kern/pmap.c to allocate and map the <code>envs</code> array. This array consists of exactly <code>NENV</code> instances of the <code>Env</code> structure allocated much like how you allocated the <code>pages</code> array. Also like the <code>pages</code> array, the memory backing <code>envs</code> should also be mapped user read-only at <code>UENVS</code> (defined in inc/memlayout.h) so user processes can read from this array.</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">envs = (struct Env *) boot_alloc(NENV * <span class="keyword">sizeof</span>(struct Env));</span><br><span class="line">boot_map_region(kern_pgdir, UENVS, PTSIZE, PADDR(envs), PTE_U);</span><br></pre></td></tr></table></figure><p>这个应该轻车熟路了，就是为<code>envs</code>分配内存，并开启虚拟映射。<br><a id="more"></a></p><h4 id="Exercise-2"><a href="#Exercise-2" class="headerlink" title="Exercise 2"></a>Exercise 2</h4><blockquote><p> In the file env.c, finish coding the following functions:</p><ul><li><code>env_init()</code><br>Initialize all of the <code>Env</code> structures in the <code>envs</code> array and add them to the <code>env_free_list</code>. Also calls <code>env_init_percpu</code>, which configures the segmentation hardware with separate segments for privilege level 0 (kernel) and privilege level 3 (user).</li><li><code>env_setup_vm()</code><br>Allocate a page directory for a new environment and initialize the kernel portion of the new environment’s address space.</li><li><code>region_alloc()</code><br>Allocates and maps physical memory for an environment</li><li><code>load_icode()</code><br>You will need to parse an ELF binary image, much like the boot loader already does, and load its contents into the user address space of a new environment.</li><li><code>env_create()</code><br>Allocate an environment with <code>env_alloc</code> and call <code>load_icode</code> to load an ELF binary into it.</li><li><code>env_run()</code><br>Start a given environment running in user mode.</li></ul></blockquote><p><code>env_init()</code> 初始化<code>envs</code>，并且连接<code>env_free_list</code>。和之前的<code>page_init</code>做法基本一样，除了顺序相反。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">env_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Set up envs array</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = NENV - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        envs[i].env_id = <span class="number">0</span>;</span><br><span class="line">        envs[i].env_status = ENV_FREE;</span><br><span class="line">        envs[i].env_link = env_free_list;</span><br><span class="line">        env_free_list = &amp;envs[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Per-CPU part of the initialization</span></span><br><span class="line">    env_init_percpu();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>env_setup_vm</code>为进程分配页目录，这里做法是<code>copy</code>了<code>kernel</code>的页目录。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">env_setup_vm</span><span class="params">(struct Env *e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">p</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate a page for the page directory</span></span><br><span class="line">    <span class="keyword">if</span> (!(p = page_alloc(ALLOC_ZERO)))</span><br><span class="line">        <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    e-&gt;env_pgdir = page2kva(p);</span><br><span class="line">    p-&gt;pp_ref++;</span><br><span class="line">    <span class="built_in">memcpy</span>(e-&gt;env_pgdir, kern_pgdir, PGSIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// UVPT maps the env's own page table read-only.</span></span><br><span class="line">    <span class="comment">// Permissions: kernel R, user R</span></span><br><span class="line">    e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) | PTE_P | PTE_U;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>region_alloc()</code>为用户空间分配页。类似于<code>lab2</code> 中的<code>boot_map_region</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">region_alloc(struct Env *e, <span class="keyword">void</span> *va, <span class="keyword">size_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> *<span class="keyword">va_t</span> = ROUNDDOWN(va, PGSIZE);</span><br><span class="line">    <span class="keyword">void</span> *end = ROUNDUP(va + len, PGSIZE);</span><br><span class="line">    <span class="keyword">for</span>(; <span class="keyword">va_t</span> &lt; end;<span class="keyword">va_t</span> += PGSIZE)&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp</span> = <span class="title">page_alloc</span>(1);</span></span><br><span class="line">        <span class="keyword">if</span>(pp == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            panic(<span class="string">"region_alloc:page alloc failed!\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        page_insert(e-&gt;env_pgdir, pp, <span class="keyword">va_t</span>, PTE_U | PTE_W);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>load_icode()</code>这个函数注释好多，一开始看了半天。其实说白了就是把<code>elf</code>程序加载到用户内存空间。正常来讲用户程序应该从磁盘上读取，但是目前<code>jos</code>还没有文件系统。<code>mit</code>直接链接了一些用户程序到kernel中。所以这里不需要读取，更加方便一点。具体我们可以参考<code>bootloader</code>的做法。因为需要对用户空间进行内存操作，这里需要用<code>lcr3()</code>切换页目录。最后需要注意的是设置进程的入口点为这个程序的入口点。最后的最后是为用户程序栈初始化分配一页。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">load_icode</span><span class="params">(struct Env *e, <span class="keyword">uint8_t</span> *binary)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Elf</span> *<span class="title">elf</span> = (<span class="title">struct</span> <span class="title">Elf</span> *) <span class="title">binary</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (elf-&gt;e_magic != ELF_MAGIC)</span><br><span class="line">        panic(<span class="string">"load_icode: not ELF executable."</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Proghdr</span> *<span class="title">ph</span> = (<span class="title">struct</span> <span class="title">Proghdr</span> *) (<span class="title">elf</span>-&gt;<span class="title">e_phoff</span> + <span class="title">binary</span>);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Proghdr</span> *<span class="title">eph</span> = <span class="title">ph</span> + <span class="title">elf</span>-&gt;<span class="title">e_phnum</span>;</span></span><br><span class="line">    lcr3(PADDR(e-&gt;env_pgdir));</span><br><span class="line">    <span class="keyword">for</span>(; ph &lt; eph; ph++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ph-&gt;p_type == ELF_PROG_LOAD)&#123;</span><br><span class="line">            region_alloc(e, (<span class="keyword">void</span> *) ph-&gt;p_va, ph-&gt;p_memsz);</span><br><span class="line">            <span class="built_in">memset</span>((<span class="keyword">void</span> *) ph-&gt;p_va, <span class="number">0</span>, ph-&gt;p_memsz);</span><br><span class="line">            <span class="built_in">memcpy</span>((<span class="keyword">void</span> *) ph-&gt;p_va, binary + ph-&gt;p_offset, ph-&gt;p_filesz);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    lcr3(PADDR(kern_pgdir));</span><br><span class="line">    e-&gt;env_tf.tf_eip = elf-&gt;e_entry;</span><br><span class="line">    region_alloc(e, (<span class="keyword">void</span> *) (USTACKTOP - PGSIZE), PGSIZE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>env_create</code>这个简单，综合前面的函数，先创建进程，然后加载用户程序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">env_create</span><span class="params">(<span class="keyword">uint8_t</span> *binary, <span class="keyword">enum</span> EnvType type)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">    env_alloc(&amp;e, <span class="number">0</span>);</span><br><span class="line">    load_icode(e, binary);</span><br><span class="line">    e-&gt;env_type = type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>env_run</code>运行进程。这个也比较简单，照着注释来就行。切换当前进程为新的进程。切换地址空间。最后调用<code>env_pop_tf</code>来保存现场，并且跳转到用户程序的入口点，不返回。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">env_run</span><span class="params">(struct Env *e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(curenv != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(curenv-&gt;env_status == ENV_RUNNING)</span><br><span class="line">            curenv-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line">    &#125;</span><br><span class="line">    curenv = e;</span><br><span class="line">    curenv-&gt;env_status = ENV_RUNNING;</span><br><span class="line">    curenv-&gt;env_runs ++;</span><br><span class="line">    lcr3(PADDR(e-&gt;env_pgdir));</span><br><span class="line">    env_pop_tf(&amp;e-&gt;env_tf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里进程建立完成，操作系统完成了从<code>kernel</code>切换到<code>用户态</code>，但是<code>hello world</code>，依旧运行不起来，因为目前操作系统无法处理中断。也就是说无法从<code>用户态</code>切换回<code>kernel</code>，当调用<code>printf</code>，会引起系统调用中断。</p><h4 id="中断、异常和系统调用"><a href="#中断、异常和系统调用" class="headerlink" title="中断、异常和系统调用"></a>中断、异常和系统调用</h4><p><code>中断、异常和系统调用</code>是用户程序或者外部设备和<code>kernel</code>进行交互的方式。比如说当敲击键盘时会产生中断，让操作系统知道这时候有字符可读。在比如用户程序运行时，发生错误，比如除0，无法运行下去，这会产生异常，让kernel来处理，系统调用就更不用说了，每时每刻都在发生，比如<code>printf</code>就是一个系统调用。这里说的<code>中断、异常和系统调用</code>，每一种都有些细微的不同，其实根据上述的例子就能看出来，中断是异步的，异常是同步的，系统调用同步异步都有可能。之后文章中说的中断，是广义上的中断，也就是一个统称，不细分为<code>中断、异常和系统调用</code>。操作系统用<code>int n</code>指令来说明中断产生，当中断产生时，操作系统会根据<code>中断向量表</code>，来索引<code>n</code>，然后跳到相应的处理函数。</p><p>此外这里还有一个叫做<code>TSS</code>的东西需要注意。就是用来保护现场的，从用户态切换到<code>kernel</code>的时候。</p><h4 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise 4"></a>Exercise 4</h4><p>这个<code>exercise</code>主要工作是建立<code>idt表</code>，以及注册相应的映射。在做这个之前，一定要仔细阅读 <code>Exercise 3</code>提的手册，务必弄清楚详细的中断机制。其实我觉得这里太偏硬件了，我更推荐看<code>CSAPP</code>关于异常那一章。</p><blockquote><p>Edit trapentry.S and trap.c and implement the features described above. The macros <code>TRAPHANDLER</code> and <code>TRAPHANDLER_NOEC</code> in trapentry.S should help you, as well as the T_* defines in inc/trap.h. You will need to add an entry point in trapentry.S (using those macros) for each trap defined in inc/trap.h, and you’ll have to provide<code>_alltraps</code> which the <code>TRAPHANDLER</code> macros refer to. You will also need to modify <code>trap_init()</code> to initialize the <code>idt</code> to point to each of these entry points defined in trapentry.S; the <code>SETGATE</code> macro will be helpful here.</p><p>Your <code>_alltraps</code> should:</p><ol><li>push values to make the stack look like a struct Trapframe</li><li>load <code>GD_KD</code> into %ds and %es</li><li><code>pushl %esp</code> to pass a pointer to the Trapframe as an argument to trap()</li><li><code>call trap</code> (can <code>trap</code> ever return?)</li></ol><p>Consider using the <code>pushal</code> instruction; it fits nicely with the layout of the <code>struct Trapframe</code>.</p></blockquote><p>首先在<code>trapentry.S</code>用预先定义的两个宏来定义中断。这个需要查看intel手册，因为有些中断需要压入错误码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">TRAPHANDLER_NOEC(t_divide, T_DIVIDE)</span><br><span class="line">TRAPHANDLER_NOEC(t_debug, T_DEBUG)</span><br><span class="line">TRAPHANDLER_NOEC(t_nmi, T_NMI)</span><br><span class="line">TRAPHANDLER_NOEC(t_brkpt, T_BRKPT)</span><br><span class="line">TRAPHANDLER_NOEC(t_oflow, T_OFLOW)</span><br><span class="line">TRAPHANDLER_NOEC(t_bound, T_BOUND)</span><br><span class="line">TRAPHANDLER_NOEC(t_illop, T_ILLOP)</span><br><span class="line">TRAPHANDLER_NOEC(t_device, T_DEVICE)</span><br><span class="line">TRAPHANDLER(t_dblflt, T_DBLFLT)</span><br><span class="line">TRAPHANDLER(t_tss, T_TSS)</span><br><span class="line">TRAPHANDLER(t_segnp, T_SEGNP)</span><br><span class="line">TRAPHANDLER(t_stack, T_STACK)</span><br><span class="line">TRAPHANDLER(t_gpflt, T_GPFLT)</span><br><span class="line">TRAPHANDLER(t_pgflt, T_PGFLT)</span><br><span class="line">TRAPHANDLER_NOEC(t_fperr, T_FPERR)</span><br><span class="line">TRAPHANDLER(t_align, T_ALIGN)</span><br><span class="line">TRAPHANDLER_NOEC(t_mchk, T_MCHK)</span><br><span class="line">TRAPHANDLER_NOEC(t_simderr, T_SIMDERR)</span><br><span class="line">TRAPHANDLER_NOEC(t_syscall, T_SYSCALL)</span><br><span class="line">TRAPHANDLER_NOEC(irq_timer, IRQ_OFFSET + IRQ_TIMER)</span><br><span class="line">TRAPHANDLER_NOEC(irq_kbd, IRQ_OFFSET + IRQ_KBD)</span><br><span class="line">TRAPHANDLER_NOEC(irq_serial, IRQ_OFFSET + IRQ_SERIAL)</span><br><span class="line">TRAPHANDLER_NOEC(irq_spurious, IRQ_OFFSET + IRQ_SPURIOUS)</span><br><span class="line">TRAPHANDLER_NOEC(irq_ide, IRQ_OFFSET + IRQ_IDE)</span><br><span class="line">TRAPHANDLER_NOEC(irq_error, IRQ_OFFSET + IRQ_ERROR)</span><br></pre></td></tr></table></figure><p>然后需要在<code>_alltraps</code> 设置好<code>trapframe</code>，最后调用<code>trap</code>来分发中断。这个按照注释和说明来做即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">_alltraps:</span><br><span class="line">    # Build trap frame.</span><br><span class="line">    pushl %ds</span><br><span class="line">    pushl %es</span><br><span class="line">    pushal</span><br><span class="line"></span><br><span class="line">    movw $(GD_KD), %ax</span><br><span class="line">    movw %ax, %ds</span><br><span class="line">    movw %ax, %es</span><br><span class="line"></span><br><span class="line">    pushl %esp</span><br><span class="line">    call trap</span><br></pre></td></tr></table></figure><p>最后在<code>idt_init()</code>设立<code>IDT表</code>，并设立相应的权限。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trap_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">Segdesc</span> <span class="title">gdt</span>[];</span></span><br><span class="line">    SETGATE(idt[T_DIVIDE], <span class="number">0</span>, GD_KT, t_divide, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_DEBUG], <span class="number">0</span>, GD_KT, t_debug, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_NMI], <span class="number">0</span>, GD_KT, t_nmi, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_BRKPT], <span class="number">0</span>, GD_KT, t_brkpt, <span class="number">3</span>);</span><br><span class="line">    SETGATE(idt[T_OFLOW], <span class="number">0</span>, GD_KT, t_oflow, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_BOUND], <span class="number">0</span>, GD_KT, t_bound, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_ILLOP], <span class="number">0</span>, GD_KT, t_illop, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_DEVICE], <span class="number">0</span>, GD_KT, t_device, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_DBLFLT], <span class="number">0</span>, GD_KT, t_dblflt, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_TSS], <span class="number">0</span>, GD_KT, t_tss, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_SEGNP], <span class="number">0</span>, GD_KT, t_segnp, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_STACK], <span class="number">0</span>, GD_KT, t_stack, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_GPFLT], <span class="number">0</span>, GD_KT, t_gpflt, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_PGFLT], <span class="number">0</span>, GD_KT, t_pgflt, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_FPERR], <span class="number">0</span>, GD_KT, t_fperr, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_ALIGN], <span class="number">0</span>, GD_KT, t_align, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_MCHK], <span class="number">0</span>, GD_KT, t_mchk, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_SIMDERR], <span class="number">0</span>, GD_KT, t_simderr, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_SYSCALL], <span class="number">0</span>, GD_KT, t_syscall, <span class="number">3</span>);</span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_TIMER], <span class="number">0</span>, GD_KT, irq_timer, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_KBD], <span class="number">0</span>, GD_KT, irq_kbd, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_SERIAL], <span class="number">0</span>, GD_KT, irq_serial, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_SPURIOUS], <span class="number">0</span>, GD_KT, irq_spurious, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_IDE], <span class="number">0</span>, GD_KT, irq_ide, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_ERROR], <span class="number">0</span>, GD_KT, irq_error, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// Per-CPU setup</span></span><br><span class="line">    trap_init_percpu();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Part-B"><a href="#Part-B" class="headerlink" title="Part B"></a>Part B</h2><h4 id="Exercise-5-amp-amp-Exercise-6"><a href="#Exercise-5-amp-amp-Exercise-6" class="headerlink" title="Exercise 5 &amp;&amp;  Exercise 6"></a>Exercise 5 &amp;&amp;  Exercise 6</h4><blockquote><p>Modify <code>trap_dispatch()</code> to dispatch page fault exceptions to <code>page_fault_handler()</code>. You should now be able to get make grade to succeed on the faultread,faultreadkernel, faultwrite, and faultwritekernel tests. If any of them don’t work, figure out why and fix them.</p></blockquote><blockquote><p> Modify <code>trap_dispatch()</code> to make breakpoint exceptions invoke the kernel monitor.</p></blockquote><p>这两个比较简单，我就放在一起了。就是单纯的分发中断处理。没什么好讲的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(tf-&gt;tf_trapno)&#123;</span><br><span class="line">       <span class="keyword">case</span> T_PGFLT:</span><br><span class="line">           page_fault_handler(tf);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       <span class="keyword">case</span> T_BRKPT:</span><br><span class="line">           monitor(tf);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="Exercise-7"><a href="#Exercise-7" class="headerlink" title="Exercise 7"></a>Exercise 7</h4><blockquote><p>Add a handler in the kernel for interrupt vector <code>T_SYSCALL</code>. You will have to edit kern/trapentry.S and kern/trap.c’s <code>trap_init()</code>. You also need to change<code>trap_dispatch()</code> to handle the system call interrupt by calling <code>syscall()</code> (defined in kern/syscall.c) with the appropriate arguments, and then arranging for the return value to be passed back to the user process in <code>%eax</code>. Finally, you need to implement <code>syscall()</code> in kern/syscall.c. Make sure <code>syscall()</code> returns <code>-E_INVAL</code> if the system call number is invalid. You should read and understand lib/syscall.c (especially the inline assembly routine) in order to confirm your understanding of the system call interface. Handle all the system calls listed in inc/syscall.h by invoking the corresponding kernel function for each call.</p></blockquote><p>添加系统调用处理。完成这个<code>exercise</code>。就能够完整的运行<code>hello world</code>了。之前建立<code>idt</code>表的时候，我已经设定好系统调用的映射了。所以这里直接处理<code>trap_dispatch()</code>就行。真正的<code>系统调用</code>触发在<code>/lib/syscall.c</code> 中，就是如下这条汇编语句</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">"int %1\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">             : <span class="string">"=a"</span> (ret)</span></span></span><br><span class="line">             : "i" (T_SYSCALL),</span><br><span class="line">               <span class="string">"a"</span> (num),</span><br><span class="line">               <span class="string">"d"</span> (a1),</span><br><span class="line">               <span class="string">"c"</span> (a2),</span><br><span class="line">               <span class="string">"b"</span> (a3),</span><br><span class="line">               <span class="string">"D"</span> (a4),</span><br><span class="line">               <span class="string">"S"</span> (a5)</span><br><span class="line">             : <span class="string">"cc"</span>, <span class="string">"memory"</span>);</span><br></pre></td></tr></table></figure><p><code>系统调用</code> 传入需要调用函数号，以及参数。所以当分发系统调用是，只要按照说明传入相应的参数，并且在<code>/kern/syscall.c</code>中按照函数号，分发下去即可。最后把返回值保存在<code>eax</code>中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> T_SYSCALL:</span><br><span class="line">           r = syscall(</span><br><span class="line">                   tf-&gt;tf_regs.reg_eax,</span><br><span class="line">                   tf-&gt;tf_regs.reg_edx,</span><br><span class="line">                   tf-&gt;tf_regs.reg_ecx,</span><br><span class="line">                   tf-&gt;tf_regs.reg_ebx,</span><br><span class="line">                   tf-&gt;tf_regs.reg_edi,</span><br><span class="line">                   tf-&gt;tf_regs.reg_esi);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123;</span><br><span class="line">               panic(<span class="string">"trap_dispatch: %e"</span>, r);</span><br><span class="line">           &#125;</span><br><span class="line">           tf-&gt;tf_regs.reg_eax = r;</span><br><span class="line">           <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><p><code>/kern/syscall.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int32_t</span></span><br><span class="line">syscall(<span class="keyword">uint32_t</span> syscallno, <span class="keyword">uint32_t</span> a1, <span class="keyword">uint32_t</span> a2, <span class="keyword">uint32_t</span> a3, <span class="keyword">uint32_t</span> a4, <span class="keyword">uint32_t</span> a5) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (syscallno) &#123;</span><br><span class="line">        <span class="keyword">case</span> SYS_cputs:</span><br><span class="line">            sys_cputs((<span class="keyword">const</span> <span class="keyword">char</span> *) a1,(<span class="keyword">size_t</span>) a2);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">case</span> SYS_cgetc:</span><br><span class="line">            <span class="keyword">return</span> sys_cgetc();</span><br><span class="line">        <span class="keyword">case</span> SYS_getenvid:</span><br><span class="line">            <span class="keyword">return</span> sys_getenvid();</span><br><span class="line">        <span class="keyword">case</span> SYS_env_destroy:</span><br><span class="line">            <span class="keyword">return</span> sys_env_destroy((<span class="keyword">envid_t</span>)a1);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Exercise-8"><a href="#Exercise-8" class="headerlink" title="Exercise 8"></a>Exercise 8</h4><blockquote><p>Add the required code to the user library, then boot your kernel. You should see user/hello print “hello, world” and then print “i am environment 00001000”.user/hello then attempts to “exit” by calling <code>sys_env_destroy()</code> (see lib/libmain.c and lib/exit.c). Since the kernel currently only supports one user environment, it should report that it has destroyed the only environment and then drop into the kernel monitor.</p></blockquote><p>这个也简单，即设置当前活动的进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thisenv = envs + ENVX(sys_getenvid ());</span><br></pre></td></tr></table></figure><h4 id="Exercise-9"><a href="#Exercise-9" class="headerlink" title="Exercise 9"></a>Exercise 9</h4><blockquote><p> Change <code>kern/trap.c</code> to panic if a page fault happens in kernel mode.</p><p>Hint: to determine whether a fault happened in user mode or in kernel mode, check the low bits of the <code>tf_cs</code>.</p><p>Read <code>user_mem_assert</code> in kern/pmap.c and implement <code>user_mem_check</code> in that same file.</p></blockquote><p>内存保护。这个也很清楚，照着说明来即可。主要就是检查标志位。用户程序不能访问<code>kernel</code>的内存。以及在kernel中<code>page fault</code>，需要特别报错。</p><p><code>/kern/trap.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//page_fault_handler</span></span><br><span class="line"><span class="keyword">if</span> (tf-&gt;tf_cs == GD_KT) &#123;</span><br><span class="line">       panic(<span class="string">"page_fault_handler: page fault in kernel mode"</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>‘/kern/pmap.c’  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">user_mem_check</span><span class="params">(struct Env *env, <span class="keyword">const</span> <span class="keyword">void</span> *va, <span class="keyword">size_t</span> len, <span class="keyword">int</span> perm)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *vat =(<span class="keyword">void</span> *) va;</span><br><span class="line">    <span class="keyword">void</span> *end =(<span class="keyword">void</span> *)va + len;</span><br><span class="line">    <span class="keyword">int</span> p = perm | PTE_P;</span><br><span class="line">    <span class="keyword">pte_t</span> *pte;</span><br><span class="line">    <span class="keyword">for</span> (; vat &lt; end; vat = ROUNDDOWN(vat+PGSIZE, PGSIZE)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">uint32_t</span>)vat &gt; ULIM) &#123;</span><br><span class="line">            user_mem_check_addr =(<span class="keyword">uintptr_t</span>) vat;</span><br><span class="line">            <span class="keyword">return</span> -E_FAULT;</span><br><span class="line">        &#125;</span><br><span class="line">        page_lookup(env-&gt;env_pgdir, vat, &amp;pte);</span><br><span class="line">        <span class="keyword">if</span> (!(pte &amp;&amp; ((*pte &amp; p) == p))) &#123;</span><br><span class="line">            user_mem_check_addr = (<span class="keyword">uintptr_t</span>) vat;</span><br><span class="line">            <span class="keyword">return</span> -E_FAULT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>/kern/syscall.c</code> 最后需要在<code>sys_cputs</code> 添加检查，因为只有这个调用访问到地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sys_cputs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Check that the user has permission to read memory [s, s+len).</span></span><br><span class="line">    <span class="comment">// Destroy the environment if not.</span></span><br><span class="line">    user_mem_assert(curenv, s, len, PTE_U | PTE_W);</span><br><span class="line">    <span class="comment">// Print the string supplied by the user.</span></span><br><span class="line">    cprintf(<span class="string">"%.*s"</span>, len, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此<code>lab3</code>结束</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这次&lt;code&gt;lab&lt;/code&gt;的&lt;code&gt;Part A&lt;/code&gt;让操作系统支持进程(单进程)，&lt;code&gt;Part B&lt;/code&gt;处理了异常中断，使其能在&lt;code&gt;kernel态&lt;/code&gt;和&lt;code&gt;用户态&lt;/code&gt;进行切换。我觉得这次lab不算很难，可能是因为经过了前面两个lab洗礼的缘故。但还是在中断跳转那里卡了好一会，不会写汇编啊。&lt;/p&gt;
&lt;h2 id=&quot;Part-A&quot;&gt;&lt;a href=&quot;#Part-A&quot; class=&quot;headerlink&quot; title=&quot;Part A&quot;&gt;&lt;/a&gt;Part A&lt;/h2&gt;&lt;p&gt;在&lt;code&gt;Jos&lt;/code&gt;中 我们用&lt;code&gt;Env&lt;/code&gt;结构体来描述进程，关于Env，讲义中已经很清楚了，这里不赘述。关键点是通过&lt;code&gt;envs&lt;/code&gt;数组和&lt;code&gt;env_free_list&lt;/code&gt;来维护数组，这里需要注意的是&lt;code&gt;env_free_list&lt;/code&gt;，不是像之前&lt;code&gt;free_page_list&lt;/code&gt;那样是反向。这里需要和&lt;code&gt;envs&lt;/code&gt;的顺序相同。&lt;/p&gt;
&lt;h4 id=&quot;Exercise-1&quot;&gt;&lt;a href=&quot;#Exercise-1&quot; class=&quot;headerlink&quot; title=&quot;Exercise 1&quot;&gt;&lt;/a&gt;Exercise 1&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;Modify &lt;code&gt;mem_init()&lt;/code&gt; in kern/pmap.c to allocate and map the &lt;code&gt;envs&lt;/code&gt; array. This array consists of exactly &lt;code&gt;NENV&lt;/code&gt; instances of the &lt;code&gt;Env&lt;/code&gt; structure allocated much like how you allocated the &lt;code&gt;pages&lt;/code&gt; array. Also like the &lt;code&gt;pages&lt;/code&gt; array, the memory backing &lt;code&gt;envs&lt;/code&gt; should also be mapped user read-only at &lt;code&gt;UENVS&lt;/code&gt; (defined in inc/memlayout.h) so user processes can read from this array.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;envs = (struct Env *) boot_alloc(NENV * &lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(struct Env));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;boot_map_region(kern_pgdir, UENVS, PTSIZE, PADDR(envs), PTE_U);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个应该轻车熟路了，就是为&lt;code&gt;envs&lt;/code&gt;分配内存，并开启虚拟映射。&lt;br&gt;
    
    </summary>
    
    
      <category term="Operating system" scheme="http://threezj.com/tags/Operating-system/"/>
    
      <category term="MIT 6.828" scheme="http://threezj.com/tags/MIT-6-828/"/>
    
  </entry>
  
  <entry>
    <title>MIT 6.828 lab2</title>
    <link href="http://threezj.com/2016/11/14/MIT%206.828%20lab2/"/>
    <id>http://threezj.com/2016/11/14/MIT 6.828 lab2/</id>
    <published>2016-11-14T15:55:06.000Z</published>
    <updated>2018-04-17T15:43:07.335Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这个<code>lab</code>主要是写内存管理相关的代码。实现操作系统必须满足三个要求<code>multiplexing, isolation, and interaction</code> 。翻译成中文就是<code>复用，隔离和相互作用</code>。这三个条件其实主要靠抽象完成。<code>复用</code> 比如<code>IO</code>读写，都对文件描述符进行处理，而不管底下是网络读写还是磁盘读写等。<code>隔离</code>抽象地址空间，每个进程拥有一个自己的地址空间，相互并不影响。<code>相互作用</code>也需要抽象的控制，防止一些恶意的软件。</p><p><code>lab2</code>关注点在于如何实现地址空间。<code>jos</code>通过实现分页管理来实现。操作系统中所有程序接触的地址都是虚拟地址，然后硬件上真正需要的则是物理地址，所以中间则是使用<code>MMU(memory management unit)</code>来把虚拟地址翻译为物理地址。</p><h2 id="连续的内存分配"><a href="#连续的内存分配" class="headerlink" title="连续的内存分配"></a>连续的内存分配</h2><p>早期操作系统都是直接操作物理地址，很明显，这样做有着致命的缺点。比如用户程序可以直接访问<code>kernel</code>地址，导致系统崩溃，多个用户程序程序直接相互影响。即使设立了保护机制，也就是通过一些<code>flag</code>来辨别是否可以访问，但还是会有问题。就是当两个进程同时载入内存时，会进行地址偏移，跳转到指令并不会是程序中原先的指令，此时需要进行<code>重定位</code>，就是扫描一遍程序，给程序中涉及到的地址加上偏移量。但是这种方法效率是很低的。需要为每个需要执行的程序进行扫描判定计算。</p><h4 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h4><p>所以这里我们提出了<code>地址空间</code>的概念。重点还是抽象。我门让每个进程处于独立的进程空间中。比如虽然两个进程都指向同一个虚拟地址，但是实际所指的物理地址是不同的。</p><h4 id="基地寄存器和界限寄存器"><a href="#基地寄存器和界限寄存器" class="headerlink" title="基地寄存器和界限寄存器"></a>基地寄存器和界限寄存器</h4><p>其实就是动态重定位。把重定位的时间推迟了，之前的重定位一般发生在加载时，而现在推迟到访问内存时，并且减少了扫描查找的时间。通过两个寄存器来保存进程的起始地址和进程使用空间的长度。当程序访问内存时，自动加上偏移量，如果超出界限，则产生错误。但这种方法还是不够快，需要进行计算，比较可以进行的很快，但计算不行。进行动态重定位之后地址称为<code>线性地址</code><br><a id="more"></a></p><h2 id="非连续的内存分配"><a href="#非连续的内存分配" class="headerlink" title="非连续的内存分配"></a>非连续的内存分配</h2><p>之前的内存分配，都是连续的，但是其实这种分法的内存利用效率很低。会产生很多的<code>内碎片</code>，<code>外碎片</code>，当你找不到足够大内存块时，还需要对内存进行整理。然后就有人提出了不连续的内存分配。把内存切开，分块保存。那么这时候，切多大的块又是一个问题。进而产生了两种方法<code>分段</code>和<code>分页</code>。</p><h4 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h4><p>分段的概念就是说，我们把进程的地址空间分成堆、栈、符号表、代码段等等。分成几个比较大的块，这几个块在物理内存中是可以不连续的。每个进程都有<code>段表</code>，<code>段表是</code>由操作系统建立的。虚拟地址分成两块，<code>段号</code>和<code>偏移量</code>，通过<code>段号</code>索引<code>段表</code>得到<code>基址</code>再加上<code>偏移量</code>，则为物理地址。段是可以动态生长的。</p><h4 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h4><p>虽然上述的<code>基地寄存器</code>和<code>界限寄存器</code>可以建立独立地址空间的抽象。但是依然有问题。现在软件越做越大，早就无法装下所有的进程了。当整个进程无法全部装入进程的时候，提出了一种更加灵活的方式，<code>虚拟内存</code>。主要思想是把进程的地址空间切成块，这些块无需全部都装到内存里，而是把一部分必要的装到内存中，而另外一些不是那么重要的装到硬盘中，直到进程需要的时候才调出来使用，大大节省内存空间。其实也是一种抽象，把磁盘的容量抽象成内存。我们用分页来实现<code>虚拟内存</code>。</p><h4 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h4><p><code>分页</code>意味当把进程切块的时候切的比<code>分段</code>要小，每一块则称为<code>页</code>。好现在我们有两个空间。<code>虚拟地址空间</code>以及<code>物理地址空间</code>。我们需要在这中间搭建一个桥梁，把虚拟地址翻译成物理地址，即<code>MMU</code>。<code>MMU</code>则是通过页表来索引得到地址的。</p><p>虚拟地址空间会比物理地址大的多，因为很多页并未分配到物理内存中，而是存在磁盘中，当需要那一页时才会调出来，替换最近使用次数最少的那一页。就好像<code>Cache</code>一样。可以把内存抽象成磁盘的一层<code>Cache</code>，以为读内存的速度比读硬盘的速度快的多。</p><p><img src="http://7xrsib.com1.z0.glb.clouddn.com/virtual-memory%5B1%5D.png" alt=""></p><h4 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h4><p>那么具体是如何翻译的？用<code>页表(page table)</code>的方式来索引。有点像<code>Hash table</code>。可以把<code>页表</code>看成一个大的数组。每个进程都有一个<code>页表</code>。<code>页表</code>的每一项叫做<code>页表项( page table entries)</code> 。<code>页表项</code>包含20位<code>physical page number (PPN)</code> 和剩下<code>12个标志位</code>来用作权限控制。下面是具体翻译的过程</p><ol><li>得到虚拟地址</li><li>截取虚拟地址的前<code>20位</code>作为索引</li><li>通过索引从页表中获取<code>页表项</code></li><li>把<code>页表项的前20位(PPN)</code>加上<code>虚拟地址的后12位(offset)</code>，则得到完整的物理地址。</li></ol><p>实际情况中，我们不可能只用一个表来存储所有的地址。因为页表中的大部分页表项都用不到，因为还未分配。所以采用多级页表的方式来存储。具体看下图，主要方式和上面相同，只不过多加了一层罢了。这样的话，如果<code>页目录</code>中某一项未分配的话，则不需要后面的<code>页表</code>了，大大节省空间。</p><p><img src="http://7xrsib.com1.z0.glb.clouddn.com/2016-11-14%2016-58-22%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p><p>以上就是分页实现方式。分页十分简洁明了的实现了操作系统的需求。比如说两个虚拟地址可以指向同一个物理地址，这就是<code>复用和交互</code>。还可以通过标志位来阻止进程访问别的进程，这就是<code>隔离</code>。</p><h2 id="lab2"><a href="#lab2" class="headerlink" title="lab2"></a>lab2</h2><p>前面是<code>lab2</code>所需的所有知识，当然我梳理的不是很细。非常具体的东西，大家还是看书为好。</p><h4 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise 1"></a>Exercise 1</h4><blockquote><p>In the file kern/pmap.c, you must implement code for the following functions (probably in the order given).</p><p><code>boot_alloc()</code><br><code>mem_init()</code> (only up to the call to <code>check_page_free_list(1)</code>)<br><code>page_init()</code><br><code>page_alloc()</code><br><code>page_free()</code></p></blockquote><p><code>boot_alloc()</code>在物理内存上为页目录以及页表的数据结构分配数据，只在<code>mem_init()</code>调用。真正的页面分配是用<code>page_alloc()</code>的。<code>boot_alloc()</code>是从<code>kernel</code>装载的结束位置开始分配的。代码如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">result = nextfree;</span><br><span class="line"><span class="keyword">if</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (PADDR(nextfree) + n &gt; (npages + <span class="number">1</span>) * PGSIZE) &#123;</span><br><span class="line">        panic(<span class="string">"out of memory\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    nextfree = ROUNDUP((<span class="keyword">char</span> *)nextfree + n, PGSIZE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure><p>写这个<code>lab</code>这个之前一定要弄清楚原理，不要什么都不懂就开始写了，这样只会无从下手。其实要写的代码都不难。</p><p><code>mem_init()</code> 望名知意，初始化内存。第一部分主要是分配<code>页目录</code>，以及追踪<code>页表</code>的数据结构。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pages = (struct PageInfo *) boot_alloc(npages * <span class="keyword">sizeof</span>(struct PageInfo));</span><br><span class="line"><span class="built_in">memset</span>(pages, <span class="number">0</span>, npages * <span class="keyword">sizeof</span>(struct PageInfo));</span><br></pre></td></tr></table></figure><p><code>page_init()</code> 按照注释的要求初始化<code>pages</code> 和<code>page_free_list</code>，这里比较要注意的是，这个链表是反向的。<code>pp_link</code>指向的是前一个<code>page</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">page_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> i, io_page_i, ext_page_i, free_top;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; npages; i++) &#123;</span><br><span class="line">        pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">        pages[i].pp_link = page_free_list;</span><br><span class="line">        page_free_list = &amp;pages[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pages[<span class="number">0</span>].pp_link = <span class="literal">NULL</span>;</span><br><span class="line">    pages[<span class="number">1</span>].pp_link = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    io_page_i = PGNUM(IOPHYSMEM);</span><br><span class="line">    ext_page_i = PGNUM(EXTPHYSMEM);</span><br><span class="line">    free_top = PGNUM(PADDR(boot_alloc(<span class="number">0</span>)));</span><br><span class="line"></span><br><span class="line">    pages[ext_page_i].pp_link = pages[io_page_i].pp_link;</span><br><span class="line">    <span class="keyword">for</span>(i = io_page_i;i &lt; ext_page_i;i++)</span><br><span class="line">        pages[i].pp_link = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    pages[free_top].pp_link = pages[ext_page_i].pp_link;</span><br><span class="line">    <span class="keyword">for</span> (i = ext_page_i; i &lt; free_top; i++)</span><br><span class="line">        pages[i].pp_link = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>page_alloc()</code> 分配页，这个也很简单。都是链表的基础操作。照着注释做就行了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct PageInfo * <span class="title">page_alloc</span><span class="params">(<span class="keyword">int</span> alloc_flags)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">p</span> = <span class="title">page_free_list</span>;</span></span><br><span class="line">    <span class="keyword">if</span>(p)&#123;</span><br><span class="line">        page_free_list = p-&gt;pp_link;</span><br><span class="line">        p-&gt;pp_link = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(alloc_flags &amp; ALLOC_ZERO)&#123;</span><br><span class="line">            <span class="built_in">memset</span>(page2kva(p), <span class="number">0</span>, PGSIZE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>page_free()</code> 释放页，把它添加回<code>free_list</code>中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">page_free</span><span class="params">(struct PageInfo *pp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pp-&gt;pp_ref != <span class="number">0</span> || pp-&gt;pp_link!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        panic(<span class="string">"pp-&gt;pp_ref is nonzero or pp-&gt;pp_link is not NULL\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pp-&gt;pp_link = page_free_list;</span><br><span class="line">    page_free_list = pp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise 4"></a>Exercise 4</h4><blockquote><p>Exercise 4. In the file kern/pmap.c, you must implement code for the following functions.</p><p><code>pgdir_walk()</code><br><code>boot_map_region()</code><br><code>page_lookup()</code><br><code>page_remove()</code><br><code>page_insert()</code></p></blockquote><p><code>pgdir_walk</code> 是个关键函数。这里需要你实现虚拟地址翻译到物理地址的过程，先从<code>页目录</code>中拿到<code>页表</code>的地址，然后再根据<code>页表</code>的索引获得<code>页表项</code>。这里是返回指向<code>页表项</code>的地址。注意这里返回的要是虚拟地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pte_t</span> * pgdir_walk(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">const</span> <span class="keyword">void</span> *va, <span class="keyword">int</span> create) &#123;</span><br><span class="line">    <span class="keyword">int</span> pdr_i = PDX(va);</span><br><span class="line">    <span class="keyword">pde_t</span> *pde = &amp;pgdir[pdr_i];</span><br><span class="line">    <span class="keyword">pte_t</span> *pgt;</span><br><span class="line">    <span class="keyword">if</span>(!(*pde &amp; PTE_P))&#123;</span><br><span class="line">        <span class="keyword">if</span>(!create)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">page</span> = <span class="title">page_alloc</span>(<span class="title">ALLOC_ZERO</span>);</span></span><br><span class="line">        <span class="keyword">if</span>(page == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        *pde = page2pa(page) | PTE_P | PTE_U | PTE_W;</span><br><span class="line">        page-&gt;pp_ref ++;</span><br><span class="line">    &#125;</span><br><span class="line">    pgt = KADDR(PTE_ADDR(*pde));</span><br><span class="line">    <span class="keyword">return</span> &amp;pgt[PTX(va)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>boot_map_region</code>这个函数无非就是映射的过程了，并设置权限。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">boot_map_region</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">uintptr_t</span> va, <span class="keyword">size_t</span> size, <span class="keyword">physaddr_t</span> pa, <span class="keyword">int</span> perm)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; (size / PGSIZE); i++, va += PGSIZE, pa+=PGSIZE)&#123;</span><br><span class="line">        <span class="keyword">pte_t</span>* pte = pgdir_walk(pgdir,(<span class="keyword">const</span> <span class="keyword">void</span> *) va, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(pte!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            *pte = pa|perm|PTE_P;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>page_lookup</code> 查找虚拟地址所对应的页</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct PageInfo * <span class="title">page_lookup</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">void</span> *va, <span class="keyword">pte_t</span> **pte_store)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pte_t</span> *pte = pgdir_walk(pgdir, va, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(pte == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pte_store!=<span class="literal">NULL</span>)  </span><br><span class="line">            *pte_store = pte;</span><br><span class="line">        <span class="keyword">return</span> pa2page(PTE_ADDR(*pte));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>page_remove</code> 删除对页的分配。<code>TLB</code>是<code>页表</code>之上又加了一层<code>cache</code>，所以这里也要删除记录</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">page_remove</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">void</span> *va)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pte_t</span> *pte;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp</span> = <span class="title">page_lookup</span>(<span class="title">pgdir</span>, <span class="title">va</span>, &amp;<span class="title">pte</span>);</span></span><br><span class="line">    <span class="keyword">if</span>(pp!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        page_decref(pp);</span><br><span class="line">        *pte = <span class="number">0</span>;</span><br><span class="line">        tlb_invalidate(pgdir, va);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>page_insert</code>分配页，若<code>页表</code>中已有数据，则需要删除。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">page_insert</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, struct PageInfo *pp, <span class="keyword">void</span> *va, <span class="keyword">int</span> perm)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pte_t</span> *pte = pgdir_walk(pgdir, va, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(pte)&#123;</span><br><span class="line">        pp-&gt;pp_ref ++;</span><br><span class="line">        <span class="keyword">if</span>(PTE_ADDR(*pte))</span><br><span class="line">            page_remove(pgdir, va);</span><br><span class="line">        *pte = page2pa(pp) | perm |PTE_P;</span><br><span class="line">        tlb_invalidate(pgdir, va);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Exercise-5"><a href="#Exercise-5" class="headerlink" title="Exercise 5"></a>Exercise 5</h4><p><strong>不保证答案的正确性，纯粹是自己的理解</strong></p><blockquote><p>Fill in the missing code in <code>mem_init()</code> after the call to <code>check_page()</code>.</p></blockquote><p>这个比较简单，按照注释说的来就行。用之前的<code>boot_map_region</code>来建立虚拟地址到物理地址的映射。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">boot_map_region(kern_pgdir, UPAGES, PTSIZE, PADDR(pages), PTE_U);</span><br><span class="line">boot_map_region(kern_pgdir, KSTACKTOP-KSTKSIZE, KSTKSIZE, PADDR(bootstack), PTE_W);</span><br><span class="line">boot_map_region(kern_pgdir, KERNBASE, <span class="number">0xffffffff</span> - KERNBASE, <span class="number">0</span>, PTE_W);</span><br></pre></td></tr></table></figure><blockquote><p>What entries (rows) in the page directory have been filled in at this point? What addresses do they map and where do they point? In other words, fill out this table as much as possible:</p></blockquote><table><thead><tr><th style="text-align:center">Entry</th><th style="text-align:center">Base Virtual Address</th><th style="text-align:left">Points to (logically):</th></tr></thead><tbody><tr><td style="text-align:center">1023</td><td style="text-align:center">0xFFC00000</td><td style="text-align:left">phys memory</td></tr><tr><td style="text-align:center">.</td><td style="text-align:center">?</td><td style="text-align:left">?</td></tr><tr><td style="text-align:center">960</td><td style="text-align:center">0xF0000000</td><td style="text-align:left">phys memory</td></tr><tr><td style="text-align:center">959</td><td style="text-align:center">0xEFC00000</td><td style="text-align:left">Kernel Stack</td></tr><tr><td style="text-align:center">958</td><td style="text-align:center">0xEF800000</td><td style="text-align:left">Memory-mapped I/O</td></tr><tr><td style="text-align:center">957</td><td style="text-align:center">0xEF400000</td><td style="text-align:left">page table</td></tr><tr><td style="text-align:center">956</td><td style="text-align:center">0xEF000000</td><td style="text-align:left">page structures</td></tr><tr><td style="text-align:center">.</td><td style="text-align:center">?</td><td style="text-align:left">?</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">0x00000000</td><td style="text-align:left">[see next question]</td></tr></tbody></table><blockquote><p>We have placed the kernel and user environment in the same address space. Why will user programs not be able to read or write the kernel’s memory? What specific mechanisms protect the kernel memory?</p></blockquote><p><code>页目录项</code>以及<code>页表项</code>，都有保留相应的<code>标志位</code>来确定此地址的权限。</p><blockquote><p>What is the maximum amount of physical memory that this operating system can support? Why?</p></blockquote><p>每个<code>PageInfo</code> 对应一个物理页也就是<code>2^12(4096)</code>字节。根据上面的映射，我们把所有<code>pages</code>放到到<code>UPAGES</code>之上，大小为<code>PTSIZE</code>。那么最大的可以支持的物理内存为<code>(PTSIZE/sizeof(PageInfo))*4096</code></p><blockquote><p>How much space overhead is there for managing memory, if we actually had the maximum amount of physical memory? How is this overhead broken down?</p></blockquote><p><code>页目录</code>4M，<code>页表</code>4M，<code>PageInfo</code> 4M ，总共12M。注意这里虽然<code>页目录</code>和<code>PageInfo</code>都不到4M，但操作系统还是预留了这么多。</p><blockquote><p>Revisit the page table setup in kern/entry.S and kern/entrypgdir.c. Immediately after we turn on paging, EIP is still a low number (a little over 1MB). At what point do we transition to running at an EIP above KERNBASE? What makes it possible for us to continue executing at a low EIP between when we enable paging and when we begin running at an EIP above KERNBASE? Why is this transition necessary?</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov $relocated, %eax</span><br><span class="line">jmp *%eax</span><br></pre></td></tr></table></figure><p>我汇编不熟。不太明白为什么要这么做。至于为什么能继续在低地址执行，是因为有映射到低地址。</p><p>为何是必须的？我也没弄清楚。照网上的答案是说，<code>kernel</code>需要获得更多的空间。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>《现代操作系统》<br>清华大学操作系统课</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这个&lt;code&gt;lab&lt;/code&gt;主要是写内存管理相关的代码。实现操作系统必须满足三个要求&lt;code&gt;multiplexing, isolation, and interaction&lt;/code&gt; 。翻译成中文就是&lt;code&gt;复用，隔离和相互作用&lt;/code&gt;。这三个条件其实主要靠抽象完成。&lt;code&gt;复用&lt;/code&gt; 比如&lt;code&gt;IO&lt;/code&gt;读写，都对文件描述符进行处理，而不管底下是网络读写还是磁盘读写等。&lt;code&gt;隔离&lt;/code&gt;抽象地址空间，每个进程拥有一个自己的地址空间，相互并不影响。&lt;code&gt;相互作用&lt;/code&gt;也需要抽象的控制，防止一些恶意的软件。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;lab2&lt;/code&gt;关注点在于如何实现地址空间。&lt;code&gt;jos&lt;/code&gt;通过实现分页管理来实现。操作系统中所有程序接触的地址都是虚拟地址，然后硬件上真正需要的则是物理地址，所以中间则是使用&lt;code&gt;MMU(memory management unit)&lt;/code&gt;来把虚拟地址翻译为物理地址。&lt;/p&gt;
&lt;h2 id=&quot;连续的内存分配&quot;&gt;&lt;a href=&quot;#连续的内存分配&quot; class=&quot;headerlink&quot; title=&quot;连续的内存分配&quot;&gt;&lt;/a&gt;连续的内存分配&lt;/h2&gt;&lt;p&gt;早期操作系统都是直接操作物理地址，很明显，这样做有着致命的缺点。比如用户程序可以直接访问&lt;code&gt;kernel&lt;/code&gt;地址，导致系统崩溃，多个用户程序程序直接相互影响。即使设立了保护机制，也就是通过一些&lt;code&gt;flag&lt;/code&gt;来辨别是否可以访问，但还是会有问题。就是当两个进程同时载入内存时，会进行地址偏移，跳转到指令并不会是程序中原先的指令，此时需要进行&lt;code&gt;重定位&lt;/code&gt;，就是扫描一遍程序，给程序中涉及到的地址加上偏移量。但是这种方法效率是很低的。需要为每个需要执行的程序进行扫描判定计算。&lt;/p&gt;
&lt;h4 id=&quot;地址空间&quot;&gt;&lt;a href=&quot;#地址空间&quot; class=&quot;headerlink&quot; title=&quot;地址空间&quot;&gt;&lt;/a&gt;地址空间&lt;/h4&gt;&lt;p&gt;所以这里我们提出了&lt;code&gt;地址空间&lt;/code&gt;的概念。重点还是抽象。我门让每个进程处于独立的进程空间中。比如虽然两个进程都指向同一个虚拟地址，但是实际所指的物理地址是不同的。&lt;/p&gt;
&lt;h4 id=&quot;基地寄存器和界限寄存器&quot;&gt;&lt;a href=&quot;#基地寄存器和界限寄存器&quot; class=&quot;headerlink&quot; title=&quot;基地寄存器和界限寄存器&quot;&gt;&lt;/a&gt;基地寄存器和界限寄存器&lt;/h4&gt;&lt;p&gt;其实就是动态重定位。把重定位的时间推迟了，之前的重定位一般发生在加载时，而现在推迟到访问内存时，并且减少了扫描查找的时间。通过两个寄存器来保存进程的起始地址和进程使用空间的长度。当程序访问内存时，自动加上偏移量，如果超出界限，则产生错误。但这种方法还是不够快，需要进行计算，比较可以进行的很快，但计算不行。进行动态重定位之后地址称为&lt;code&gt;线性地址&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Operating system" scheme="http://threezj.com/tags/Operating-system/"/>
    
      <category term="MIT 6.828" scheme="http://threezj.com/tags/MIT-6-828/"/>
    
  </entry>
  
  <entry>
    <title>MIT 6.828 lab1</title>
    <link href="http://threezj.com/2016/11/06/MIT%206.828%20lab1/"/>
    <id>http://threezj.com/2016/11/06/MIT 6.828 lab1/</id>
    <published>2016-11-06T07:50:06.000Z</published>
    <updated>2018-04-17T15:43:36.091Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>开启一场漫长且有趣的旅程，即日起开始学习<code>MIT 6.828</code>。总共有七个<code>lab</code>。<code>lab6</code>和<code>lab7</code>其中选一个做。</p><h2 id="PC启动流程简述"><a href="#PC启动流程简述" class="headerlink" title="PC启动流程简述"></a>PC启动流程简述</h2><p>先了解一下当<code>PC</code>加电后，整个物理地址空间分布。</p><p><img src="http://7xrsib.com1.z0.glb.clouddn.com/2016-11-03%2020-55-37%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p><p>早期的<code>16位</code>计算机是只有<code>1MB</code>的寻址能力。也就是说只能使用<code>0x0000 - 0xffff</code>这么多，如上图所示，<code>640kb</code>以下的部分为早期计算机使用的部分。而上面<code>640kb - 1mb</code>的这些地方则保留下来作为特殊使用，比如视频显示之类的。其中最重要的部分为<code>BIOS( Basic Input/Output System)</code>，<code>BIOS</code>的主要责任为进行一些自检，然后从启动设备中，并载入它的第一扇区到内存的特定位置，即<code>0x7c00</code>，然后跳转到这个位置继续执行。此时，<code>BIOS</code>的工作完成。<code>0x7c00</code> 即是<code>bootloader</code>的入口点。</p><p>当现代计算机突破了<code>1MB</code>内存，达到<code>4GB</code>甚至更多的时候，依然保留了最开始的<code>1M</code>内存空间。所以开始一开始加电以后，是处于实模式的，也就是只有<code>1MB</code>内存可以访问。<code>bootloader</code>会把实模式切换到保护模式。也就是<code>4GB</code>寻址模式。然后再读取<code>kernel</code>到内存中，并且把控制权转给<code>kernel</code>。至此操作系统才算真正的启动起来。</p><p>下面简单总结下启动流程。</p><ol><li><code>PC</code>启动，并且执行第一条指令，位于<code>0xffff0</code>。是一条跳转指令，跳到<code>BIOS</code>刚开始的地方</li><li><code>BIOS</code> 进行初始化。</li><li><code>BIOS</code>搜寻启动设备，并加载<code>bootloader</code>到内存中，转移控制给<code>bootloader</code></li><li><code>bootloader</code>从实模式切换到保护模式</li><li><code>bootloader</code>从硬盘中读取<code>kernel</code>到内存中，并转移控制给<code>kernel</code></li><li>操作系统启动<a id="more"></a></li></ol><h2 id="关于实模式和保护模式"><a href="#关于实模式和保护模式" class="headerlink" title="关于实模式和保护模式"></a>关于实模式和保护模式</h2><p>实模式即是当<code>PC</code>加电时，处于的模式，仅仅只有<code>16位</code>寻址能力。实模式将内存看成分段的区域。程序段和数据位于不同的区域。但是不区分<code>kernel</code>的操作还是用户的操作，也就是说每一个指针都指向实际的物理地址。很明显，这是致命的。可以通过修改<code>A20</code>地址线可以完成从实模式到保护模式的转换，具体如何转换我也不是很清楚，有兴趣的朋友自己研究。</p><p>在实模式下，地址如下翻译 <code>physical address = 16 * segment + offset</code>。目前你只需要知道在保护模式下，地址翻译与实模式下不同即可。</p><h2 id="Exercise"><a href="#Exercise" class="headerlink" title="Exercise"></a>Exercise</h2><h4 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise 3"></a>Exercise 3</h4><blockquote><p>At what point does the processor start executing 32-bit code? What exactly causes the switch from 16- to 32-bit mode?</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># Switch from real to protected mode, using a bootstrap GDT</span><br><span class="line"># and segment translation that makes virtual addresses</span><br><span class="line"># identical to their physical addresses, so that the</span><br><span class="line"># effective memory map does not change during the switch.</span><br><span class="line">lgdt    gdtdesc</span><br><span class="line">movl    %cr0, %eax</span><br><span class="line">orl     $CR0_PE_ON, %eax</span><br><span class="line">movl    %eax, %cr0</span><br><span class="line"></span><br><span class="line"># Jump to next instruction, but in 32-bit code segment.</span><br><span class="line"># Switches processor into 32-bit mode.</span><br><span class="line">ljmp    $PROT_MODE_CSEG, $protcseg</span><br></pre></td></tr></table></figure><p>不多解释，注释很清楚。</p><blockquote><p>What is the <em>last</em> instruction of the boot loader executed, and what is the <em>first</em> instruction of the kernel it just loaded?</p></blockquote><p><code>((void (*)(void)) (ELFHDR-&gt;e_entry))();</code> 根据<code>main.c</code> 的代码，这是最后一条代码。然后我们去看反汇编文件<code>boot.asm</code>。搜索上面那条代码，很清楚的可以看到最后一条指令如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// call the entry point from the ELF header</span><br><span class="line">// note: does not return!</span><br><span class="line">((void (*)(void)) (ELFHDR-&gt;e_entry))();</span><br><span class="line">7d6b:   ff 15 18 00 01 00       call   *0x10018</span><br></pre></td></tr></table></figure><p>第一条<code>kernel</code>执行的语句如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movw    $0x1234,0x472           # warm boot</span><br></pre></td></tr></table></figure><blockquote><p>Where is the first instruction of the kernel?</p></blockquote><p>让我困惑的是，当我实际<code>debug</code>的时候发现，并没有跳到<code>0x10018</code>去执行<code>kernel</code>，反而跳到了<code>0x10000c</code>。估计大概是由于内存映射之类的原因。故猜想<code>0x10018</code>可是是<code>c语言</code>的虚拟地址。</p><blockquote><p>How does the boot loader decide how many sectors it must read in order to fetch the entire kernel from disk? Where does it find this information?</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ph = (struct Proghdr *) ((<span class="keyword">uint8_t</span> *) ELFHDR + ELFHDR-&gt;e_phoff); <span class="comment">//e_phoff是header表的位置偏移</span></span><br><span class="line">eph = ph + ELFHDR-&gt;e_phnum;   <span class="comment">//e_phnum是header的数目</span></span><br><span class="line"><span class="keyword">for</span> (; ph &lt; eph; ph++)</span><br><span class="line">    <span class="comment">// p_pa is the load address of this segment (as well</span></span><br><span class="line">    <span class="comment">// as the physical address)</span></span><br><span class="line">    readseg(ph-&gt;p_pa, ph-&gt;p_memsz, ph-&gt;p_offset);</span><br></pre></td></tr></table></figure><p>注释很清楚了，也就是分别获取起始地址和结束地址，再来个循环，分块读取。</p><h4 id="Exercise-5"><a href="#Exercise-5" class="headerlink" title="Exercise 5"></a>Exercise 5</h4><p><code>ELF</code>二进制文件，文件开头是一唱串固定长度的<code>program header</code>，保存了程序所需要的各种<code>section</code>，比如<code>.text</code>保存了程序指令，<code>.data</code>则保存了已经初始化的静态变量，如<code>int x =0</code>。使用<code>objdump -h obj/kern/kernel</code>可查看段信息。其实特别需要注意<code>.text</code>段中的 <code>VMA</code> 和<code>LMA</code>列。分别代表链接地址<code>(link address)</code>和加载地址<code>(load address)</code>。 <code>VMA</code>指的是程序运行时的虚拟地址，而<code>LMA</code>则是程序真正载入到内存的时的物理地址。大部分时候这两个地址是一样的，但也有不同的时候。</p><p>这个练习就是修改一下<code>boot/Makefrag</code>中<code>-Ttext 0x7C00</code>的地址，让<code>bootloader</code>的<code>VMA</code>和<code>LMA</code>不一样。重新编译运行，程序会崩溃。</p><h4 id="Exercise-6"><a href="#Exercise-6" class="headerlink" title="Exercise 6"></a>Exercise 6</h4><blockquote><p>Examine the 8 words of memory at 0x00100000 at the point the BIOS enters the boot loader, and then again at the point the boot loader enters the kernel. Why are they different? What is there at the second breakpoint? (You do not really need to use QEMU to answer this question. Just think.)</p></blockquote><p>实验结果如下</p><p><img src="http://7xrsib.com1.z0.glb.clouddn.com/2016-11-04%2013-38-22%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p><p>当<code>bootloader</code> 运行之前<code>0x00100000</code>是空，运行完之后，被填充满了。猜想是<code>bootloader</code>把<code>kernel</code>填充到这里来了。查看代码，确实如此。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* AT(...) gives the load address of this section, which tells</span><br><span class="line">   the boot loader where to load the kernel in physical memory */</span><br><span class="line">.text : AT(0x100000) &#123;</span><br><span class="line">    *(.text .stub .text.* .gnu.linkonce.t.*)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Exercise-7"><a href="#Exercise-7" class="headerlink" title="Exercise 7"></a>Exercise 7</h4><blockquote><p>Use QEMU and GDB to trace into the JOS kernel and stop at the <code>movl %eax, %cr0</code>. Examine memory at 0x00100000 and at 0xf0100000. Now, single step over that instruction using the stepi GDB command. Again, examine memory at 0x00100000 and at 0xf0100000. Make sure you understand what just happened.</p><p>What is the first instruction <em>after</em> the new mapping is established that would fail to work properly if the mapping weren’t in place? Comment out the <code>movl %eax, %cr0</code> inkern/entry.S, trace into it, and see if you were right.</p></blockquote><p>实验结果如下</p><p><img src="http://7xrsib.com1.z0.glb.clouddn.com/2016-11-04%2014-10-16%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p><p>当运行<code>movl %eax, %cr0</code> 之后， 两个地址都指向了同一个地方也就是<code>0x00100000</code>，说明完成了地址映射。当我们把<code>movl %eax, %cr0</code> 注释掉之后，<code>os</code>启动崩溃，生成错误如下。</p><p><code>qemu: fatal: Trying to execute code outside RAM or ROM at 0xf010002c</code></p><h4 id="Exercise-8"><a href="#Exercise-8" class="headerlink" title="Exercise 8"></a>Exercise 8</h4><blockquote><p>We have omitted a small fragment of code - the code necessary to print octal numbers using patterns of the form “%o”. Find and fill in this code fragment.</p></blockquote><p>修改代码如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">'o'</span>:</span><br><span class="line">            <span class="comment">// Replace this with your code.</span></span><br><span class="line">            <span class="comment">//putch('X', putdat);</span></span><br><span class="line">            <span class="comment">//putch('X', putdat);</span></span><br><span class="line">            <span class="comment">//putch('X', putdat);</span></span><br><span class="line">            num = getuint(&amp;ap, lflag);</span><br><span class="line">            base = <span class="number">8</span>;</span><br><span class="line">            <span class="keyword">goto</span> number;</span><br></pre></td></tr></table></figure><p>回答下列问题</p><blockquote><p>Explain the interface between printf.c and console.c. Specifically, what function does console.c export? How is this function used by printf.c?</p></blockquote><p><code>printf.c</code>在其<code>putch()</code>函数中调用了<code>cputchar()</code> 。<code>console.c</code> 封装了一些与硬件接触的函数，如<code>getchar()</code>与<code>cputchar()</code>。</p><blockquote><p>Explain the following from console.c:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">1</span>      <span class="keyword">if</span> (crt_pos &gt;= CRT_SIZE) &#123;</span><br><span class="line">&gt; <span class="number">2</span>              <span class="keyword">int</span> i;</span><br><span class="line">&gt; <span class="number">3</span>              memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * <span class="keyword">sizeof</span>(<span class="keyword">uint16_t</span>));</span><br><span class="line">&gt; <span class="number">4</span>              <span class="keyword">for</span> (i = CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i++)</span><br><span class="line">&gt; <span class="number">5</span>                      crt_buf[i] = <span class="number">0x0700</span> | <span class="string">' '</span>;</span><br><span class="line">&gt; <span class="number">6</span>              crt_pos -= CRT_COLS;</span><br><span class="line">&gt; <span class="number">7</span>      &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>处理屏幕满了的情况。丢弃第一行。然后把后面的往上移。</p><blockquote><p>For the following questions you might wish to consult the notes for Lecture 2. These notes cover GCC’s calling convention on the x86.</p><p>Trace the execution of the following code step-by-step:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">int</span> x = <span class="number">1</span>, y = <span class="number">3</span>, z = <span class="number">4</span>;</span><br><span class="line">&gt; cprintf(<span class="string">"x %d, y %x, z %d\n"</span>, x, y, z);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><ul><li>In the call to <code>cprintf()</code>, to what does <code>fmt</code> point? To what does <code>ap</code> point?</li><li>List (in order of execution) each call to <code>cons_putc</code>, <code>va_arg</code>, and <code>vcprintf</code>. For <code>cons_putc</code>, list its argument as well. For <code>va_arg</code>, list what <code>ap</code> points to before and after the call. For <code>vcprintf</code> list the values of its two arguments.</li></ul></blockquote><p><code>fmt</code> 指向字符串 <code>$4 = 0xf0101b4e &quot;x %d, y %x, z %d\n&quot;</code> ，<code>ap</code> 则指向第二个参数的地址，即是<code>x</code>的地址。</p><p>接下来我们跟踪调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cprintf (fmt=<span class="number">0xf0101b4e</span> <span class="string">"x %d, y %x, z %d\n"</span>)</span><br><span class="line">vcprintf (fmt=<span class="number">0xf0101b4e</span> <span class="string">"x %d, y %x, z %d\n"</span>, ap=<span class="number">0xf010ff64</span> <span class="string">"\001"</span>)</span><br><span class="line">vprintfmt (putch=<span class="number">0xf01008cf</span> &lt;putch&gt;, putdat=<span class="number">0xf010ff2c</span>, fmt=<span class="number">0xf0101b4e</span> <span class="string">"x %d, y %x, z %d\n"</span>, ap=<span class="number">0xf010ff64</span> <span class="string">"\001"</span>)</span><br><span class="line">cons_putc (c=<span class="number">120</span>)</span><br></pre></td></tr></table></figure><p>当<code>va_arg</code>调用之后，<code>(va_list) 0xf010ff68 &quot;\003&quot;</code> 指向了第二个参数，也就是 <code>y</code>。</p><blockquote><p>Run the following code.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0x00646c72</span>;</span><br><span class="line">&gt; cprintf(<span class="string">"H%x Wo%s"</span>, <span class="number">57616</span>, &amp;i);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>What is the output? </p></blockquote><p>输出为<code>He110 World</code> 。比较简单，不多做解释。</p><blockquote><p>In the following code, what is going to be printed after <code>&#39;y=&#39;</code>? (note: the answer is not a specific value.) Why does this happen?</p><p>   <code>cprintf(&quot;x=%d y=%d&quot;, 3);</code></p></blockquote><p>输出为<code>x=3 y=-267380676</code>。因为只传入了一个参数，也就是<code>va_list</code>长度为一，当要输出第二个参数，<code>ap</code>处存放的是随机的数。</p><blockquote><p>Let’s say that GCC changed its calling convention so that it pushed arguments on the stack in declaration order, so that the last argument is pushed last. How would you have to change cprintf or its interface so that it would still be possible to pass it a variable number of arguments?</p></blockquote><p>既然要改变了入栈了，那么则要改变<code>va_arg</code>读取顺序。在网上找到一种方法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> va_arg(ap,t) \</span></span><br><span class="line">   (*(t *)((ap -= __va_size(t)) + __va_size(t)))</span><br></pre></td></tr></table></figure><h4 id="Exercise-9"><a href="#Exercise-9" class="headerlink" title="Exercise 9"></a>Exercise 9</h4><blockquote><p>Determine where the kernel initializes its stack, and exactly where in memory its stack is located. How does the kernel reserve space for its stack? And at which “end” of this reserved area is the stack pointer initialized to point to?</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">movl    $0x0,%ebp           # nuke frame pointer</span><br><span class="line">movl    $(bootstacktop),%esp # Set the stack pointer</span><br></pre></td></tr></table></figure><p><code>kern/entry.S</code> 中的上述代码设置了栈。根据反汇编文件可知，这个<code>bootstacktop</code>的地址为<code>0xf0110000</code> 。栈的预留靠<code>.space KSTKSIZE</code>实现。</p><h4 id="Exercise-10"><a href="#Exercise-10" class="headerlink" title="Exercise 10"></a>Exercise 10</h4><blockquote><p>To become familiar with the C calling conventions on the x86, find the address of the <code>test_backtrace</code> function in obj/kern/kernel.asm, set a breakpoint there, and examine what happens each time it gets called after the kernel starts. How many 32-bit words does each recursive nesting level of <code>test_backtrace</code> push on the stack, and what are those words?</p></blockquote><p>在 <code>obj/kern/kernel.asm</code> 中找到 函数的入口地址为<code>0xf0100040</code> 。接下来跟踪调试，查看每次<code>esp</code> 的变化。这里涉及到的是栈的知识，不多解释，最好的学习资料是<code>csapp</code>的<code>lab2</code>。</p><p>每调用一次<code>test_backtrace</code>。会发生如下事情。</p><ol><li>压入参数</li><li>压入返回地址，为下一行地址。</li><li>压入<code>ebp</code></li><li>更新<code>ebp</code>为<code>esp</code>的值，此时设立了函数的栈帧</li><li>压入<code>ebx</code> 用来保存临时变量之类的</li><li>扩大栈，也就是<code>esp</code>减去某个值<code>(栈是向下生长的)</code>，为函数分配空间</li></ol><p>通过<code>gdb</code>分析，每次调用会压入<code>8个字</code>。压入的内容就是我上面说的那些。</p><h4 id="Exercise-11"><a href="#Exercise-11" class="headerlink" title="Exercise 11"></a>Exercise 11</h4><blockquote><p> Implement the backtrace function as specified above</p></blockquote><p>通过上面的分析，此题不难。无非是用<code>read_ebp</code>获得<code>ebp</code>，然后就可获得所有需要的内容。</p><h4 id="Exercise-12"><a href="#Exercise-12" class="headerlink" title="Exercise 12"></a>Exercise 12</h4><blockquote><p>Modify your stack backtrace function to display, for each eip, the function name, source file name, and line number corresponding to that eip.</p></blockquote><p>此题关键是补全<code>debuginfo_eip</code>，实现查找行号。下面是我的实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stab_binsearch(stabs, &amp;lline, &amp;rline, N_SLINE, addr);</span><br><span class="line"><span class="keyword">if</span> (lline &gt; rline)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">info-&gt;eip_line = stabs[lline].n_desc;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上则是全部内容。具体代码在 <a href="https://github.com/threezj/mit6.828" target="_blank" rel="noopener">github:mit 6.828</a> 。看似短短的一个<code>lab1</code>，花费了大量的时间，确实不容易。虽然写的代码不多，但对操作系统启动的理解是很深入的。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://pdos.csail.mit.edu/6.828/2016/schedule.html" target="_blank" rel="noopener">mit 6.828 2016</a></p><p><a href="http://www.cnblogs.com/fatsheep9146/" target="_blank" rel="noopener">fatsheep9146的csdn博客</a></p><p><a href="https://github.com/valkjsaaa/PKU-OS-Labs" target="_blank" rel="noopener">valkjsaaa的github</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;开启一场漫长且有趣的旅程，即日起开始学习&lt;code&gt;MIT 6.828&lt;/code&gt;。总共有七个&lt;code&gt;lab&lt;/code&gt;。&lt;code&gt;lab6&lt;/code&gt;和&lt;code&gt;lab7&lt;/code&gt;其中选一个做。&lt;/p&gt;
&lt;h2 id=&quot;PC启动流程简述&quot;&gt;&lt;a href=&quot;#PC启动流程简述&quot; class=&quot;headerlink&quot; title=&quot;PC启动流程简述&quot;&gt;&lt;/a&gt;PC启动流程简述&lt;/h2&gt;&lt;p&gt;先了解一下当&lt;code&gt;PC&lt;/code&gt;加电后，整个物理地址空间分布。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrsib.com1.z0.glb.clouddn.com/2016-11-03%2020-55-37%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;早期的&lt;code&gt;16位&lt;/code&gt;计算机是只有&lt;code&gt;1MB&lt;/code&gt;的寻址能力。也就是说只能使用&lt;code&gt;0x0000 - 0xffff&lt;/code&gt;这么多，如上图所示，&lt;code&gt;640kb&lt;/code&gt;以下的部分为早期计算机使用的部分。而上面&lt;code&gt;640kb - 1mb&lt;/code&gt;的这些地方则保留下来作为特殊使用，比如视频显示之类的。其中最重要的部分为&lt;code&gt;BIOS( Basic Input/Output System)&lt;/code&gt;，&lt;code&gt;BIOS&lt;/code&gt;的主要责任为进行一些自检，然后从启动设备中，并载入它的第一扇区到内存的特定位置，即&lt;code&gt;0x7c00&lt;/code&gt;，然后跳转到这个位置继续执行。此时，&lt;code&gt;BIOS&lt;/code&gt;的工作完成。&lt;code&gt;0x7c00&lt;/code&gt; 即是&lt;code&gt;bootloader&lt;/code&gt;的入口点。&lt;/p&gt;
&lt;p&gt;当现代计算机突破了&lt;code&gt;1MB&lt;/code&gt;内存，达到&lt;code&gt;4GB&lt;/code&gt;甚至更多的时候，依然保留了最开始的&lt;code&gt;1M&lt;/code&gt;内存空间。所以开始一开始加电以后，是处于实模式的，也就是只有&lt;code&gt;1MB&lt;/code&gt;内存可以访问。&lt;code&gt;bootloader&lt;/code&gt;会把实模式切换到保护模式。也就是&lt;code&gt;4GB&lt;/code&gt;寻址模式。然后再读取&lt;code&gt;kernel&lt;/code&gt;到内存中，并且把控制权转给&lt;code&gt;kernel&lt;/code&gt;。至此操作系统才算真正的启动起来。&lt;/p&gt;
&lt;p&gt;下面简单总结下启动流程。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;PC&lt;/code&gt;启动，并且执行第一条指令，位于&lt;code&gt;0xffff0&lt;/code&gt;。是一条跳转指令，跳到&lt;code&gt;BIOS&lt;/code&gt;刚开始的地方&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BIOS&lt;/code&gt; 进行初始化。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BIOS&lt;/code&gt;搜寻启动设备，并加载&lt;code&gt;bootloader&lt;/code&gt;到内存中，转移控制给&lt;code&gt;bootloader&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bootloader&lt;/code&gt;从实模式切换到保护模式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bootloader&lt;/code&gt;从硬盘中读取&lt;code&gt;kernel&lt;/code&gt;到内存中，并转移控制给&lt;code&gt;kernel&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;操作系统启动
    
    </summary>
    
    
      <category term="Operating system" scheme="http://threezj.com/tags/Operating-system/"/>
    
      <category term="MIT 6.828" scheme="http://threezj.com/tags/MIT-6-828/"/>
    
  </entry>
  
  <entry>
    <title>生成学习算法</title>
    <link href="http://threezj.com/2016/10/30/%E7%94%9F%E6%88%90%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/"/>
    <id>http://threezj.com/2016/10/30/生成学习算法/</id>
    <published>2016-10-30T13:21:06.000Z</published>
    <updated>2018-04-17T15:34:17.723Z</updated>
    
    <content type="html"><![CDATA[<h2 id="生成学习算法"><a href="#生成学习算法" class="headerlink" title="生成学习算法"></a>生成学习算法</h2><p>可能大部分人之前学过的分类算法，都是基于<code>train data</code>来最佳化参数，从而得到<code>data</code>的类别。也就是基于<code>p(y|x; θ)</code>来进行学习，比如<code>Logistic Regression</code>。现在我们换一种思路，反过来求解，分别对<code>p(x|y)</code> 求解，也就是说，对每一个<code>y</code>，<code>model</code>一个概率模型。当需要对新的<code>data</code>分类时，分别计算属于每个类的概率，从而得到最优的类别。公式基于贝叶斯定理,如下所示。</p><p><img src="http://7xrsib.com1.z0.glb.clouddn.com/2016-10-29%2023-45-27%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""><br><a id="more"></a></p><h2 id="高斯线性判别"><a href="#高斯线性判别" class="headerlink" title="高斯线性判别"></a>高斯线性判别</h2><p>这个算法前提是<code>p(x|y)</code> 是基于多变量正态分布。多变量正态分布模型如下。</p><p><img src="http://7xrsib.com1.z0.glb.clouddn.com/2016-10-29%2023-45-08%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p><p>现在因为只有两种情况，<code>y</code>属于伯努利分布，然后分别对两种情况来model 多变量正态分布</p><p><img src="http://7xrsib.com1.z0.glb.clouddn.com/2016-10-29%2023-44-52%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p><p>对所有样本的几率和取对数，进行最大似然估计。</p><p><img src="http://7xrsib.com1.z0.glb.clouddn.com/2016-10-29%2023-42-53%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p><p>好，现在我们共有四个参数<code>φ</code>,<code>Σ</code>, <code>μ0</code> ,<code>μ1</code> 。根据上面公式可分别求出四个参数。</p><p><img src="http://7xrsib.com1.z0.glb.clouddn.com/2016-10-29%2023-43-20%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p><p>到这里，高斯线性判别已经结束。我们分别对两个类型，进行拟合高斯模型。接下来需要分类的话，只需要对新的<code>data</code>分别用各自的高斯函数求解比较即可。具体的做法如下图。</p><p><img src="http://7xrsib.com1.z0.glb.clouddn.com/2016-10-29%2023-43-27%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p><h4 id="GDA与Logistics回归"><a href="#GDA与Logistics回归" class="headerlink" title="GDA与Logistics回归"></a>GDA与Logistics回归</h4><p>其实正好是一个相反的关系，当我们求解<code>p(y = 1|x;φ,μ0,μ1,Σ)</code>时，便是在求解Logistics回归，我们用上面的公式，并运用贝叶斯公式，即可得到Logistics回归的公式。</p><p>那么我们到底应该选用哪种算法？</p><p>大部分的情况下，Logistics回归的表现都会比GDA要好。因为GDA对数据分布模型依赖性很强。因为GDA的前提是<code>p(x|y)</code>是多变量正态分布的。当<code>p(x|y)</code>是多变量正态分布时，<code>p(y|x)</code>一定是Logistics回归的表现形式。然而反过来却不一定。也就是说GDA做了一个更强的假设。</p><h2 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h2><p>朴素贝叶斯也是属于生成学习算法的一种。既然是属于生成学习算法，那我们的目标只有一个。那就是计算<code>p(y|x)</code>的概率，选取最大的那一类。理论还是和之前一样，使用贝叶斯公式，反过来计算。此处有个问题，若x是多维的应该如何计算。这里有一个强假设，就是说每一个特征的概率与其他概率是不相关的。这就是<code>Naive Bayes (NB) assumption</code>，这在实际生活中，当然是不可能的，但是即使如此，贝叶斯分类的效果依然是很好的。</p><p><img src="http://7xrsib.com1.z0.glb.clouddn.com/2016-10-31%2020-40-54%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p><p>在上面的公式中，我们其实只有三个参数，我们分别用 <code>φi|y=1 = p(xi=1|y=1)</code>,<code>φi|y=0 = p(xi=1|y=0)</code>和 <code>φy = p(y=1)</code> 来表示。计算公式如下。</p><p><img src="http://7xrsib.com1.z0.glb.clouddn.com/2016-10-31%2020-40-44%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>下面给出一维的实现，多维其实一样的，只不过是把每一维都乘起来。粗粗一写，原谅不良的变量名，以及大量复制黏贴。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一维特征情况</span></span><br><span class="line">train_data = [ &#123;<span class="string">'Name'</span>:<span class="string">'Drew'</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'Name'</span>:<span class="string">'Claudia'</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'Name'</span>:<span class="string">'Drew'</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'Name'</span>:<span class="string">'Drew'</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'Name'</span>:<span class="string">'Alberto'</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'Name'</span>:<span class="string">'Karin'</span>&#125;, </span><br><span class="line">        &#123;<span class="string">'Name'</span>:<span class="string">'Nina'</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'Name'</span>:<span class="string">'Sergio'</span>&#125; ]</span><br><span class="line">train_label = [<span class="string">'Male'</span>,<span class="string">'Female'</span>,<span class="string">'Female'</span>,<span class="string">'Female'</span>,<span class="string">'Male'</span>,<span class="string">'Female'</span>,<span class="string">'Female'</span>,<span class="string">'Male'</span>]</span><br><span class="line">predict_data = [&#123;<span class="string">'Name'</span>:<span class="string">'Drew'</span>&#125;]</span><br><span class="line">predict_label = <span class="keyword">None</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多维特征的情况</span></span><br><span class="line"><span class="comment"># train_data = [ &#123;'Name':'Drew','Over170':'No','Eye':'Blue','Hair':'Short'&#125;,</span></span><br><span class="line"><span class="comment">#         &#123;'Name':'Claudia','Over170':'Yes','Eye':'Brown','Hair':'Long'&#125;,</span></span><br><span class="line"><span class="comment">#         &#123;'Name':'Drew','Over170':'No','Eye':'Blue','Hair':'Long'&#125;,</span></span><br><span class="line"><span class="comment">#         &#123;'Name':'Drew','Over170':'No','Eye':'Blue','Hair':'Long'&#125;,</span></span><br><span class="line"><span class="comment">#         &#123;'Name':'Alberto','Over170':'Yes','Eye':'Brown','Hair':'Short'&#125;,</span></span><br><span class="line"><span class="comment">#         &#123;'Name':'Karin','Over170':'No','Eye':'Blue','Hair':'Long'&#125;, </span></span><br><span class="line"><span class="comment">#         &#123;'Name':'Nina','Over170':'Yes','Eye':'Brown','Hair':'Short'&#125;,</span></span><br><span class="line"><span class="comment">#         &#123;'Name':'Sergio','Over170':'Yes','Eye':'Blue','Hair':'Long'&#125; ]</span></span><br><span class="line"><span class="comment"># train_label = ['Male','Female','Female','Female','Male','Female','Female','Male']</span></span><br><span class="line"><span class="comment"># predict_data = [&#123;'Name':'Drew','Over170':'Yes','Eye':'Blue','Hair':'Long'&#125;]</span></span><br><span class="line"><span class="comment"># predict_label = None;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(X, Y, predicted)</span>:</span></span><br><span class="line">    theta_y1 = <span class="number">0</span> <span class="comment"># φi|y=1</span></span><br><span class="line">    theta_y0 = <span class="number">0</span> <span class="comment"># φi|y=0</span></span><br><span class="line">    theta_y = <span class="number">0</span> <span class="comment"># φy</span></span><br><span class="line"></span><br><span class="line">    t1 = <span class="number">0</span></span><br><span class="line">    t2 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(X)):</span><br><span class="line">        <span class="keyword">if</span> X[i][<span class="string">'Name'</span>] == predict_data[<span class="number">0</span>][<span class="string">'Name'</span>] <span class="keyword">and</span> Y[i] == predicted:</span><br><span class="line">            t1 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> Y[i] == predicted:</span><br><span class="line">            t2 += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    theta_y1 = t1 / t2</span><br><span class="line"></span><br><span class="line">    t1 = <span class="number">0</span></span><br><span class="line">    t2 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(X)):</span><br><span class="line">        <span class="keyword">if</span> X[i][<span class="string">'Name'</span>] == predict_data[<span class="number">0</span>][<span class="string">'Name'</span>] <span class="keyword">and</span> Y[i] != predicted:</span><br><span class="line">            t1 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> Y[i] != predicted:</span><br><span class="line">            t2 += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    theta_y0 = t1 / t2</span><br><span class="line"></span><br><span class="line">    t1 = <span class="number">0</span></span><br><span class="line">    t2 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(X)):</span><br><span class="line">        <span class="keyword">if</span> Y[i] == predicted:</span><br><span class="line">            t1 += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    theta_y = t1 / len(X)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (theta_y1, theta_y0, theta_y)</span><br><span class="line"></span><br><span class="line">theta_y1, theta_y0, theta_y = predict(train_data, train_label, <span class="string">'Male'</span>)</span><br><span class="line"></span><br><span class="line">print(theta_y1 * theta_y / (theta_y1 * theta_y + theta_y0 * (<span class="number">1</span> - theta_y)))</span><br></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>CS229</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;生成学习算法&quot;&gt;&lt;a href=&quot;#生成学习算法&quot; class=&quot;headerlink&quot; title=&quot;生成学习算法&quot;&gt;&lt;/a&gt;生成学习算法&lt;/h2&gt;&lt;p&gt;可能大部分人之前学过的分类算法，都是基于&lt;code&gt;train data&lt;/code&gt;来最佳化参数，从而得到&lt;code&gt;data&lt;/code&gt;的类别。也就是基于&lt;code&gt;p(y|x; θ)&lt;/code&gt;来进行学习，比如&lt;code&gt;Logistic Regression&lt;/code&gt;。现在我们换一种思路，反过来求解，分别对&lt;code&gt;p(x|y)&lt;/code&gt; 求解，也就是说，对每一个&lt;code&gt;y&lt;/code&gt;，&lt;code&gt;model&lt;/code&gt;一个概率模型。当需要对新的&lt;code&gt;data&lt;/code&gt;分类时，分别计算属于每个类的概率，从而得到最优的类别。公式基于贝叶斯定理,如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrsib.com1.z0.glb.clouddn.com/2016-10-29%2023-45-27%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Machine Learning" scheme="http://threezj.com/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>我对于动态规划的理解</title>
    <link href="http://threezj.com/2016/10/12/%E6%88%91%E5%AF%B9%E4%BA%8E%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://threezj.com/2016/10/12/我对于动态规划的理解/</id>
    <published>2016-10-12T06:06:06.000Z</published>
    <updated>2018-04-17T15:36:25.707Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>动态规划很早就接触过了，但一直都心存疑惑。网上的一些文章，基本都是满篇术语。<code>状态转移</code>， <code>状态方程</code>，这种名词，其实是让初学者比较迷惑。直到我上完<code>Berkeley</code>的<a href="http://cs61a.org/" target="_blank" rel="noopener">CS 61 A</a>, 突然就理解了所谓的动态规划。或者说是真正的理解了递归。把玩函数式语言对理解递归，或者说程序结构，非常有帮助。<a href="https://www.amazon.cn/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E8%A7%A3%E9%87%8A/dp/B0011AP7RY/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1476242304&amp;sr=1-1&amp;keywords=SICP" target="_blank" rel="noopener">SICP</a> 这本书已经很多人推荐了，用<code>Scheme</code>讲的，我没看完，看了大概前面两章。我比较推荐的是<code>华盛顿大学</code>的<a href="http://courses.cs.washington.edu/courses/cse341/16sp/" target="_blank" rel="noopener">Programming Languages</a> 还有上面<code>Berkeley</code>那门课。</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>我认为所谓的动态规划，就是递归的记忆化过程。这里必须要提一个函数式语言的好处，支持<code>尾递归</code>。<code>尾递归</code>可以用来防止重复计算。可惜很多语言并不支持，很容易就栈溢出了，比如<code>JAVA</code> ，<code>Python</code>。所以需要把递归改写成循环形式。其实本质还是和尾递归一样。<br><a id="more"></a></p><h2 id="斐波那契"><a href="#斐波那契" class="headerlink" title="斐波那契"></a>斐波那契</h2><p>首先我门先写一个递归版的斐波那契。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> fib(n -<span class="number">1</span>) + fib(n -<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数有大量的重复计算。是个树形结构。比如计算<code>fib(10)</code>，那么他会分别计算<code>fib(9)</code>,<code>fib(8)</code>,当计算<code>fib(9)</code>时，会计算<code>fib(8)</code>,<code>fib(7)</code>,<code>fib(6)</code>…但是当计算<code>fib(8)</code>时，上面的计算过程又要重复一遍。</p><p>我测试了一下<code>fib(50)</code>，已经要等很久才出结果了。</p><p>接下来我们改写它。把计算的过程储存起来。也就是<code>记忆化</code>。</p><h4 id="变形一"><a href="#变形一" class="headerlink" title="变形一"></a>变形一</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span>[] fibs = <span class="keyword">new</span> <span class="keyword">double</span>[N];</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (fibs[n] != <span class="number">0</span>) <span class="keyword">return</span> fibs[n];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> fibs[n] = fib(n -<span class="number">1</span>) + fib(n -<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单。多开了个数组来保存已经计算过的值。节省大量重复的计算。<code>fib(50)</code>可以秒算。这其实就是一个动态规划的过程。注意这里有两个比较动态规划比较重要的特性。也就是<code>重叠子问题</code> 和<code>最优子结构</code>。比如说斐波那契的每一个数，都是依靠前面两个数的和计算得出，也就是<code>最优子结构</code>。但如果不记忆化，就会有大量重复计算，这就是<code>重叠子问题</code> 。</p><p>接下来我们再来看一个尾递归版，但是注意<code>JAVA</code>并不支持尾递归，容易栈溢出。这里只做演示。</p><h4 id="变形二"><a href="#变形二" class="headerlink" title="变形二"></a>变形二</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">fib_tail</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fib_tail(n - <span class="number">1</span>, b, a + b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过把计算结果保存到参数中，来简化计算结果。其实原理和上面开数组是一样的。也可以秒算<code>fib_tail(50,1,1)</code> 。</p><h4 id="变形三"><a href="#变形三" class="headerlink" title="变形三"></a>变形三</h4><p>第三种方法直接用循环来做。既节省递归切换的时间，又避免了尾递归栈溢出的烦恼。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">fib3</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">double</span> c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        c = a + b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是这么简单。下面看一个略复杂的。</p><h2 id="House-Robber"><a href="#House-Robber" class="headerlink" title="House Robber"></a>House Robber</h2><p><a href="https://leetcode.com/problems/house-robber/" target="_blank" rel="noopener">House Robber</a> 。大概意思就是给你个数组，挑一串数字使和最大化，但每两个数不能相邻。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] robs;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        robs = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        Arrays.fill(robs,-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> rob(nums,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= nums.length) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (robs[i] != -<span class="number">1</span>) <span class="keyword">return</span> robs[i];</span><br><span class="line">        <span class="keyword">int</span> max = Integer.max(rob(nums,i+<span class="number">1</span>),nums[i] + rob(nums,i+<span class="number">2</span>));</span><br><span class="line">        <span class="keyword">return</span> robs[i] = max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是我的版本。我更喜欢用递归来描述问题。思路是数组里的每一数，我有两种选择，选或者不选，选了这个就不能选下一个，递归的求解，然后进行比较，选取较大的大个，并且用数组记忆结果。这就是所谓带备忘的<code>自顶向下法</code>。</p><p>再给出一种方法，我在<code>LeetCode</code>论坛找的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(nums.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums.length==<span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Initialize an arrays to store the money</span></span><br><span class="line"><span class="keyword">int</span>[] mark = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//We can infer the formula from problem:mark[i]=max(num[i]+mark[i-2],mark[i-1])</span></span><br><span class="line">    <span class="comment">//so initialize two nums at first.</span></span><br><span class="line">mark[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">mark[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Using Dynamic Programming to mark the max money in loop.</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">mark[i] = Math.max(nums[i]+mark[i-<span class="number">2</span>], mark[i-<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mark[nums.length-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里注释很清楚，不多做解释。这种方法也就是所谓的<code>自底向上法</code>，不需要递归切换，速度会比上面那种快。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>当然，如果你需要熟练掌握动态规划，必须进行大量的练习。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>《算法导论》</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;动态规划很早就接触过了，但一直都心存疑惑。网上的一些文章，基本都是满篇术语。&lt;code&gt;状态转移&lt;/code&gt;， &lt;code&gt;状态方程&lt;/code&gt;，这种名词，其实是让初学者比较迷惑。直到我上完&lt;code&gt;Berkeley&lt;/code&gt;的&lt;a href=&quot;http://cs61a.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CS 61 A&lt;/a&gt;, 突然就理解了所谓的动态规划。或者说是真正的理解了递归。把玩函数式语言对理解递归，或者说程序结构，非常有帮助。&lt;a href=&quot;https://www.amazon.cn/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E8%A7%A3%E9%87%8A/dp/B0011AP7RY/ref=sr_1_1?s=books&amp;amp;ie=UTF8&amp;amp;qid=1476242304&amp;amp;sr=1-1&amp;amp;keywords=SICP&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SICP&lt;/a&gt; 这本书已经很多人推荐了，用&lt;code&gt;Scheme&lt;/code&gt;讲的，我没看完，看了大概前面两章。我比较推荐的是&lt;code&gt;华盛顿大学&lt;/code&gt;的&lt;a href=&quot;http://courses.cs.washington.edu/courses/cse341/16sp/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Programming Languages&lt;/a&gt; 还有上面&lt;code&gt;Berkeley&lt;/code&gt;那门课。&lt;/p&gt;
&lt;h2 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h2&gt;&lt;p&gt;我认为所谓的动态规划，就是递归的记忆化过程。这里必须要提一个函数式语言的好处，支持&lt;code&gt;尾递归&lt;/code&gt;。&lt;code&gt;尾递归&lt;/code&gt;可以用来防止重复计算。可惜很多语言并不支持，很容易就栈溢出了，比如&lt;code&gt;JAVA&lt;/code&gt; ，&lt;code&gt;Python&lt;/code&gt;。所以需要把递归改写成循环形式。其实本质还是和尾递归一样。&lt;br&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://threezj.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>MIT 6.824 lab1</title>
    <link href="http://threezj.com/2016/09/27/MIT%206.824%20lab1/"/>
    <id>http://threezj.com/2016/09/27/MIT 6.824 lab1/</id>
    <published>2016-09-27T14:00:00.000Z</published>
    <updated>2018-04-17T15:43:53.383Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>花了几天功夫，断断续续做了下<code>lab1</code>。其实大部分时间都在看<code>Go</code>。非常非常简洁的一门语言。对并发的支持非常好。值得花时间学习。然而<code>MapReduce</code>并没想象的这么复杂。</p><h2 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h2><p>主要思想很简单。主要由<code>map</code>和<code>reduce</code>两个函数组成。(玩过函数式编程的朋友，对这两个函数应该很熟悉)，数据从<code>map</code>输入，输出一系列键值对，再由<code>reduce</code>把输出的键值对根据键组合在一起。当然最有趣的地方是，这些操作都是异步的，在多个机器上运行，所以非常快。</p><h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><ol><li>把数据分成<code>M</code>份，分别是<code>Mi</code></li><li>启动一个<code>master</code>对象，由它来控制如何分配调控</li><li><code>master</code>不断的挑出一个好的机器(<code>worker</code>)来对<code>Mi</code>进行执行<code>map</code>函数</li><li><code>map</code>函数返回一个 <code>key/value</code> 数组</li><li>然后把 <code>key/value</code> 数组分成<code>R</code>份存在本地，等待<code>Reduce</code>。当<code>map</code>全部完成后，每个<code>Mi</code>生<code>R</code>份结果。</li><li>从每个<code>Mi</code>中选择一份<code>Ri</code>。然后根据<code>Key</code>排序，把相同<code>Key</code>的<code>Value</code>合在一起，生成<code>key/list(value)</code></li><li>开始<code>reduce</code>，输入<code>list(value)</code>。</li><li>最后会生成<code>R</code>份文件</li></ol><p>最后的<code>R</code>份文件没必要直接合在一起。通常会把它们丢给下个<code>MapReduce</code></p><h2 id="lab"><a href="#lab" class="headerlink" title="lab"></a>lab</h2><p>总体来说不难。实现步骤全在<code>paper</code>中讲的很清楚了</p><ul><li><code>lab1</code> 完成两个函数<code>doMap</code>和<code>doReduce</code>。<code>doMap</code>就是完成上面<code>4,5</code>两个步骤.<code>doReduce</code>是上<br>面<code>7,8</code>两个步骤。注意这里不是异步，而是顺序执行</li><li><code>lab2</code> 实现<code>wordcount</code>，只要完成了<code>lab1</code>，<code>lab2</code>就是手到擒来的事情。</li><li><code>lab3</code> 略复杂一点。把上面<code>map</code>和<code>reduce</code>的操作变成异步。<code>Go</code>中有一个很有趣的东西，叫做<code>channel</code>可以起到很大帮助。类似于生产者消费者。这里不细讲。另外还需要一点<code>RPC</code>的知识。</li><li><code>lab4</code> 处理<code>worker</code>失败的情况。如果失败就让别的<code>worker</code>重新执行这个任务。</li></ul><p>具体代码放在<a href="https://github.com/threezj/mit-6.824" target="_blank" rel="noopener">mit-6.824</a></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://pdos.csail.mit.edu/6.824/papers/mapreduce.pdf" target="_blank" rel="noopener">MapReduce (2004)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;花了几天功夫，断断续续做了下&lt;code&gt;lab1&lt;/code&gt;。其实大部分时间都在看&lt;code&gt;Go&lt;/code&gt;。非常非常简洁的一门语言。
      
    
    </summary>
    
    
      <category term="Distributed Computing" scheme="http://threezj.com/tags/Distributed-Computing/"/>
    
  </entry>
  
  <entry>
    <title>进程与线程</title>
    <link href="http://threezj.com/2016/07/28/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    <id>http://threezj.com/2016/07/28/进程与线程/</id>
    <published>2016-07-28T07:58:06.000Z</published>
    <updated>2018-04-17T15:31:13.479Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><blockquote><p>进程是一个程序的实例</p></blockquote><p>上面是最基本进程定义。就好比说当你双击<code>txt</code>文件，就开启了一个进程运行文本编辑器。当你再双击一下，就又开启了一个进程。这两个进程互不干扰，一个进程关闭或者崩溃，并不会导致另一个进程关闭。但是这两个进程拥有一个通信的接口，就是那个<code>txt</code>文件。这两个文本编辑器使用的同一个文件，这就又引申出另一个问题，进程间通信<code>(IPC)</code>.</p><p>在举个例子程序是一系列指令的集合，就好比一个类，进程则是真正在执行这些指令的东西，就好比对象。</p><h4 id="进程的特点"><a href="#进程的特点" class="headerlink" title="进程的特点"></a>进程的特点</h4><p>进程拥有一个独立的执行环境。进程之间互不干扰。它拥有自己栈，堆，<code>code</code>，静态文本，完全自给自足。所以说一个进程拥有独立的地址空间以及一个或者多个线程。<br><a id="more"></a></p><h4 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h4><p>在<code>unix</code>系统中，进程创建执行主要靠两个函数<code>fork</code>和<code>exec</code>。</p><p>先来看<code>fork</code>，这个函数用来创建进程，执行一次返回两次。返回0的则是子进程。下面是创建过程。</p><ol><li>创建一个进程管理块<code>(PCB)</code>，这个东西保存了进程的状态，以及<code>PC</code>，寄存器等等</li><li>创建一个新的地址空间</li><li>把父进程的所有内容都拷贝的新的地址空间中，包括<code>code</code>，<code>stack</code>，<code>heap</code>，<code>static data</code>。</li><li>从父进程那里继承一些执行环境，比如打开的文件之类的</li><li>通知调度器，这个新的进程已经准备好了</li></ol><p><code>fock</code>函数就是克隆了一份当前的进程。然后<code>exec</code>，执行一个新的程序。</p><ol><li>填充程序信息到刚才创建地址空间</li><li>复制参数到内存</li><li>执行程序，状态变为<code>start</code></li></ol><p>现在才是创建了一个真正新的进程。<code>Linux</code>采用<code>copy-on-write</code>技术，也就是说当<code>fork</code>时，并不直接复制整个地址空间给子进程，而是先共享一个拷贝，直到需要写入时，才拷贝。避免了大量的不必要拷贝。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><blockquote><p>A thread of execution is the smallest sequence of programmed instructions that can be managed independently by a scheduler, which is typically a part of the operating system. A thread is a component of a process. Multiple threads can exist within one process, executing concurrently and sharing resources such as memory, while different processes do not share these resources</p></blockquote><p>上面这段来自维基百科的定义，清楚简介的定义了线程。翻译下就是说，线程就是一段代码的执行单元，可以直接被调度器调度。并且是进程的一部分，一个进程可拥有多个线程。<br>多个线程可以并行执行，共享堆，静态文本。但是每个线程拥有自己的栈。</p><p>线程比进程更加轻量级，也称之为轻量级的进程。</p><h4 id="为什么需要线程"><a href="#为什么需要线程" class="headerlink" title="为什么需要线程"></a>为什么需要线程</h4><ul><li>创建线程比创建进程的代价要低，且更迅速</li><li>清楚简洁的表示并行任务。大多数程序都拥有需要并发执行的任务，你可以简单的为每个任务创建一个线程，语义明确且好维护。</li><li>并行让任务立即响应。大幅度改善用户体验。保持用户界面流畅</li><li>提升多核处理器的效率。多个任务并行处理，能大大减少计算时间</li><li>使<code>I/O</code>更加高效。一些线程等待<code>I/O</code>数据，另外的去计算</li></ul><h2 id="进程vs线程"><a href="#进程vs线程" class="headerlink" title="进程vs线程"></a>进程vs线程</h2><ul><li>进程之间是互相独立的，而线程共享<code>heap</code>以及<code>static code</code></li><li>进程创建需要创建新的地址空间，而线程并不要求。所以创建线程比进程更便宜。</li><li>一个进程可以拥有多个线程</li><li>对于内容切换，线程比进程快很多</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>维基百科<br>《Operating Systems Principles and Practice》</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;进程&quot;&gt;&lt;a href=&quot;#进程&quot; class=&quot;headerlink&quot; title=&quot;进程&quot;&gt;&lt;/a&gt;进程&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;进程是一个程序的实例&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面是最基本进程定义。就好比说当你双击&lt;code&gt;txt&lt;/code&gt;文件，就开启了一个进程运行文本编辑器。当你再双击一下，就又开启了一个进程。这两个进程互不干扰，一个进程关闭或者崩溃，并不会导致另一个进程关闭。但是这两个进程拥有一个通信的接口，就是那个&lt;code&gt;txt&lt;/code&gt;文件。这两个文本编辑器使用的同一个文件，这就又引申出另一个问题，进程间通信&lt;code&gt;(IPC)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;在举个例子程序是一系列指令的集合，就好比一个类，进程则是真正在执行这些指令的东西，就好比对象。&lt;/p&gt;
&lt;h4 id=&quot;进程的特点&quot;&gt;&lt;a href=&quot;#进程的特点&quot; class=&quot;headerlink&quot; title=&quot;进程的特点&quot;&gt;&lt;/a&gt;进程的特点&lt;/h4&gt;&lt;p&gt;进程拥有一个独立的执行环境。进程之间互不干扰。它拥有自己栈，堆，&lt;code&gt;code&lt;/code&gt;，静态文本，完全自给自足。所以说一个进程拥有独立的地址空间以及一个或者多个线程。&lt;br&gt;
    
    </summary>
    
    
      <category term="Operating system" scheme="http://threezj.com/tags/Operating-system/"/>
    
  </entry>
  
  <entry>
    <title>为什么机器学习真的可以学到东西？</title>
    <link href="http://threezj.com/2016/07/27/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%BA%E5%99%A8%E5%8F%AF%E4%BB%A5%E5%AD%A6%E4%B9%A0%EF%BC%9F/"/>
    <id>http://threezj.com/2016/07/27/为什么机器可以学习？/</id>
    <published>2016-07-26T17:15:06.000Z</published>
    <updated>2018-04-17T15:37:41.631Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>开始跟《机器学习基石》这门课，相对于<code>Stanford</code>那门课，这门明显难度大很多，我跟到第10个<code>Lecture</code>，才刚刚讲到<code>Logistic Regression</code>。前面费了很大力气在讲机器什么时候可以学习，以及证明为什么能学习。</p><p>此文主要是基于《机器学习基石》的学习笔记。<code>Topic</code>是为什么机器可以学习？</p><h2 id="机器学习流程"><a href="#机器学习流程" class="headerlink" title="机器学习流程"></a>机器学习流程</h2><p>下面是一个粗略的机器学习流程图</p><p><img src="http://beader.me/mlnotebook/section2/images/basic_setup_of_the%20_learning_problem.png" alt=""></p><p>机器学习最开始也是最终的目的是获得一个<code>target function</code>，喂进去数据能直接得到正确结论的函数。为了得到这个函数，我们需要一大堆的训练数据。然后通过一个好的机器学习算法，从一大堆<code>可能的function(也就是H)</code>中挑选一个<code>比较好的function(也就是g)</code>，这个<code>g</code>和<code>target function</code>长得越像越好。<br><a id="more"></a></p><h2 id="Hoeffding’s-inequality"><a href="#Hoeffding’s-inequality" class="headerlink" title="Hoeffding’s inequality"></a>Hoeffding’s inequality</h2><p>大家有没有想过，为什么这样就能学到东西。我们的算法只是在训练数据上跑，从训练数据跑出来的<code>g</code>，我们怎么能确定它也能在测试数据上跑的很好呢？这个就是问题的关键。其实接下来内容主要就是论证这个问题。</p><p>先来考虑一个简单的问题。比如说我们现在有一个黑罐子，里面有很多弹珠，只有两种颜色，黄的和绿的。好现在问你，你怎么能知道黄色弹珠大概有多少颗？</p><p><img src="http://beader.me/mlnotebook/section2/images/bin_sample.png" alt=""></p><p>大家肯定都会说抽样。没错，我们抽出10个弹珠，很容易能知道黄色弹珠在<code>sample</code>中的比例。但是这个比例真的能代表罐子中的比例吗？也许能，也许不能。而且能的记录会随着我们<code>sample</code>数目的增大而增大。但是也有可能你抓出一把全绿。但这种情况发生的记录很小。这里我们有一个定理保证这种偏差发生的记录很小。</p><p><code>Hoeffding&#39;s inequality</code>可以保证偏差很大发生的几率很小，并且随着<code>N</code>的增大很减小。公式如下，<code>v</code>代表<code>sample</code>中黄色弹珠的比例，<code>μ</code>表示罐子中黄色弹珠的比例。<code>ϵ</code>也就是偏差。</p><blockquote><p>ℙ[|ν−μ|&gt;ϵ]≤2exp(−2(ϵ^2)N)</p></blockquote><h2 id="坏事的发生"><a href="#坏事的发生" class="headerlink" title="坏事的发生"></a>坏事的发生</h2><p>现在我们称<code>v</code>为<code>Ein</code>,<code>μ</code>为<code>Eout</code>，现在我们已经证明了<code>Ein</code>和<code>Eout</code>不会差的太远，更重要的事情是保重<code>Ein</code>越小越好，这就需要一个好的算法。<br>还记得上面的学习流程吗，我们的算法是从很多个<code>h</code>中去挑选一个<code>Ein</code>最小的<code>h</code>让它成为<code>g</code>。但是这里会有坏事情发生。<br>所谓的坏事情就是<code>bad sample</code>，就是说我们抽出了十个全是绿的弹珠。现在有一个好的<code>h</code>称之为<code>h1</code>，和坏的<code>h</code>叫<code>h2</code>，<code>h1</code>对于这个<code>bad sample</code>的表现当然是糟糕的，而恰好<code>h2</code>表现很好，那<code>h2</code>就被选成<code>g</code>了。</p><p>当出现坏事的时候，我们学习就会困难，可以直接说不能学习。所以这个坏事出现的概率是多少呢？把所有h中发生坏事的几率加起来。</p><p><img src="http://7xrsib.com1.z0.glb.clouddn.com/Screenshot.png" alt=""></p><p>从上图的式子中可以看到，坏事发生的几率和<code>M</code>有关。<code>M</code>也就是<code>h</code>的个数。<br>从现在的条件来看，如果<code>M</code>很大甚至无线的话那么<code>Learning</code>是不可行的。</p><h4 id="无效的Hypothesis"><a href="#无效的Hypothesis" class="headerlink" title="无效的Hypothesis"></a>无效的Hypothesis</h4><p>真实的情况是<code>M</code>一般不会很大，请再仔细看看上一张图的推导，<code>M</code>是通过把所有的<code>h</code>坏事发生的概率加起来的，但是其实这些<code>h</code>不是互相独立的。所以这些<code>h</code>是有重复的，如下图。</p><p><img src="http://beader.me/mlnotebook/section2/images/hypothesis_overlap.png" alt=""></p><p>比如说，我们想学习的<code>target function</code>是一条把<code>x1</code>分类成正负的线。现在<code>h</code>就有无数个，因为任意一条线都能分类，但是实际有意义的只有两种，分成正的和负的。<br>如果是两个点的话，实际有效的<code>h</code>就有4种，但是3个点就有可能不到8种了，因为会出现三点共线的情况。4个点的话按理说有16种，但是同样有一种情况不会发生，请看下图。</p><p><img src="http://7xrsib.com1.z0.glb.clouddn.com/Screenshot1.png" alt=""></p><p>所以现在我们的公式就变成了这样，大大减小<code>M</code>的个数</p><p><img src="http://7xrsib.com1.z0.glb.clouddn.com/Screenshot22.png" alt=""></p><h2 id="成长函数的上限"><a href="#成长函数的上限" class="headerlink" title="成长函数的上限"></a>成长函数的上限</h2><p>现在我们给上面<code>effective(N)</code>一个称呼，叫做成长函数。也就是说，对于某一个输入<code>D</code>，<code>H</code>最多能够产生的多少种方程。注意是种类的数量。<br>这个所谓的种类我们也给一个定义叫做<code>dichotomy</code>,用来表示<code>H</code>对与<code>D</code>的二元分类情况。<br>好，现在问题的关键，就是<code>H</code>到底能把<code>D</code>分成多少个<code>dichotomy</code>。也就是它的成长函数到底是多少？<br>但是我们很难确定它的成长函数。但是好在我们拥有一个叫做<code>break point</code>的东西，这就是成长函数的上限。我们再看回上面分类的例子。</p><ol><li>一个点能分成两种</li><li>两个点分成四种</li><li>三个点分成六种或者八种</li><li>四个点只有14种(<code>break point</code>)</li></ol><p>这里的输入为三个点就是一个<code>break point</code>。也就是说当输入N个点，<code>H</code>不能够把这个<code>N</code>个点的排列组合全部表示出来时<code>(2^N)</code>，<code>N</code>就是一个<code>break point</code>。<br>当<code>H</code>能把<code>N</code>的全部组合表示出来时，说明这<code>N</code>个点被<code>H</code>给<code>shatter</code>掉了</p><p>我们用<code>B(N,k)</code>来表示当输入<code>N</code>个点时，<code>H</code>可以最多产生多少个<code>dichotomy</code>。<br>通过数学归纳法我们可以证明到</p><p><img src="http://7xrsib.com1.z0.glb.clouddn.com/ssss.png" alt=""></p><h2 id="VC-BOUND"><a href="#VC-BOUND" class="headerlink" title="VC BOUND"></a>VC BOUND</h2><p>现在到了最后一步，除了把上边那个成长函数的上限代入进去之外，还需要进行一系列的变形，这些变形需要很强的数学能力和概率上面的知识，我自己都不太懂，况且我觉得大部分人都不需要了解。这里我就略过，有兴趣的强人自己<code>google</code>咯。<br>最终的式子如下</p><p><img src="http://7xrsib.com1.z0.glb.clouddn.com/okkkkkkk.png" alt=""></p><p>好了，现在我们终于能说机器学习确实可以学到东西了。但是需要满足三个条件。</p><ol><li>有一个好的<code>H</code>(拥有<code>break point</code>)</li><li>足够多的数据</li><li>好的算法，能够使<code>Ein</code>足够小</li></ol><p>这三者的关系如下图。</p><p><img src="http://7xrsib.com1.z0.glb.clouddn.com/vvvvvv.png" alt=""></p><p><code>dvc = k - 1</code>，大致上可以把它看出<code>theta</code>的维度加1</p><p>上图很清晰的说明，并不是说你的模型搞得很复杂，算法弄得很好，就能学好，反而是取到一个折中的点，这样的学习才最有效。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;开始跟《机器学习基石》这门课，相对于&lt;code&gt;Stanford&lt;/code&gt;那门课，这门明显难度大很多，我跟到第10个&lt;code&gt;Lecture&lt;/code&gt;，才刚刚讲到&lt;code&gt;Logistic Regression&lt;/code&gt;。前面费了很大力气在讲机器什么时候可以学习，以及证明为什么能学习。&lt;/p&gt;
&lt;p&gt;此文主要是基于《机器学习基石》的学习笔记。&lt;code&gt;Topic&lt;/code&gt;是为什么机器可以学习？&lt;/p&gt;
&lt;h2 id=&quot;机器学习流程&quot;&gt;&lt;a href=&quot;#机器学习流程&quot; class=&quot;headerlink&quot; title=&quot;机器学习流程&quot;&gt;&lt;/a&gt;机器学习流程&lt;/h2&gt;&lt;p&gt;下面是一个粗略的机器学习流程图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://beader.me/mlnotebook/section2/images/basic_setup_of_the%20_learning_problem.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;机器学习最开始也是最终的目的是获得一个&lt;code&gt;target function&lt;/code&gt;，喂进去数据能直接得到正确结论的函数。为了得到这个函数，我们需要一大堆的训练数据。然后通过一个好的机器学习算法，从一大堆&lt;code&gt;可能的function(也就是H)&lt;/code&gt;中挑选一个&lt;code&gt;比较好的function(也就是g)&lt;/code&gt;，这个&lt;code&gt;g&lt;/code&gt;和&lt;code&gt;target function&lt;/code&gt;长得越像越好。&lt;br&gt;
    
    </summary>
    
    
      <category term="Machine Learning" scheme="http://threezj.com/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat 架构探索</title>
    <link href="http://threezj.com/2016/06/25/Tomcat%20%E6%9E%B6%E6%9E%84%E6%8E%A2%E7%B4%A2/"/>
    <id>http://threezj.com/2016/06/25/Tomcat 架构探索/</id>
    <published>2016-06-24T17:13:06.000Z</published>
    <updated>2018-04-17T15:38:50.504Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>花了一个礼拜的时间阅读了 <code>how tomcat works</code>，本文基于此书，整理了一下<code>Tomcat 5</code>的基本架构，其实也没什么多复杂的东西，无非是解析<code>Http</code>请求，然后调用相应的<code>Servlet</code>。另推荐看<code>CSAPP</code>的网络编程那一章</p><h2 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h2><p><code>Tomcat</code>由两个模块协同合作</p><ul><li><code>connector</code></li><li><code>container</code></li></ul><p><code>connector</code> 负责解析处理<code>HTTP</code>请求，比如说<code>请求头</code>,<code>查询字符串</code>,<code>请求参数</code>之类的。生成<code>HttpRequest</code>和<code>HttpResponse</code><br>之后交给<code>container</code>，由它负责调用相应的<code>Servlet</code>。<br><a id="more"></a></p><h2 id="Connector"><a href="#Connector" class="headerlink" title="Connector"></a>Connector</h2><p><code>Tomcat</code>默认的<code>Connector</code>为<code>HttpConnector</code>。作为<code>Connector</code>必须要实现<code>Connector</code>这个接口。</p><p><code>Tomcat</code>启动以后会开启一个线程，做一个死循环，通过<code>ServerSocket</code>来等待请求。一旦得到请求，生成<code>Socket</code>，注意这里<code>HttpConnector</code>并不会自己处理<code>Socket</code>，而是把它交给<code>HttpProcessor</code>。详细看下面代码，这里我只保留了关键代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Loop until we receive a shutdown command</span></span><br><span class="line">        <span class="keyword">while</span> (!stopped) &#123;</span><br><span class="line">            Socket socket = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket = serverSocket.accept(); <span class="comment">//等待链接</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (AccessControlException ace) &#123;</span><br><span class="line">                log(<span class="string">"socket accept security exception"</span>, ace);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Hand this socket off to an appropriate processor</span></span><br><span class="line">            HttpProcessor processor = createProcessor();</span><br><span class="line">            processor.assign(socket);  <span class="comment">//这里是立刻返回的</span></span><br><span class="line">            <span class="comment">// The processor will recycle itself when it finishes</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>注意一点，上面的<code>processor.assign(socket);</code>是立刻返回的，并不会阻塞在那里等待。因为Tomcat不可能一次只能处理一个请求，所以是异步的，每个<code>processor</code>处理都是一个单独的线程。</p><h4 id="HttpProcessor"><a href="#HttpProcessor" class="headerlink" title="HttpProcessor"></a>HttpProcessor</h4><p>上面的代码并没有显示调用<code>HttpProcessor</code>的<code>process</code>方法，那这个方法是怎么调用的呢？我们来看一下<code>HttpProcessor</code>的<code>run</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Process requests until we receive a shutdown signal</span></span><br><span class="line">        <span class="keyword">while</span> (!stopped) &#123;</span><br><span class="line">            <span class="comment">// Wait for the next socket to be assigned</span></span><br><span class="line">            Socket socket = await(); </span><br><span class="line">            <span class="keyword">if</span> (socket == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// Process the request from this socket</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                process(socket);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                log(<span class="string">"process.invoke"</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Finish up this request</span></span><br><span class="line">            connector.recycle(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们发现他是调用<code>await</code>方法来阻塞等待获得<code>socket</code>方法。而之前<code>Connector</code>是调用<code>assign</code>分配的，这是什么原因？<br>下面仔细看<code>await</code>和<code>assign</code>方法。这两个方法协同合作，当<code>assign</code>获取<code>socket</code>时会通知<code>await</code>然后返回<code>socket</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">assign</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Wait for the Processor to get the previous Socket</span></span><br><span class="line">    <span class="keyword">while</span> (available) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Store the newly available Socket and notify our thread</span></span><br><span class="line">    <span class="keyword">this</span>.socket = socket;</span><br><span class="line">    available = <span class="keyword">true</span>;</span><br><span class="line">    notifyAll();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> Socket <span class="title">await</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Wait for the Connector to provide a new Socket</span></span><br><span class="line">    <span class="keyword">while</span> (!available) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Notify the Connector that we have received this Socket</span></span><br><span class="line">    Socket socket = <span class="keyword">this</span>.socket;</span><br><span class="line">    available = <span class="keyword">false</span>;</span><br><span class="line">    notifyAll();</span><br><span class="line">    <span class="keyword">return</span> (socket);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>默认<code>available</code>为<code>false</code>。</p><p>接下来就是剩下的事情就是解析请求，填充<code>HttpRequest</code>和<code>HttpResponse</code>对象，然后交给<code>container</code>负责。<br>这里我不过多赘述如何解析<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//parse</span></span><br><span class="line">    ....</span><br><span class="line">    connector.getContainer().invoke(request, response);</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h2><blockquote><p>A Container is an object that can execute requests received from a client, and return responses based on those requests </p></blockquote><p><code>Container</code>是一个接口，实现了这个接口的类的实例，可以处理接收的请求，调用对应的<code>Servlet</code>。</p><p>总共有四类<code>Container</code>，这四个<code>Container</code>之间并不是平行关系，而是父子关系</p><ul><li><code>Engine</code> - 最顶层的容器，可以包含多个<code>Host</code></li><li><code>Host</code> - 代表一个虚拟主机，可以包含多个<code>Context</code></li><li><code>Context</code> - 代表一个<code>web应用</code>，也就是<code>ServletContext</code>，可以包含多个<code>Wrappers</code></li><li><code>Wrapper</code> - 代表一个<code>Servlet</code>,不能包含别的容器了，这是最底层</li></ul><h4 id="Container的调用"><a href="#Container的调用" class="headerlink" title="Container的调用"></a>Container的调用</h4><p>容器好比是一个加工厂，加工接受的<code>request</code>，加工方式和流水线也很像，但又有点区别。这里会用到一个叫做<code>Pipeline</code>的 东西，中文翻译为<code>管道</code>，<code>request</code>就放在管道里顺序加工，进行加工的工具叫做<code>Valve</code>，好比手术刀，<code>Pipeline</code>可添加多个<code>Valve</code>,最后加工的工具称为<code>BaseValve</code></p><p>上面可能讲的比较抽象，接下来我们来看代码。<code>Engine</code>是顶层容器，所以上面<code>invoke</code>，执行的就是<code>Engine</code>的方法。<code>StandardEngine</code>是<code>Engine</code>的默认实现，注意它也同时实现了<code>Pipeline</code>接口，且包含了<code>Pipeline</code>。</p><p>它的构造方法同时指定了<code>baseValve</code>,也就是管道最后一个调用的<code>Valve</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StandardEngine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    pipeline.setBasic(<span class="keyword">new</span> StandardEngineValve());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>好，接着我们看<code>invoke</code>,这个方法是继承自<code>ContainerBase</code>。只有一行，之间交给<code>pipeline</code>，进行加工。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Request request, Response response)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        pipeline.invoke(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面是<code>StandardPipeline</code>的<code>invoke</code>实现，也就是默认的<code>pipeline</code>实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Request request, Response response)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        <span class="comment">// Invoke the first Valve in this pipeline for this request</span></span><br><span class="line">        (<span class="keyword">new</span> StandardPipelineValveContext()).invokeNext(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>也只有一行！调用<code>StandardPipelineValveContext</code>的<code>invokeNext</code>方法，这是一个<code>pipeline</code>的内部类。让我们来看<br>具体代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invokeNext</span><span class="params">(Request request, Response response)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> subscript = stage;</span><br><span class="line">            stage = stage + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// Invoke the requested Valve for the current request thread</span></span><br><span class="line">            <span class="keyword">if</span> (subscript &lt; valves.length) &#123;</span><br><span class="line">                valves[subscript].invoke(request, response, <span class="keyword">this</span>);  <span class="comment">//加工</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((subscript == valves.length) &amp;&amp; (basic != <span class="keyword">null</span>)) &#123;</span><br><span class="line">                basic.invoke(request, response, <span class="keyword">this</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ServletException</span><br><span class="line">                    (sm.getString(<span class="string">"standardPipeline.noValve"</span>));</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>它调用了<code>pipeline</code>所用的<code>Valve</code>来对<code>request</code>做加工，当Valve执行完，会调用<code>BaseValve</code>,也就是上面的<code>StandardEngineValve</code>，<br>我们再来看看它的<code>invoke</code>方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Select the Host to be used for this Request</span></span><br><span class="line">StandardEngine engine = (StandardEngine) getContainer();</span><br><span class="line">Host host = (Host) engine.map(request, <span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">if</span> (host == <span class="keyword">null</span>) &#123;</span><br><span class="line">    ((HttpServletResponse) response.getResponse()).sendError</span><br><span class="line">        (HttpServletResponse.SC_BAD_REQUEST,</span><br><span class="line">            sm.getString(<span class="string">"standardEngine.noHost"</span>,</span><br><span class="line">                        request.getRequest().getServerName()));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Ask this Host to process this request</span></span><br><span class="line">host.invoke(request, response);</span><br></pre></td></tr></table></figure></p><p>它通过<code>(Host) engine.map(request, true);</code>获取所对应的<code>Host</code>,然后进入到下一层容器中继续执行。后面的执行顺序<br>和<code>Engine</code>相同，我不过多赘述</p><h4 id="执行顺序小结"><a href="#执行顺序小结" class="headerlink" title="执行顺序小结"></a>执行顺序小结</h4><p>经过一长串的<code>invoke</code>终于讲完了第一层容器的执行顺序。估计你们看的有点晕，我这里小结一下。</p><blockquote><p>Connector -&gt; HttpProcessor.process() -&gt; StandardEngine.invoke() -&gt; StandardPipeline.invoke() -&gt;<br>StandardPipelineValveContext.invokeNext() -&gt; valves.invoke() -&gt; StandardEngineValve.invoke() -&gt;<br>StandardHost.invoke()</p></blockquote><p>到这里位置<code>Engine</code>这一层结束。接下来进行<code>Host</code>，步骤完全一致</p><blockquote><p>StandardHost.invoke() -&gt; StandardPipeline.invoke() -&gt;<br>StandardPipelineValveContext.invokeNext() -&gt; valves.invoke() -&gt; StandardHostValve.invoke() -&gt;<br>StandardContext.invoke()</p></blockquote><p>然后再进行<code>Context</code>这一层的处理，到最后选择对应的<code>Wrapping</code>执行。</p><h2 id="Wrapper"><a href="#Wrapper" class="headerlink" title="Wrapper"></a>Wrapper</h2><p><code>Wrapper</code>相当于一个<code>Servlet</code>实例，<code>StandardContext</code>会更根据的<code>request</code>来选择对应的<code>Wrapper</code>调用。我们直接来看看<br><code>Wrapper</code>的<code>basevalve</code>是如果调用<code>Servlet</code>的<code>service</code>方法的。下面是<code>StandardWrapperValve</code>的<code>invoke</code>方法，我省略了很多，<br>只看关键。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Request request, Response response,</span></span></span><br><span class="line"><span class="function"><span class="params">                       ValveContext valveContext)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        <span class="comment">// Allocate a servlet instance to process this request</span></span><br><span class="line">        <span class="keyword">if</span> (!unavailable) &#123;</span><br><span class="line">            servlet = wrapper.allocate();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Create the filter chain for this request</span></span><br><span class="line">        ApplicationFilterChain filterChain =</span><br><span class="line">            createFilterChain(request, servlet);</span><br><span class="line">        <span class="comment">// Call the filter chain for this request</span></span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> This also calls the servlet's service() method</span></span><br><span class="line">        String jspFile = wrapper.getJspFile();  <span class="comment">//是否是jsp</span></span><br><span class="line">        <span class="keyword">if</span> (jspFile != <span class="keyword">null</span>)</span><br><span class="line">            sreq.setAttribute(Globals.JSP_FILE_ATTR, jspFile);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            sreq.removeAttribute(Globals.JSP_FILE_ATTR);</span><br><span class="line">        <span class="keyword">if</span> ((servlet != <span class="keyword">null</span>) &amp;&amp; (filterChain != <span class="keyword">null</span>)) &#123;</span><br><span class="line">            filterChain.doFilter(sreq, sres);</span><br><span class="line">        &#125;</span><br><span class="line">        sreq.removeAttribute(Globals.JSP_FILE_ATTR);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>首先调用<code>wrapper.allocate()</code>,这个方法很关键，它会通过<code>反射</code>找到对应<code>servlet</code>的<code>class</code>文件，构造出实例返回给我们。然后创建一个<code>FilterChain</code>，熟悉<code>j2ee</code>的各位应该对这个不陌生把？这就是我们在开发<code>web app</code>时使用的<code>filter</code>。然后就执行<code>doFilter</code>方法了，它又会调用<code>internalDoFilter</code>，我们来看这个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">internalDoFilter</span><span class="params">(ServletRequest request, ServletResponse response)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        <span class="comment">// Call the next filter if there is one</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.iterator.hasNext()) &#123;</span><br><span class="line">            ApplicationFilterConfig filterConfig =</span><br><span class="line">              (ApplicationFilterConfig) iterator.next();</span><br><span class="line">            Filter filter = <span class="keyword">null</span>;</span><br><span class="line">            </span><br><span class="line">            filter = filterConfig.getFilter();</span><br><span class="line">            filter.doFilter(request, response, <span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// We fell off the end of the chain -- call the servlet instance</span></span><br><span class="line">        <span class="keyword">if</span> ((request <span class="keyword">instanceof</span> HttpServletRequest) &amp;&amp;</span><br><span class="line">            (response <span class="keyword">instanceof</span> HttpServletResponse)) &#123;</span><br><span class="line">            servlet.service((HttpServletRequest) request,</span><br><span class="line">                            (HttpServletResponse) response);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            servlet.service(request, response);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>终于，在这个方法里看到了<code>service</code>方法，现在你知道在使用<code>filter</code>的时候如果不执行<code>doFilter</code>，<code>service</code>就不会执行的原因了把。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>Tomcat</code>的重要过程应该都在这里了，还值得一提的是<code>LifeCycle</code>接口，这里所有类几乎都实现了<code>LifeCycle</code>，<code>Tomcat</code>通过它来统一管理容器的生命流程，大量运用观察者模式。有兴趣的同学可以自己看书</p><h2 id="Referance"><a href="#Referance" class="headerlink" title="Referance"></a>Referance</h2><p><code>How Tomcat works</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;花了一个礼拜的时间阅读了 &lt;code&gt;how tomcat works&lt;/code&gt;，本文基于此书，整理了一下&lt;code&gt;Tomcat 5&lt;/code&gt;的基本架构，其实也没什么多复杂的东西，无非是解析&lt;code&gt;Http&lt;/code&gt;请求，然后调用相应的&lt;code&gt;Servlet&lt;/code&gt;。另推荐看&lt;code&gt;CSAPP&lt;/code&gt;的网络编程那一章&lt;/p&gt;
&lt;h2 id=&quot;基本架构&quot;&gt;&lt;a href=&quot;#基本架构&quot; class=&quot;headerlink&quot; title=&quot;基本架构&quot;&gt;&lt;/a&gt;基本架构&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Tomcat&lt;/code&gt;由两个模块协同合作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;connector&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;container&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;connector&lt;/code&gt; 负责解析处理&lt;code&gt;HTTP&lt;/code&gt;请求，比如说&lt;code&gt;请求头&lt;/code&gt;,&lt;code&gt;查询字符串&lt;/code&gt;,&lt;code&gt;请求参数&lt;/code&gt;之类的。生成&lt;code&gt;HttpRequest&lt;/code&gt;和&lt;code&gt;HttpResponse&lt;/code&gt;&lt;br&gt;之后交给&lt;code&gt;container&lt;/code&gt;，由它负责调用相应的&lt;code&gt;Servlet&lt;/code&gt;。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://threezj.com/tags/Java/"/>
    
      <category term="Tomcat" scheme="http://threezj.com/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP Cache 详细解析</title>
    <link href="http://threezj.com/2016/05/04/CSAPP%20Cache%20%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/"/>
    <id>http://threezj.com/2016/05/04/CSAPP Cache 详细解析/</id>
    <published>2016-05-03T16:13:06.000Z</published>
    <updated>2018-04-17T15:44:24.455Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>又要来推荐<code>CSAPP</code>这本书啦。很多同学可能写了这么久代码，计算机的基本工作方式都不太懂，看这本书会给你一种融会贯通的感觉，小到二进制位级操作，大到手撸web服务器。</p><p>今天主要整理下<code>Cache</code>的运行机制。</p><h2 id="什么是Cache"><a href="#什么是Cache" class="headerlink" title="什么是Cache"></a>什么是<code>Cache</code></h2><p>编程说到底其实就是对数据的操作。<code>CPU</code>通过各种总线从读取数据，放入<code>ALU(运算器)</code>进行运算，然后再把数据放回主存中。下面是一个简单的示意图。</p><p><img src="http://7xrsib.com1.z0.glb.clouddn.com/QQ%E6%88%AA%E5%9C%9620160503224541.jpg" alt=""></p><p>很明显。数据运输过程的时间，就是性能的提现。没有数据<code>CPU</code>只能在那里等待.所以为了加快主存到<code>CPU</code>的速度，系统设计者采取了存储设备分层的结构.</p><p><code>Cache</code>又称为<code>高速缓存存储器</code>，是一种非常小非常快的存储器，同时也非常贵，放在<code>CPU</code>和<code>主存</code>之间，相当于中介的存在，每当<code>CPU</code>取数据的时候总是先从<code>Cache</code>中找，如果<code>Cache</code>没有，再到<code>主存</code>找。</p><p><code>CPU</code>和<code>主存</code>直接会放置多个<code>Cache</code>，越靠近<code>CPU</code>则越小越快越贵。</p><p><img src="http://7xrsib.com1.z0.glb.clouddn.com/QQ%E6%88%AA%E5%9C%9620160503230817.jpg" alt=""><br><a id="more"></a></p><h2 id="局部性"><a href="#局部性" class="headerlink" title="局部性"></a>局部性</h2><p>程序一般使用数据，都倾向于使用地址靠近的数据，或者是最近刚刚使用过的数据。回想下你之前写的程序是不是这样。比如说数组，一整块连续的地址循环访问。不断访问同一个数据去做求和之类的操作。所以分为如下</p><ul><li>时间局部性</li><li>空间局部性</li></ul><h2 id="Cache工作原理"><a href="#Cache工作原理" class="headerlink" title="Cache工作原理"></a>Cache工作原理</h2><p>查找<code>Cache</code>中数据时，找到了称为<code>Hit</code>,没找到则称为<code>Miss</code></p><h4 id="Cache-Miss-Type"><a href="#Cache-Miss-Type" class="headerlink" title="Cache Miss Type"></a>Cache Miss Type</h4><p><code>Miss</code>的情况分为三种</p><ul><li><code>Cold Miss</code>.也就是第一次找的时候，<code>Cache</code>不含数据，当然是<code>Miss</code></li><li><code>Conflict Miss</code>.比较有意思的一种的情况。比如说第一次查找数据<code>0</code>，第一次时不含数据属于<code>Cold Miss</code>，然后就去主存中找，放到<code>Cache</code>中，第二次查找需要数据<code>8</code>，又没有，继续去主存那里找，注意！，<code>8</code>把放到<code>Cache</code>中时覆盖了<code>0</code>，第三次你又需要<code>0</code>了，然后就悲剧了，不断<code>0,8,0,8,0,8,0,8 Miss</code>,当然这里涉及到一个写策略。</li><li><code>Capacity Miss</code>.这种也比较容易理解，就是你需要的数据超过<code>Cache</code>的大小了，当然<code>Miss</code>了</li></ul><h4 id="Cache-Replacement-Policies-Cache替换策略"><a href="#Cache-Replacement-Policies-Cache替换策略" class="headerlink" title="Cache Replacement Policies(Cache替换策略)"></a>Cache Replacement Policies(Cache替换策略)</h4><ul><li><code>Random</code>  随机替换</li><li><code>LRU</code>     <code>Least Recently Used</code>，替换最近最少使用的数据</li><li><code>FIFO</code>    这个应该很熟悉先进先出法。先保存的数据先出去</li></ul><h4 id="Cache-查找原理"><a href="#Cache-查找原理" class="headerlink" title="Cache 查找原理"></a>Cache 查找原理</h4><p>了解查找之前先要知道<code>Cache</code>的组成结构，总共分为两块。</p><ul><li><code>set</code></li><li><code>line</code></li></ul><p>一块Cache，有多个<code>set</code>，一个<code>set</code>有多行<code>line</code>.</p><p><code>set</code>个数取决于你是几位的机器，因为查找数据的时候是根据地址来区分是哪个<code>set</code>的。</p><p><code>line</code>中又分成三块。</p><ul><li><code>valid bit</code>  标志位，标志这块数据是否有效</li><li><code>tag</code>        相当于身份证，只有部分地址和这个<code>tag</code>对上以后，才能继续访问<code>block</code></li><li><code>block</code>      数据真正存放的地方</li></ul><p>那么地址又是如何划分的呢？也是分成三块</p><ul><li><code>tag</code>            对应前面’line’的’tag’</li><li><code>set index</code>      用来查找属于哪个’set’</li><li><code>block offset</code>   块偏移量确定数据的位置</li></ul><p>我这么讲可能比较抽象，直接看下图，再对照着看上面的文字，应该比较容易理解。</p><p><img src="http://7xrsib.com1.z0.glb.clouddn.com/QQ%E6%88%AA%E5%9C%9620160503235056.jpg" alt=""></p><p>所以<code>Cache</code>的查找过程是怎么样的呢？</p><ol><li>根据<code>set index</code>找到属于哪个<code>set</code></li><li>查找<code>set</code>中的每一行<code>line</code></li><li>先看<code>valid bit</code>是否有效</li><li>接着比对<code>tag</code></li><li>根据<code>block offset</code>获取数据</li></ol><h2 id="回写策略"><a href="#回写策略" class="headerlink" title="回写策略"></a>回写策略</h2><p>回写指的是，保持数据一致性，需要写回到主存中，这也很好理解，不回写的话数据就不同步了。</p><ul><li><code>Write-through</code> 直接把数据写回到主存中</li><li><code>Write-back</code>    等知道数据在<code>Cache</code>中要被覆盖了再写回到主存中</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>CSAPP<br>CMU 15213<br>维基百科</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;又要来推荐&lt;code&gt;CSAPP&lt;/code&gt;这本书啦。很多同学可能写了这么久代码，计算机的基本工作方式都不太懂，看这本书会给你一种融会贯通的感觉，小到二进制位级操作，大到手撸web服务器。&lt;/p&gt;
&lt;p&gt;今天主要整理下&lt;code&gt;Cache&lt;/code&gt;的运行机制。&lt;/p&gt;
&lt;h2 id=&quot;什么是Cache&quot;&gt;&lt;a href=&quot;#什么是Cache&quot; class=&quot;headerlink&quot; title=&quot;什么是Cache&quot;&gt;&lt;/a&gt;什么是&lt;code&gt;Cache&lt;/code&gt;&lt;/h2&gt;&lt;p&gt;编程说到底其实就是对数据的操作。&lt;code&gt;CPU&lt;/code&gt;通过各种总线从读取数据，放入&lt;code&gt;ALU(运算器)&lt;/code&gt;进行运算，然后再把数据放回主存中。下面是一个简单的示意图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrsib.com1.z0.glb.clouddn.com/QQ%E6%88%AA%E5%9C%9620160503224541.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;很明显。数据运输过程的时间，就是性能的提现。没有数据&lt;code&gt;CPU&lt;/code&gt;只能在那里等待.所以为了加快主存到&lt;code&gt;CPU&lt;/code&gt;的速度，系统设计者采取了存储设备分层的结构.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Cache&lt;/code&gt;又称为&lt;code&gt;高速缓存存储器&lt;/code&gt;，是一种非常小非常快的存储器，同时也非常贵，放在&lt;code&gt;CPU&lt;/code&gt;和&lt;code&gt;主存&lt;/code&gt;之间，相当于中介的存在，每当&lt;code&gt;CPU&lt;/code&gt;取数据的时候总是先从&lt;code&gt;Cache&lt;/code&gt;中找，如果&lt;code&gt;Cache&lt;/code&gt;没有，再到&lt;code&gt;主存&lt;/code&gt;找。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CPU&lt;/code&gt;和&lt;code&gt;主存&lt;/code&gt;直接会放置多个&lt;code&gt;Cache&lt;/code&gt;，越靠近&lt;code&gt;CPU&lt;/code&gt;则越小越快越贵。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrsib.com1.z0.glb.clouddn.com/QQ%E6%88%AA%E5%9C%9620160503230817.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Operating system" scheme="http://threezj.com/tags/Operating-system/"/>
    
  </entry>
  
  <entry>
    <title>最短路径算法总结</title>
    <link href="http://threezj.com/2016/05/02/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://threezj.com/2016/05/02/最短路径算法总结/</id>
    <published>2016-05-02T07:13:06.000Z</published>
    <updated>2018-04-17T15:35:23.227Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>因为我在跟<code>Robert Sedgewick</code>的<code>Algorithms</code>，所以本文和前面几篇算法文章一样，都是基于这门课的梳理总结，并加以自己理解，这种学习方式其实效率还挺高的。</p><h2 id="最短路径算法"><a href="#最短路径算法" class="headerlink" title="最短路径算法"></a>最短路径算法</h2><p>最短路径问题有多种情况可以讨论</p><ul><li>给定起点的最短路径问题</li><li>给定终点的最短路径问题</li><li>给定起点和终点的最短路径，也就是求任意两点之间的最短路径问题</li></ul><p>本文只讨论<code>单源起点问题</code>，有如下三个算法可以解决这个问题。</p><ul><li><code>Dijkstra</code>            //适用于无负权重</li><li><code>Topological sort</code>    //适用于无环</li><li><code>Bellman-Ford</code>        //适用于无负环<a id="more"></a></li></ul><a id="more"></a><h2 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h2><blockquote><p>对于不含负权的有向图，这是目前已知的最快的单源最短路径算法</p></blockquote><p>比较有意思的是，这个算法可以说就是<code>prim</code>算法。只不过就是比较的依据从<code>相对于整棵树</code>变成了<code>源点</code></p><p>所以，原理依旧是贪心算法，保证每一步都是最短。这里需要用优先队列来保存边。</p><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol><li>初始化所有顶点到源点的路径为无限大</li><li>顶点插入优先队列</li><li>出队一个点</li><li>对所有与这个点相关联的边进行<code>放松</code>操作</li><li>重复3</li></ol><p>所谓的<code>放松</code>操作，就是一个比较的过程，若比原来的距离更短即进队。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>可以看到下面的代码基本上和<code>Prim</code>一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @author Robert Sedgewick @author Kevin Wayne</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DijkstraSP</span><span class="params">(EdgeWeightedDigraph G, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (DirectedEdge e : G.edges()) &#123;</span><br><span class="line">           <span class="keyword">if</span> (e.weight() &lt; <span class="number">0</span>)</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"edge "</span> + e + <span class="string">" has negative weight"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       distTo = <span class="keyword">new</span> <span class="keyword">double</span>[G.V()];</span><br><span class="line">       edgeTo = <span class="keyword">new</span> DirectedEdge[G.V()];</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.V(); v++)</span><br><span class="line">           distTo[v] = Double.POSITIVE_INFINITY;</span><br><span class="line">       distTo[s] = <span class="number">0.0</span>;</span><br><span class="line">       <span class="comment">// relax vertices in order of distance from s</span></span><br><span class="line">       pq = <span class="keyword">new</span> IndexMinPQ&lt;Double&gt;(G.V());</span><br><span class="line">       pq.insert(s, distTo[s]);</span><br><span class="line">       <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">           <span class="keyword">int</span> v = pq.delMin();</span><br><span class="line">           <span class="keyword">for</span> (DirectedEdge e : G.adj(v))</span><br><span class="line">               relax(e);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// relax edge e and update pq if changed</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">relax</span><span class="params">(DirectedEdge e)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> v = e.from(), w = e.to();</span><br><span class="line">       <span class="keyword">if</span> (distTo[w] &gt; distTo[v] + e.weight()) &#123;</span><br><span class="line">           distTo[w] = distTo[v] + e.weight();</span><br><span class="line">           edgeTo[w] = e;</span><br><span class="line">           <span class="keyword">if</span> (pq.contains(w)) pq.decreaseKey(w, distTo[w]);</span><br><span class="line">           <span class="keyword">else</span>                pq.insert(w, distTo[w]);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="关于Dijkstra为什么不能含有负权值"><a href="#关于Dijkstra为什么不能含有负权值" class="headerlink" title="关于Dijkstra为什么不能含有负权值"></a>关于<code>Dijkstra</code>为什么不能含有负权值</h4><p>可以想象一下，如果有一条负边在图中。<code>Dijkstra</code>维护的优先队列，每次都是取一条最小的边出来的，而这条负边，可以使这条路无限小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">relax</span><span class="params">(DirectedEdge e)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> v = e.from(), w = e.to();</span><br><span class="line">       <span class="keyword">if</span> (distTo[w] &gt; distTo[v] + e.weight()) &#123;   <span class="comment">//若是负边的话每次都会减小，就会不断进入优先队列！！！</span></span><br><span class="line">           distTo[w] = distTo[v] + e.weight();  </span><br><span class="line">           edgeTo[w] = e;</span><br><span class="line">           <span class="keyword">if</span> (pq.contains(w)) pq.decreaseKey(w, distTo[w]);</span><br><span class="line">           <span class="keyword">else</span>                pq.insert(w, distTo[w]);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h4><p><code>Dijkstra</code>效率取决于优先队列的效率。二叉堆的话效率为<code>O(ElogV)</code></p><h2 id="Topological-sort"><a href="#Topological-sort" class="headerlink" title="Topological sort"></a>Topological sort</h2><p>这种方法实现简单，效率也高，但只适用于无环图，权值可以为负。</p><h4 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h4><ol><li>初始化所有顶点到源点的路径为无限大</li><li>对顶点进行<code>拓扑排序</code></li><li>按照顶点顺序，对每条相关的边进行<code>放松</code></li></ol><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Topological topological = <span class="keyword">new</span> Topological(G);</span><br><span class="line"><span class="keyword">if</span> (!topological.hasOrder())</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Digraph is not acyclic."</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> v : topological.order()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (DirectedEdge e : G.adj(v))</span><br><span class="line">        relax(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="效率-1"><a href="#效率-1" class="headerlink" title="效率"></a>效率</h4><blockquote><p>Topological sort algorithm computes SPT in any edgeweighted<br>DAG in time proportional to E + V</p></blockquote><h2 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman-Ford"></a>Bellman-Ford</h2><p>对于无负环的图一种解决方案。最直接的实现是对所有边进行<code>V-1</code>次放松,但是效率太低。复杂度高达<code>O(V*E)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.V(); i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.V(); v++)</span><br><span class="line">        <span class="keyword">for</span> (DirectedEdge e : G.adj(v))</span><br><span class="line">            relax(e);</span><br></pre></td></tr></table></figure><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>原始的版本总共进行<code>V-1</code>次放松，但其实，后面的很多次都是无效的放松，实际中不到<code>V-1</code>次就已经放松完全了。判断依据就是<code>distTo[v]</code>有无变化。</p><p>这种方法时间复杂度最坏情况依旧是<code>O(V*E)</code>，平均情况已经快很多了<code>O(E+V)</code></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>算法4th</p><p>维基百科</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;因为我在跟&lt;code&gt;Robert Sedgewick&lt;/code&gt;的&lt;code&gt;Algorithms&lt;/code&gt;，所以本文和前面几篇算法文章一样，都是基于这门课的梳理总结，并加以自己理解，这种学习方式其实效率还挺高的。&lt;/p&gt;
&lt;h2 id=&quot;最短路径算法&quot;&gt;&lt;a href=&quot;#最短路径算法&quot; class=&quot;headerlink&quot; title=&quot;最短路径算法&quot;&gt;&lt;/a&gt;最短路径算法&lt;/h2&gt;&lt;p&gt;最短路径问题有多种情况可以讨论&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;给定起点的最短路径问题&lt;/li&gt;
&lt;li&gt;给定终点的最短路径问题&lt;/li&gt;
&lt;li&gt;给定起点和终点的最短路径，也就是求任意两点之间的最短路径问题&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文只讨论&lt;code&gt;单源起点问题&lt;/code&gt;，有如下三个算法可以解决这个问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Dijkstra&lt;/code&gt;            //适用于无负权重&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Topological sort&lt;/code&gt;    //适用于无环&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Bellman-Ford&lt;/code&gt;        //适用于无负环&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://threezj.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>最小生成树,Prim和Kruskal详细学习笔记</title>
    <link href="http://threezj.com/2016/04/24/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91,Prim%E5%92%8CKruskal%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://threezj.com/2016/04/24/最小生成树,Prim和Kruskal详细学习笔记/</id>
    <published>2016-04-24T07:13:06.000Z</published>
    <updated>2018-04-17T15:35:46.342Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>最小生成树是一副连通加权无向图中一棵权值最小的生成树。<br>最小生成树其实是<strong>最小权重生成树</strong>的简称。</p></blockquote><p>可能翻译为<code>最小权重生成树</code>更容易理解一些。意思就是说在图中的每条边都加上权值，所谓权值是一种抽象的含义。可以指代一切可以量化的东西。比如说修路的费用，路程等等。然后在图中找到这样一棵树，边的权值加起来最小。并且既然是棵树，必须满足的要求是无环.</p><p>一般用两种贪心算法来找到最小生成树，分别是<code>prim</code>和<code>Kruskal</code><br><a id="more"></a></p><h2 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h2><p><code>Kruskal</code> 算法，我觉得比较容易理解，实现也比较简单。</p><ol><li>新建图G</li><li>把图G中所有的边按照权值从小到大排序。(一般使用优先队列)</li><li>取出最小的边</li><li>如果这条边连接的两个节点于图G中不在同一个连通分量中，则添加这条边到图G中.(使用并查集)</li><li>重复3，直至图G中所有的节点都在同一个连通分量中</li></ol><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KruskalMST</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Edge&gt; mst = <span class="keyword">new</span> Queue&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> weight;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KruskalMST</span><span class="params">(EdgeWeightedGraph g)</span></span>&#123;</span><br><span class="line">        MinPQ&lt;Edge&gt; minPQ = <span class="keyword">new</span> MinPQ&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Edge edge:g.edges())&#123;</span><br><span class="line">            minPQ.insert(edge);</span><br><span class="line">        &#125;</span><br><span class="line">        UF uf =<span class="keyword">new</span> UF(minPQ.size());</span><br><span class="line">        <span class="keyword">while</span> (!minPQ.isEmpty())&#123;</span><br><span class="line">            Edge edge = minPQ.delMin();</span><br><span class="line">            <span class="keyword">int</span> v = edge.either();</span><br><span class="line">            <span class="keyword">int</span> w = edge.other(v);</span><br><span class="line">            <span class="keyword">if</span>(!uf.connected(v,w))&#123;</span><br><span class="line">                uf.union(v,w);</span><br><span class="line">                mst.enqueue(edge);</span><br><span class="line">                <span class="comment">//weight+=edge.weight();</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h4><p><code>Kruskal</code> 算法 基本上取决于优先队列的选择，以及并查集的实现。</p><p>比较优的算法效率为<code>O(ElogE)</code>E为图中的边数.</p><p>对优先队列和并查集不了解的同学可以看看我这两篇文章，<a href="http://threezj.com/2016/03/20/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E4%B9%8B%E9%A1%BA%E5%BA%8F%E3%80%81%E4%BA%8C%E5%88%86%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91/">查找算法之顺序、二分、二叉搜索树、红黑树</a> 和 <a href="http://threezj.com/2016/03/12/Union-Find%20/">并查集</a></p><h2 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h2><p><code>Prim</code>算法，简单的说就是<code>从一个点开始不断让树长大的过程,并且保持权值最小</code>。</p><ol><li>生成图G</li><li>从s点开始</li><li>把与s点相连的边都加入<code>edgeTo[]</code>,并且保存到这些点的距离<code>distTo[]</code>,且插入到优先队列</li><li>出队一个点</li><li>查找与这个点相连的点，若权值比<code>distTo[]</code>中保存的值小则进更新，同时更新<code>distTo[]</code>和优先队列.</li><li>重复4</li></ol><p>如下图</p><p><img src="http://7xrsib.com1.z0.glb.clouddn.com/QQ%E6%88%AA%E5%9C%9620160424222602.jpg" alt=""></p><h4 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Edge[] edgeTo;        <span class="comment">// edgeTo[v] = shortest edge from tree vertex to non-tree vertex</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span>[] distTo;      <span class="comment">// distTo[v] = weight of shortest such edge</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;     <span class="comment">// marked[v] = true if v on tree, false otherwise</span></span><br><span class="line"><span class="keyword">private</span> IndexMinPQ&lt;Double&gt; pq;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PrimMST</span><span class="params">(EdgeWeightedGraph G)</span></span>&#123;</span><br><span class="line">    edgeTo = <span class="keyword">new</span> Edge[G.V()];</span><br><span class="line">    distTo = <span class="keyword">new</span> <span class="keyword">double</span>[G.V()];</span><br><span class="line">    marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line">    pq = <span class="keyword">new</span> IndexMinPQ&lt;Double&gt;(G.V());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.V(); v++)</span><br><span class="line">        distTo[v] = Double.POSITIVE_INFINITY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.V(); v++)      <span class="comment">// run from each vertex to find</span></span><br><span class="line">        <span class="keyword">if</span> (!marked[v]) prim(G, v);      <span class="comment">// minimum spanning forest</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prim</span><span class="params">(EdgeWeightedGraph g, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    distTo[s]=<span class="number">0</span>;</span><br><span class="line">    pq.insert(s,distTo[s]);</span><br><span class="line">    <span class="keyword">while</span> (!pq.isEmpty())&#123;</span><br><span class="line">        grow(g,pq.delMin());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(EdgeWeightedGraph g, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    marked[v]=<span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (Edge e :g.adj(v))&#123;</span><br><span class="line">        <span class="keyword">int</span> w = e.other(v);</span><br><span class="line">        <span class="keyword">if</span>(marked[w])   <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(distTo[w]&gt;e.weight())&#123;</span><br><span class="line">            distTo[w]=e.weight();</span><br><span class="line">            edgeTo[w] = e;</span><br><span class="line">            <span class="keyword">if</span>(pq.contains(w))</span><br><span class="line">                pq.decreaseKey(w,distTo[w]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pq.insert(w,distTo[w]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h4><p>具体性能也是取决于优先队列的选择，一般来说可以达到<code>O(ElogV)</code></p><h2 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h2><blockquote><p>Kruskal can have better performance if the edges can be sorted in linear time, or are already sorted.</p><p>Prim’s better if the number of edges to vertices is high.</p></blockquote><p>引用自<code>stackoverflow</code></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><code>维基百科</code></p><p><code>算法4th</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;最小生成树是一副连通加权无向图中一棵权值最小的生成树。&lt;br&gt;最小生成树其实是&lt;strong&gt;最小权重生成树&lt;/strong&gt;的简称。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可能翻译为&lt;code&gt;最小权重生成树&lt;/code&gt;更容易理解一些。意思就是说在图中的每条边都加上权值，所谓权值是一种抽象的含义。可以指代一切可以量化的东西。比如说修路的费用，路程等等。然后在图中找到这样一棵树，边的权值加起来最小。并且既然是棵树，必须满足的要求是无环.&lt;/p&gt;
&lt;p&gt;一般用两种贪心算法来找到最小生成树，分别是&lt;code&gt;prim&lt;/code&gt;和&lt;code&gt;Kruskal&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://threezj.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>推荐一门CMU公开课</title>
    <link href="http://threezj.com/2016/04/15/%E6%8E%A8%E8%8D%90%E4%B8%80%E9%97%A8CMU%E5%85%AC%E5%BC%80%E8%AF%BE/"/>
    <id>http://threezj.com/2016/04/15/推荐一门CMU公开课/</id>
    <published>2016-04-15T07:13:06.000Z</published>
    <updated>2018-04-15T14:49:01.370Z</updated>
    
    <content type="html"><![CDATA[<h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><p>推荐一门非常有意思的公开课。<code>CMU 15213</code> 由大名鼎鼎的<code>CSAPP</code>的作者主讲。内容就是按照<code>CSAPP</code>这本书为主线进行讲解的，看不进书的同学，强烈建议直接看视频。</p><p>这门课最核心的内容是七个<code>lab</code>，非常非常有意思。比如第一个<code>datalab</code>，要求你只允许用<code>! ~ | &amp;amp; +</code>这些位级操作符来进行运算，很头脑风暴，可能有些人写了这么多年代码1个字节几个二进制位都不知道。</p><p>我刚刚做完第二个<code>boomlab</code>，通过利用<code>GDB</code>反汇编二进制文件，调试单步执行找到炸弹，要求你可以不会写汇编，但要能看懂汇编。</p><p><img src="http://7xrsib.com1.z0.glb.clouddn.com/QQ%E6%88%AA%E5%9C%9620160415204556.jpg" alt=""></p><p>最后有个实验貌似是自己实现一个malloc有兴趣的同学可以和我一起跟课。</p><ul><li><a href="http://www.cs.cmu.edu/~213/index.html" target="_blank" rel="noopener">CMU 15213</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;推荐&quot;&gt;&lt;a href=&quot;#推荐&quot; class=&quot;headerlink&quot; title=&quot;推荐&quot;&gt;&lt;/a&gt;推荐&lt;/h2&gt;&lt;p&gt;推荐一门非常有意思的公开课。&lt;code&gt;CMU 15213&lt;/code&gt; 由大名鼎鼎的&lt;code&gt;CSAPP&lt;/code&gt;的作者主讲。内容就
      
    
    </summary>
    
    
      <category term="杂" scheme="http://threezj.com/tags/%E6%9D%82/"/>
    
  </entry>
  
  <entry>
    <title>用拉链法和线性探测法解决哈希冲突</title>
    <link href="http://threezj.com/2016/03/28/%E7%94%A8%E6%8B%89%E9%93%BE%E6%B3%95%E5%92%8C%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B%E6%B3%95%E8%A7%A3%E5%86%B3%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81/"/>
    <id>http://threezj.com/2016/03/28/用拉链法和线性探测法解决哈希冲突/</id>
    <published>2016-03-28T07:13:06.000Z</published>
    <updated>2018-04-17T15:34:02.718Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面学习到的几种算法比如<code>红黑树</code>，<code>二叉搜索树</code>，查找插入<code>时间复杂度</code>最快也只能到<code>O(logn)</code>.现在介绍一种算法可以使查找插入<code>时间复杂度</code>达到常数级别。</p><h2 id="散列表-Hash-table"><a href="#散列表-Hash-table" class="headerlink" title="散列表(Hash table)"></a>散列表(Hash table)</h2><p>也称为<code>哈希表</code>。是字典的一种抽象。比如说你要查一个字，通过这个字的拼音首字母，找到这个字的页码，然后翻到那页找就行了。这种方法直接把查找<code>时间复杂度</code>降到了常数。但是要牺牲一定的计算索引的时间。计算索引的那个函数称为<code>哈希函数</code>(<code>散列函数`</code>)。如果两个不同的<code>key</code>算出了同一个索引，此时就要用到一定的方法来解决哈希冲突。<br><a id="more"></a></p><h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p><code>哈希函数</code>一般具有如下特点。</p><ul><li>相等的<code>key</code>产生相等的<code>哈希值</code></li><li>计算简单方便</li><li><code>哈希值</code>均匀分布。(若过度集中，则容易使效率降低到<code>o(n)</code>)</li></ul><p>构造<code>哈希函数</code>有多种方法，这里不详细讲解。</p><h2 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h2><p>若两个不相等的<code>key</code>产生了相等的<code>哈希值</code>，这时则需要采用<code>哈希冲突</code>。</p><h2 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h2><p><code>Java</code>标准库的<code>HashMap</code>基本上就是用<code>拉链法</code>实现的。<code>拉链法</code>的实现比较简单，将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p><p><img src="http://7xrsib.com1.z0.glb.clouddn.com/searchQQ%E6%88%AA%E5%9C%9620160328161219.jpg" alt=""></p><h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><ul><li>得到一个<code>key</code></li><li>计算<code>key</code>的<code>hashValue</code></li><li>根据<code>hashValue</code>值定位到<code>data[hashValue]</code>。(<code>data[hashValue]</code>是一条链表)</li><li>若<code>data[hashValue]</code>为空则直接插入</li><li>不然则添加到表头</li></ul><p>这里需要注意的是，<code>哈希函数</code>必须保证<code>哈希值</code>的<code>均匀分布</code>，若全部集中在一条链表中，则<code>时间复杂度</code>和顺序链表相同。</p><p>还有一点则是数组的大小，若你能估计数据的大小，则直接指定即可，否则就需要<code>动态扩充</code>数组。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeparateChainingHashST</span>&lt;<span class="title">Key</span>,<span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">//这里的M需要根据实际情况调整</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SeparateChainingHashST</span><span class="params">(<span class="keyword">int</span> M)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.M = M;</span><br><span class="line">            st = (SequentialSearchST&lt;Key, Value&gt;[]) <span class="keyword">new</span> SequentialSearchST[M];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">                st[i]=<span class="keyword">new</span> SequentialSearchST&lt;Key,Value&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (key.hashCode() &amp; <span class="number">0x7fffffff</span>) % M;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key k,Value v)</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> hashValue = hash(k);</span><br><span class="line">            st[hashValue].put(k,v);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key k)</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> hashValue = hash(k);</span><br><span class="line">            <span class="keyword">return</span> st[hashValue].get(k);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线性探测"><a href="#线性探测" class="headerlink" title="线性探测"></a>线性探测</h2><p><code>线性探测</code>直接使用数组来存储数据。可以想象成一个停车问题。若当前车位已经有车，则你就继续往前开，直到找到下一个为空的车位。</p><p><img src="http://7xrsib.com1.z0.glb.clouddn.com/searchQQ%E6%88%AA%E5%9C%9620160328162810.jpg" alt=""></p><h4 id="实现步骤-1"><a href="#实现步骤-1" class="headerlink" title="实现步骤"></a>实现步骤</h4><ul><li>得到<code>key</code></li><li>计算得<code>hashValue</code></li><li>若不冲突，则直接填入数组</li><li>若冲突，则使<code>hashValue++</code>，也就是往后找，直到找到第一个<code>data[hashValue]</code>为空的情况,则填入。若到了尾部可循环到前面。</li></ul><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinearProbingHashST</span>&lt;<span class="title">Key</span>,<span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinearProbingHashST</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">        keys = (Key[]) <span class="keyword">new</span> Object[cap];</span><br><span class="line">        values = (Value[]) <span class="keyword">new</span> Object[cap];</span><br><span class="line">        M = cap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (key.hashCode() &amp; <span class="number">0x7fffffff</span>) % M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key,Value value)</span></span>&#123;</span><br><span class="line">        <span class="comment">//若当前数据含量超过了总容量的一半，则重新调整容量</span></span><br><span class="line">        <span class="keyword">if</span>(N&gt;=M/<span class="number">2</span>) resize(<span class="number">2</span>*M);  </span><br><span class="line">        <span class="keyword">int</span> hashValue = hash(key);</span><br><span class="line">        <span class="keyword">if</span> (values[hashValue]==<span class="keyword">null</span>)&#123;</span><br><span class="line">            keys[hashValue] = key;</span><br><span class="line">            values[hashValue] = value;</span><br><span class="line">            N++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(keys[hashValue].equals(key))&#123;</span><br><span class="line">            values[hashValue]=value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (values[hashValue] != <span class="keyword">null</span>)&#123;</span><br><span class="line">                hashValue = (hashValue+<span class="number">1</span>)%M;</span><br><span class="line">            &#125;</span><br><span class="line">            keys[hashValue] = key;</span><br><span class="line">            values[hashValue] = value;</span><br><span class="line">            N++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hashValue = hash(key);</span><br><span class="line">        <span class="keyword">if</span> (keys[hashValue]!=<span class="keyword">null</span>&amp;&amp;!keys[hashValue].equals(key))&#123;</span><br><span class="line">            <span class="keyword">while</span> (keys[hashValue]!=<span class="keyword">null</span> &amp;&amp;keys[hashValue]!=key)&#123;</span><br><span class="line">                hashValue = (hashValue+<span class="number">1</span>)%M;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> values[hashValue];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h2><p>一般来说，使用<code>散列表</code>会比<code>红黑树</code>快很多。但具体还是要看<code>哈希函数</code>的计算效率。但是<code>散列表</code>无法保证顺序，所以如果你需要进行有关顺序的操作，应该使用<code>红黑树</code>或者<code>二叉搜索树</code>。</p><p>对于<code>线性探测</code>来说动态调整数组大小是必要的，不然会产生死循环。</p><p><code>拉链法</code>的删除操作比较方便，直接链表修改地址即可。而<code>线性探测</code>删除操作很复杂，而且<code>线性探测</code>耗费的内存比拉链法要多。</p><p>分别对四个文件进行插入搜索操作。</p><ul><li><code>tale.txt</code>(779kb)<br>顺序查找(7.143秒) 二分查找(0.46秒) <code>二叉搜索树</code>(0.191秒) <code>红黑树</code>(0.237秒) <code>拉链法</code>(0.124秒) <code>线性探测</code>(0.103秒)</li><li><code>leipzig100k.txt</code>(12670kb)<br>顺序查找(无) 二分查找(13.911秒) <code>二叉搜索树</code>(1.389秒) <code>红黑树</code>(1.442秒)<br><code>拉链法</code>(0.707秒) <code>线性探测</code>(0.562秒)</li><li><code>leipzig300k.txt</code>(37966kb)<br>顺序查找(无) 二分查找(60.222秒) <code>二叉搜索树</code>(2.742秒) <code>红黑树</code>(3.104秒)<br><code>拉链法</code>(1.839秒) <code>线性探测</code>(1.559秒)</li><li><code>leipzig1m.txt</code>(126607kb)<br>顺序查找(无) 二分查找(无) <code>二叉搜索树</code>(3.016秒) <code>红黑树</code>(2.797秒)<br><code>拉链法</code>(3.938秒) <code>线性探测</code>(3.668秒)</li></ul><p><img src="http://7xrsib.com1.z0.glb.clouddn.com/searchQQ%E6%88%AA%E5%9C%9620160328190932.jpg" alt=""></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><code>维基百科</code></p><p><a href="http://www.amazon.cn/%E5%9B%BE%E7%81%B5%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%9B%E4%B9%A6-%E7%AE%97%E6%B3%95-%E5%A1%9E%E5%A5%87%E5%A8%81%E5%85%8B/dp/B009OCFQ0O/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1457882078&amp;sr=1-1&amp;keywords=%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">算法 4th</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前面学习到的几种算法比如&lt;code&gt;红黑树&lt;/code&gt;，&lt;code&gt;二叉搜索树&lt;/code&gt;，查找插入&lt;code&gt;时间复杂度&lt;/code&gt;最快也只能到&lt;code&gt;O(logn)&lt;/code&gt;.现在介绍一种算法可以使查找插入&lt;code&gt;时间复杂度&lt;/code&gt;达到常数级别。&lt;/p&gt;
&lt;h2 id=&quot;散列表-Hash-table&quot;&gt;&lt;a href=&quot;#散列表-Hash-table&quot; class=&quot;headerlink&quot; title=&quot;散列表(Hash table)&quot;&gt;&lt;/a&gt;散列表(Hash table)&lt;/h2&gt;&lt;p&gt;也称为&lt;code&gt;哈希表&lt;/code&gt;。是字典的一种抽象。比如说你要查一个字，通过这个字的拼音首字母，找到这个字的页码，然后翻到那页找就行了。这种方法直接把查找&lt;code&gt;时间复杂度&lt;/code&gt;降到了常数。但是要牺牲一定的计算索引的时间。计算索引的那个函数称为&lt;code&gt;哈希函数&lt;/code&gt;(&lt;code&gt;散列函数`&lt;/code&gt;)。如果两个不同的&lt;code&gt;key&lt;/code&gt;算出了同一个索引，此时就要用到一定的方法来解决哈希冲突。&lt;br&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://threezj.com/tags/Algorithm/"/>
    
  </entry>
  
</feed>
