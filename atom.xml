<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一派胡言</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://threezj.com/"/>
  <updated>2018-11-01T16:21:53.575Z</updated>
  <id>http://threezj.com/</id>
  
  <author>
    <name>Jian Zhang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>论文笔记 [SOSP &#39;17] PebblesDB, Building Key-Value Stores using Fragmented Log-Structured Merge Trees.</title>
    <link href="http://threezj.com/2018/11/02/pebblesdb/"/>
    <id>http://threezj.com/2018/11/02/pebblesdb/</id>
    <published>2018-11-01T16:21:06.000Z</published>
    <updated>2018-11-01T16:21:53.575Z</updated>
    
    <content type="html"><![CDATA[<p>PebblesDB为了减少写放大，同时又不影响读的效率，提出了一种类似于skiplist的方式来建立LSM-Tree，叫做Fragmented Log-Structured Merge Trees (FLSM)。与rocksdb相比，大概减少了2.4-3倍的写放大，以及6.7倍的write throughput。这篇的idea也比较好懂，用分区的方式来减少compaction，但又可以像skiplist那样来检索，读效率也很高。</p><h2 id="Problems"><a href="#Problems" class="headerlink" title="Problems"></a>Problems</h2><p>目前的LSM-Tree存在一个很大的写放大在于，它会对每一层的sstable写多次。在每一次compaction的时候，需要将上下两层有overlap的sstable读到内存，进行排序，然后再输出。但是这个操作是多次的，频繁的。当上一层又满了之后，又需要重复一遍上述操作，第二层overlap的sstable，又被写了一遍。</p><p><img src="https://zhang.nos-eastchina1.126.net/blog/WX20181101-233702%402x.png" alt=""><br><a id="more"></a><br>如上图中level1的sstable被重复写了3次。这就是写放大的问题所在。而LSM很巧妙的解决了这个问题</p><h2 id="Fragmented-Log-Structured-Merge-Trees"><a href="#Fragmented-Log-Structured-Merge-Trees" class="headerlink" title="Fragmented Log-Structured Merge Trees"></a>Fragmented Log-Structured Merge Trees</h2><p>这个名字也很直观。据作者说，本来这篇文章一开始投的是Eurosys，结果被拒了，后来重写了paper，才取了这个名字，写成所谓的数据结构创新，PebblesDB是基于FLSM，然后才被sosp接收了。</p><p>FLSM的思想就是将每一层的sstables划分逻辑上的区域(level0除外)，每个局域内sstable之间是可以重叠的。给这个区域取一个名字叫Guard。同时每个Guard有一个对应的key。假设有两个连续的Guard：G1:k1，G2:k2，那么G1内的sstable的key就在[k1, k2)这个范围内。</p><p>做了这样的划分之后，查找某个key，是先对整个level的Guards进行二分查找，找到某个Guard之后，再查这个Guard里的所有sstable（像level0那样）。是不是和skiplist很像？Guard的划分也是随机的，在插入的时候根据概率来确定是否需要开辟一个新的Guard。并且每一层的概率是不同的，上层稀疏，下层紧密。上一层已经有的Guard，在下一层也必须有。如下图。</p><p><img src="https://zhang.nos-eastchina1.126.net/blog/WX20181101-235755%402x.png" alt=""></p><p>那么FLSM是怎么解决写放大的呢？就在于compaction的时候，每一层的sstable的只需要写一次。上一层的sstable需要合并到下层的时候，只需要将上层的sstable做合并排序，然后根据下层Guard的key做划分，添加到不同的Guard中即可。当然这也有个例外，就是在最后一层的时候，因为没有更下层的Guard来添加，只能合并做重写。过程就如下图</p><p><img src="https://zhang.nos-eastchina1.126.net/blog/guard-compaction.png" alt=""></p><h2 id="EVALUATION"><a href="#EVALUATION" class="headerlink" title="EVALUATION"></a>EVALUATION</h2><p>按照上述的结构，FLSM大量减少了写放大。读的时候需要查找单个Guard内的多个sstable（bloom filter优化），因为PebblesDB增加了单个sstable的大小，效果也不差。但是FLSM也有局限性，即在做range query的时候，读放大会很严重（所有level，每个guard中所有sstable）。但是Guard的数量是可以调整的，调成1的时候就和传统的LSM实现一样了。</p><p>还有一种情况就是在顺序插入的时候，在这种workload下，所有sstable就没有overlap，之前的LSM实现，可以直接将上层的sstable移到下层不需要做IO。而PebblesDB还是要按照下层Guard的key做划分之后写入，增加了IO。下图为测试结果。</p><p><img src="https://zhang.nos-eastchina1.126.net/blog/WX20181102-000707%402x.png" alt=""></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] PebblesDB: Building Key-Value Stores using Fragmented Log-Structured Merge Trees. SOSP ‘17</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PebblesDB为了减少写放大，同时又不影响读的效率，提出了一种类似于skiplist的方式来建立LSM-Tree，叫做Fragmented Log-Structured Merge Trees (FLSM)。与rocksdb相比，大概减少了2.4-3倍的写放大，以及6.7倍的write throughput。这篇的idea也比较好懂，用分区的方式来减少compaction，但又可以像skiplist那样来检索，读效率也很高。&lt;/p&gt;
&lt;h2 id=&quot;Problems&quot;&gt;&lt;a href=&quot;#Problems&quot; class=&quot;headerlink&quot; title=&quot;Problems&quot;&gt;&lt;/a&gt;Problems&lt;/h2&gt;&lt;p&gt;目前的LSM-Tree存在一个很大的写放大在于，它会对每一层的sstable写多次。在每一次compaction的时候，需要将上下两层有overlap的sstable读到内存，进行排序，然后再输出。但是这个操作是多次的，频繁的。当上一层又满了之后，又需要重复一遍上述操作，第二层overlap的sstable，又被写了一遍。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://zhang.nos-eastchina1.126.net/blog/WX20181101-233702%402x.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="File System" scheme="http://threezj.com/tags/File-System/"/>
    
      <category term="paper reading" scheme="http://threezj.com/tags/paper-reading/"/>
    
  </entry>
  
  <entry>
    <title>论文笔记 [FAST &#39;16] WiscKey, Separating Keys from Values in SSD-conscious Storage</title>
    <link href="http://threezj.com/2018/10/27/wisckey/"/>
    <id>http://threezj.com/2018/10/27/wisckey/</id>
    <published>2018-10-27T15:29:06.000Z</published>
    <updated>2018-10-27T15:32:02.952Z</updated>
    
    <content type="html"><![CDATA[<p>LSM-Tree的优势在于借鉴LFS的思想，将大块的内存连续的写出到磁盘，减少磁盘seek的时间。同时输出的格式又是连续的，查找的速度也比较快。但是LSM-Tree的结构，也带来了写放大和读放大的问题。这些影响在hdd上是值得的，但是在ssd上并不友好。WiscKey提出了一种面向ssd的，将key和value分开存储的方法。</p><h2 id="Write-and-Read-Amplification"><a href="#Write-and-Read-Amplification" class="headerlink" title="Write and Read Amplification"></a>Write and Read Amplification</h2><p>写放大主要在于compaction的，每次两层之间做compact时，都需要将多个sstable读出做排序（读放大），再写到磁盘。而读放大方面，LSM-Tree需要查找多个数据结构，memtable-&gt;imutable-&gt;level files，假设不存在这个key的，便要把每一层做二分查找搜一遍。特别是第0层，有overlap，需要每个文件都看，虽然有bloom filter，但也影响效率。当value比较大的时候，问题就很明显了，compaction时sstable的读入和写出，都是将key和value一起读一起写的，当value变长时，效率会很低。这些放大的影响在hdd，来换取磁盘seek的消耗还是值得，但是在SSD上就不一样了，SSD随机读写要快的多，并且有并行随机读取的特性可以利用。</p><p><img src="https://zhang.nos-eastchina1.126.net/blog/WX20181027-212041%402x.png" alt=""><br><a id="more"></a></p><h2 id="WiscKey"><a href="#WiscKey" class="headerlink" title="WiscKey"></a>WiscKey</h2><p>key idea就是将key和value分开存储，LSM-Tree里只存key加一个value地址的偏移量，value放到另一个log文件中。之所以可以做是因为，compaction的时候，其实并不需要value的参与，需要排序的只有key而已。idea很简单，但是设计细节还是很复杂。有如下几个问题需要解决。</p><ol><li>因为key和value分开存储，原先read的时候key和value是一起读上的，现在多了一次seek。</li><li>value的log文件怎么样做垃圾回收？</li><li>key和value分开在两个地方写，怎么保证一致性。</li></ol><h4 id="Parallel-Range-Query"><a href="#Parallel-Range-Query" class="headerlink" title="Parallel Range Query"></a>Parallel Range Query</h4><p>WiscKey很好的利用了SSD的特性，当key和value分开存储读取和写入时，可以在后台开启多个线程并行读取value log，但是这里有个不足，是需要value足够大，根据实验数据当value大于4KB时，WiscKey的读性能才能展现出来。</p><h4 id="Garbage-Collection"><a href="#Garbage-Collection" class="headerlink" title="Garbage Collection"></a>Garbage Collection</h4><p>删除key的时候，只是在LSM-Tree删除，并不会涉及到value log，所以需要定期的清除无效的value。这里比较有趣的是，为了方便做垃圾回事和一致性，value log，存的不仅是value，还有key。如下图</p><p><img src="https://zhang.nos-eastchina1.126.net/blog/WX20181027-222137%402x.png" alt=""></p><p>垃圾回收的步骤如下</p><ol><li>从tail开始数据</li><li>检测key是否被删除，或者修改了。（查找LSM-Tree）</li><li>将依然有效的数据顺序添加到head</li><li>free 直接的space</li></ol><p>这个垃圾回收工作不需要实时做，可以离线，效率还是很高的。</p><h4 id="Crash-Consistency"><a href="#Crash-Consistency" class="headerlink" title="Crash Consistency"></a>Crash Consistency</h4><p>WiscKey无论是key丢失，还是value丢失都很好处理。</p><ol><li>若是key丢失了，value还在，就和key被删除的情况一样。</li><li>若是key在，value丢失。因为value log也存了key，只要比较一下key是否相同即可，反之则删除key。</li></ol><p>还有一步可以优化的则是，可以去掉原来的WAL， 因为value log里存了所有可以用来recovery的信息。</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>WiscKey这种key与value分离的设计有如下优点。</p><ul><li>减少写放大和读放大，compaction时只涉及到key，显著减少数据量</li><li>LSM-Tree的层高和sstable的数量会明显减少。树变小还可以更好的利用cache</li></ul><p>但也有不足</p><ul><li>对小value不友好</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] WiscKey: Separating Keys from Values in SSD-conscious Storage. FAST ‘16</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LSM-Tree的优势在于借鉴LFS的思想，将大块的内存连续的写出到磁盘，减少磁盘seek的时间。同时输出的格式又是连续的，查找的速度也比较快。但是LSM-Tree的结构，也带来了写放大和读放大的问题。这些影响在hdd上是值得的，但是在ssd上并不友好。WiscKey提出了一种面向ssd的，将key和value分开存储的方法。&lt;/p&gt;
&lt;h2 id=&quot;Write-and-Read-Amplification&quot;&gt;&lt;a href=&quot;#Write-and-Read-Amplification&quot; class=&quot;headerlink&quot; title=&quot;Write and Read Amplification&quot;&gt;&lt;/a&gt;Write and Read Amplification&lt;/h2&gt;&lt;p&gt;写放大主要在于compaction的，每次两层之间做compact时，都需要将多个sstable读出做排序（读放大），再写到磁盘。而读放大方面，LSM-Tree需要查找多个数据结构，memtable-&amp;gt;imutable-&amp;gt;level files，假设不存在这个key的，便要把每一层做二分查找搜一遍。特别是第0层，有overlap，需要每个文件都看，虽然有bloom filter，但也影响效率。当value比较大的时候，问题就很明显了，compaction时sstable的读入和写出，都是将key和value一起读一起写的，当value变长时，效率会很低。这些放大的影响在hdd，来换取磁盘seek的消耗还是值得，但是在SSD上就不一样了，SSD随机读写要快的多，并且有并行随机读取的特性可以利用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://zhang.nos-eastchina1.126.net/blog/WX20181027-212041%402x.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="File System" scheme="http://threezj.com/tags/File-System/"/>
    
      <category term="paper reading" scheme="http://threezj.com/tags/paper-reading/"/>
    
  </entry>
  
  <entry>
    <title>论文笔记 Time, Clocks and the Ordering of Events in a Distributed System</title>
    <link href="http://threezj.com/2018/10/14/clock/"/>
    <id>http://threezj.com/2018/10/14/clock/</id>
    <published>2018-10-14T15:14:06.000Z</published>
    <updated>2018-10-14T15:18:05.219Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在分布式系统中，如何确定两个事件发生的先后顺序是比较困难的。在不同机器上的物理时钟会有会有误差。Lamport在1978的文章<a href="http://research.microsoft.com/users/lamport/pubs/time-clocks.pdf" target="_blank" rel="noopener">Time, Clocks and the Ordering of Events in a Distributed System” (1978)</a>提出了一种Logical Clock 来描述分布式系统中的先后顺序。论文中先是定义了一种偏序的<code>happened before</code> 关系，通过这种关系给出了logical clock的算法，最后用logical clock实现了全序的分布式算法。</p><h2 id="Happened-before"><a href="#Happened-before" class="headerlink" title="Happened-before"></a>Happened-before</h2><p>Lamport提出用事件发生的先后因果关系来描述事件。若事件b依赖于a发生，则<code>a happened-before b</code>。定义如下。</p><ol><li>If a and b are events in the same process, and a comes before b, then a → b.</li><li>If a is the sending of a message by one process and b is the receipt of the same message by another process, then a → b.</li><li>if a→ b and b → c then a→c. </li></ol><p>若相互之间没有依赖关系，可认为是并行的。并发说明这两个事件谁先发生并不重要，这其实逻辑时钟的重要思想。Logical clock只保证你的系统不出错（即不违反相互依赖关系），而不能保证事件发生的真实顺序。<br><a id="more"></a></p><h2 id="Logical-Clock"><a href="#Logical-Clock" class="headerlink" title="Logical Clock"></a>Logical Clock</h2><p>Logical Clock就是给事件打上时间戳（一般实现为递增的序号）。如果a happended before b, 那么a的时间戳就要小于b。时间戳的逻辑遵循下面的规则。</p><ul><li>在同一个进程中，每发生一个事件则时间戳+1</li><li>不同进程中，进程A收到进程B的message, 其中包含B的时间戳为T， 则C(A) = max(T, C(A)) + 1</li></ul><p>若a-&gt;b, 则C(a) &lt; C(b), 但是反过来并不能成立。在并行的情况，时间戳的大小并不能反映事情发生的先后顺序，因为根本不重要。</p><h2 id="Total-Ordering"><a href="#Total-Ordering" class="headerlink" title="Total Ordering"></a>Total Ordering</h2><p>既然并行的情况，事件发生的顺序不重要。为了保证全局的顺序，就强制规定一种顺序，比如说机器编号，机器编号小的时间戳更小。由此，Lamport提出了基于Logical Clock的分布式算法。这个算法基于一个前提，message被一个进程发送给另一个进程，接收到的顺序是按照发出的顺序的。算法如下</p><p>首先，每个进程都维护一个request queue。</p><ol><li>假设进程A发送request message(RQ) 给其他进程，包含暑假戳T_rq在message里面。并且将RQ入队</li><li>当其他进程收到R时，进程将RQ入队，并发送ack给进程A（也要包含时间戳）</li><li>当进程A需要release资源的时候，进程A删除在队列里的RQ message，并发送release message(RL)给其它进程</li><li>当收到RL时，进程删除队列里所有来自进程A的RQ</li></ol><p>进程A只有满足以下条件才能获取资源：</p><ol><li>RQ是队里中的第一个request message，</li><li>进程A收到其它所有进程的message, 其中包含的时间戳&gt;T_rq。</li></ol><p>为什么这个算法可以work？通过上述两个条件，我们保证了所有进程都看到了RQ，并且按照前面的算法，RQ是按照Lamport Clock进行排序的。所有进程看到的都是同一个顺序。</p><p>这个算法也有一定的局限性，即需要所有进程参与，一旦某个进程挂掉了，整个system就不可用了。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] Time, Clocks and the Ordering of Events in a Distributed System</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在分布式系统中，如何确定两个事件发生的先后顺序是比较困难的。在不同机器上的物理时钟会有会有误差。Lamport在1978的文章&lt;a href=&quot;http://research.microsoft.com/users/lamport/pubs/time-clocks.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Time, Clocks and the Ordering of Events in a Distributed System” (1978)&lt;/a&gt;提出了一种Logical Clock 来描述分布式系统中的先后顺序。论文中先是定义了一种偏序的&lt;code&gt;happened before&lt;/code&gt; 关系，通过这种关系给出了logical clock的算法，最后用logical clock实现了全序的分布式算法。&lt;/p&gt;
&lt;h2 id=&quot;Happened-before&quot;&gt;&lt;a href=&quot;#Happened-before&quot; class=&quot;headerlink&quot; title=&quot;Happened-before&quot;&gt;&lt;/a&gt;Happened-before&lt;/h2&gt;&lt;p&gt;Lamport提出用事件发生的先后因果关系来描述事件。若事件b依赖于a发生，则&lt;code&gt;a happened-before b&lt;/code&gt;。定义如下。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;If a and b are events in the same process, and a comes before b, then a → b.&lt;/li&gt;
&lt;li&gt;If a is the sending of a message by one process and b is the receipt of the same message by another process, then a → b.&lt;/li&gt;
&lt;li&gt;if a→ b and b → c then a→c. &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;若相互之间没有依赖关系，可认为是并行的。并发说明这两个事件谁先发生并不重要，这其实逻辑时钟的重要思想。Logical clock只保证你的系统不出错（即不违反相互依赖关系），而不能保证事件发生的真实顺序。&lt;br&gt;
    
    </summary>
    
    
      <category term="paper reading" scheme="http://threezj.com/tags/paper-reading/"/>
    
      <category term="Distributed System" scheme="http://threezj.com/tags/Distributed-System/"/>
    
  </entry>
  
  <entry>
    <title>论文笔记 Paxos made simple</title>
    <link href="http://threezj.com/2018/09/26/paxos/"/>
    <id>http://threezj.com/2018/09/26/paxos/</id>
    <published>2018-09-26T05:36:06.000Z</published>
    <updated>2018-10-14T15:18:04.094Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Basic-Paxos"><a href="#Basic-Paxos" class="headerlink" title="Basic Paxos"></a>Basic Paxos</h2><blockquote><p>The Paxos algorithm, when presented in plain English, is very simple. </p></blockquote><p>Paxos有许多变种，一般来说都是指的Basic Paxos，也就是这篇论文里提出来的内容。下面没有特殊说明，都是指的Basic Paxos。</p><p>Paxos需要保证的是两个特性。</p><ol><li><p>safety</p><ul><li>Only a value that has been proposed may be chosen</li><li>Only a single value is chosen, and</li><li>A process never learns that a value has been chosen unless it actually has been.</li></ul></li><li><p>liveness</p><ul><li>Some proposed value is eventually chosen</li><li>If a value is chosen, servers eventually learn about it</li></ul></li></ol><p>Paxos和raft一样也划分了三种角色，但是和raft的不同的是一台机器可以同时扮演这三个角色。</p><ul><li><p>Proposer</p></li><li><p>Acceptor</p></li><li><p>Learner</p></li></ul><a id="more"></a><h4 id="Problems"><a href="#Problems" class="headerlink" title="Problems"></a>Problems</h4><ol><li><p>problem1: split votes</p><p>如果acceptor只接受它收到的一个value。那么在多个机器一起提出proposal时，会发生脑裂，导致没有value被选择。</p><p><img src="http://p7ok3gm01.bkt.clouddn.com/5.png" alt=""></p><p>解决办法：acceptor必须接受多个不同的value</p></li><li><p>problem2: conflict choise </p><p>如果acceptor接受每个它收到的value，会导致选择多个不同的value。</p><p><img src="http://p7ok3gm01.bkt.clouddn.com/6.png" alt=""></p><p>一旦某个value被选择之后，后续的proposal必选选择同个value。同时proposal应该带有unique number，acceptor应该拒绝旧的序号</p><p><img src="http://p7ok3gm01.bkt.clouddn.com/7.png" alt="">proposal返回的时候，若已有value被选择，应该将value返回，proposer需要选择最大的accept_num对于的value来发起accept请求</p><p>解决办法：2-phase protocal，并且通过num来拒绝旧的提案。</p></li><li><p>problem3: livelock</p><p><img src="http://p7ok3gm01.bkt.clouddn.com/4.png" alt="">解决办法： 在重新开始下一轮proposal时，随机设定时间，让其它proposers先完成选择。</p></li></ol><h4 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h4><ol><li>phase1<ul><li>proposer 选择一个proposal number，发送prepare rpc请求给所有acceptors（或者大部分），参数为num</li><li>acceptor在收到proposal req之后会根据num比较，拒绝所有num比已经回复promise小的proposal。同时需要返回已经accept的highest-numbered的value（如果有的话）</li></ul></li><li>phase2<ul><li>proposer收到大多数acceptors的promise之后，开始发送accept request给所有acceptors。参数为proposal   numer 和value。value是highest-numbered proposal among the responses，如果没有acceptors没有返回value的话，则可以任意选择，说明之前没有accept的提案。</li><li>acceptor收到accept request之后，和之前一样比较proposal num，只有比之前promise的num大才会接受</li></ul></li></ol><p>所以acceptor需要持久化 可以允许返回promise的最小proposal number，和accepted proposal number和对应的value。</p><p><img src="http://p7ok3gm01.bkt.clouddn.com/8.png" alt=""></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] Paxos made simple</p><p>[2] Implementing Replicated Logs with Paxos. John Ousterhout and Diego Ongaro</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Basic-Paxos&quot;&gt;&lt;a href=&quot;#Basic-Paxos&quot; class=&quot;headerlink&quot; title=&quot;Basic Paxos&quot;&gt;&lt;/a&gt;Basic Paxos&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;The Paxos algorithm, when presented in plain English, is very simple. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Paxos有许多变种，一般来说都是指的Basic Paxos，也就是这篇论文里提出来的内容。下面没有特殊说明，都是指的Basic Paxos。&lt;/p&gt;
&lt;p&gt;Paxos需要保证的是两个特性。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;safety&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Only a value that has been proposed may be chosen&lt;/li&gt;
&lt;li&gt;Only a single value is chosen, and&lt;/li&gt;
&lt;li&gt;A process never learns that a value has been chosen unless it actually has been.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;liveness&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Some proposed value is eventually chosen&lt;/li&gt;
&lt;li&gt;If a value is chosen, servers eventually learn about it&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Paxos和raft一样也划分了三种角色，但是和raft的不同的是一台机器可以同时扮演这三个角色。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Proposer&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Acceptor&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Learner&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="paper reading" scheme="http://threezj.com/tags/paper-reading/"/>
    
      <category term="Distributed System" scheme="http://threezj.com/tags/Distributed-System/"/>
    
  </entry>
  
  <entry>
    <title>NFS vs AFS</title>
    <link href="http://threezj.com/2018/08/20/NFS%20vs%20AFS/"/>
    <id>http://threezj.com/2018/08/20/NFS vs AFS/</id>
    <published>2018-08-20T13:46:06.000Z</published>
    <updated>2018-08-20T13:48:26.848Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>周末读了ostep的两篇文章<a href="http://pages.cs.wisc.edu/~remzi/OSTEP/dist-nfs.pdf" target="_blank" rel="noopener">Sun’s Network File System</a>和<a href="http://pages.cs.wisc.edu/~remzi/OSTEP/dist-afs.pdf" target="_blank" rel="noopener">The Andrew File System</a>，都是讲的分布式文件系统，但是侧重的方向不同，导致相关实现也全然不同，写篇笔记对比一下。</p><h2 id="NFS"><a href="#NFS" class="headerlink" title="NFS"></a>NFS</h2><p>NFS的goal是fast crash recovery and simple，所以它的设计都是为这个目的服务。</p><h4 id="key-design"><a href="#key-design" class="headerlink" title="key design"></a>key design</h4><ul><li><p>stateless  </p><p>server不保存任何有关client的状态。假如crash，不用做任何操作，直接重启即可。这是一个最重要的设计。需要的信息都通过rpc的参数传递过来。</p></li><li><p>idempotent</p><p>接口都做到幂等性，这样做主要是为了处理message lost 或者 server crash这些情况，client只需要retry即可。</p></li><li><p>client-cache</p><p>这主要为性能考虑，但同时为带来一致性问题。NFS通过前先通过getattr request发送给server，查看cache是否过期，一般是周期性的问一下，比如所3s。同时在close的时候将cache刷回server。</p><a id="more"></a></li></ul><h2 id="AFS"><a href="#AFS" class="headerlink" title="AFS"></a>AFS</h2><p>AFS却不同，它的goal为scale。也就是如何让server能支持更多的服务器。为了支持很多的client，要做的就是减少与client 与server的交互，也就减少了server的资源占用(cpu/network)。</p><h4 id="key-design-1"><a href="#key-design-1" class="headerlink" title="key design"></a>key design</h4><ul><li><p>whole-file caching</p><p>client发起fetch请求，拿到整个file后，会写到磁盘里。这很好的解决了cache一致性的问题。这里和NFS不同，NFS其他client是以block为单位获取的，所以不同client之间看到的是混合版错误的文件。AFS同样也是close的时候刷新，server只接收时间最近的修改。</p></li><li><p>callback</p><p>client不会定时请求server询问cache是否过期，而是会在server注册callback，若其他client修改了文件，server会通知client重新获取。这里带来server recovery时的复杂性，重启时server会通知所有client cache失效，重新获取。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;周末读了ostep的两篇文章&lt;a href=&quot;http://pages.cs.wisc.edu/~remzi/OSTEP/dist-nfs.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Sun’s Network File System&lt;/a&gt;和&lt;a href=&quot;http://pages.cs.wisc.edu/~remzi/OSTEP/dist-afs.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;The Andrew File System&lt;/a&gt;，都是讲的分布式文件系统，但是侧重的方向不同，导致相关实现也全然不同，写篇笔记对比一下。&lt;/p&gt;
&lt;h2 id=&quot;NFS&quot;&gt;&lt;a href=&quot;#NFS&quot; class=&quot;headerlink&quot; title=&quot;NFS&quot;&gt;&lt;/a&gt;NFS&lt;/h2&gt;&lt;p&gt;NFS的goal是fast crash recovery and simple，所以它的设计都是为这个目的服务。&lt;/p&gt;
&lt;h4 id=&quot;key-design&quot;&gt;&lt;a href=&quot;#key-design&quot; class=&quot;headerlink&quot; title=&quot;key design&quot;&gt;&lt;/a&gt;key design&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;stateless  &lt;/p&gt;
&lt;p&gt;server不保存任何有关client的状态。假如crash，不用做任何操作，直接重启即可。这是一个最重要的设计。需要的信息都通过rpc的参数传递过来。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;idempotent&lt;/p&gt;
&lt;p&gt;接口都做到幂等性，这样做主要是为了处理message lost 或者 server crash这些情况，client只需要retry即可。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;client-cache&lt;/p&gt;
&lt;p&gt;这主要为性能考虑，但同时为带来一致性问题。NFS通过前先通过getattr request发送给server，查看cache是否过期，一般是周期性的问一下，比如所3s。同时在close的时候将cache刷回server。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Distributed System" scheme="http://threezj.com/tags/Distributed-System/"/>
    
  </entry>
  
  <entry>
    <title>Database concurrency control note</title>
    <link href="http://threezj.com/2018/07/05/Database%20concurrency%20control%20note/"/>
    <id>http://threezj.com/2018/07/05/Database concurrency control note/</id>
    <published>2018-07-05T12:28:06.000Z</published>
    <updated>2018-07-05T12:28:39.040Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Locking-in-B-Tree"><a href="#Locking-in-B-Tree" class="headerlink" title="Locking in B+Tree"></a>Locking in B+Tree</h2><p>使用2PL在index上效果会很差，因为每次使用索引时都会lock root，导致其他事务无法访问。Index一般使用<code>Lock crabbing</code>。</p><h4 id="Basic-Lock-Crabbing"><a href="#Basic-Lock-Crabbing" class="headerlink" title="Basic Lock Crabbing"></a>Basic Lock Crabbing</h4><ol><li>search<ul><li>获取parent的S lock</li><li>接着到下一层获取child的S lock</li><li>释放上一层parent的S lock，如此循环。</li></ul></li><li>insert/delete<ul><li>获取parent的X lock</li><li>到下一层，获取child的X lock</li><li>如果安全的话则释放parent的X lock。安全即是指child没有分裂或者合并。也就是说有足够的空间插入，或者足够多的节点删除。不然继续到一层，如此循环。</li></ul></li></ol><p>在删除或者插入的情况下，如果节点都满或者都不够的话很有可能整条链上都有锁，一直到leaf节点才会逐级向上释放，并发性比较差，由此引入一种优化的方案。<br><a id="more"></a></p><h4 id="Optimistic-Lock-Coupling"><a href="#Optimistic-Lock-Coupling" class="headerlink" title="Optimistic Lock Coupling"></a>Optimistic Lock Coupling</h4><p>基本思想就是在插入或者删除的时候和查找一样获取S lock，直到叶子节点时，如果需要分裂或者合并再采用上面的算法重来一遍。也就是先假设合并或者分裂比较少见。若真发生了再上X锁。</p><h2 id="Timestamp-Ordering-Concurrency-Control"><a href="#Timestamp-Ordering-Concurrency-Control" class="headerlink" title="Timestamp Ordering Concurrency Control"></a>Timestamp Ordering Concurrency Control</h2><p>通过时间戳来确定事务的先后顺序而不是采用锁。</p><p>在事务启动前，分配时间戳。若TS(T1)&lt;TS(T2)则DBMS必须确保执行顺序与T1在T2之前的串行调度一样。</p><h4 id="BASIC-T-O"><a href="#BASIC-T-O" class="headerlink" title="BASIC T/O"></a>BASIC T/O</h4><ol><li>Read X<ul><li>如果TS(Ti) &lt; W-TS(X)，则违法了顺序，也就是Ti希望去读在Ti之后的事务写的数据了。这种情况下需要中上事务，或者重启</li><li>若相反，则可以读，并且需要更新R-TS(X) = max(R-TS(X), TS(Ti))。也就是将最大的读事务的timestamp记录下，当写的时候可以用来比较。</li></ul></li><li>Write X<ul><li>若果TS(Ti) &lt; R-TS(X) 或者 TS(Ti) &lt; W-TS(X)，与上面一样，也是违法了顺序。则终止或重启。</li><li>如相反，则允许写，并且更新W-TS(X) = Ti</li></ul></li></ol><p>这里有一种优化方法，也就是时TS(Ti) &lt; W-TS(X)，忽略写，让事务继续。因为反正Ti的write都会之后的事务覆盖。这种方法叫Thomas Write Rule</p><h2 id="Optimistic-Concurrency-Control-OCC"><a href="#Optimistic-Concurrency-Control-OCC" class="headerlink" title="Optimistic Concurrency Control (OCC)"></a>Optimistic Concurrency Control (OCC)</h2><p>与悲观锁相反，假设冲突发生的情况比较少，不加锁，直到冲突发生后，再重试。当每个事务运行的时候都会copy一份内容作为private workspace。事务的所有的操作都在private workspace中，只有等提交时才会写到真正的数据库中。具体的实施如下。</p><ul><li>Read phase：将需要写的那部分数据copy到private workspace</li><li>Validation phase： 当事务提交的事务，检查是否与其他事务冲突。</li><li>Write phase：若无冲突，则将修改的部分写入数据库。反之则终止或重启。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Locking-in-B-Tree&quot;&gt;&lt;a href=&quot;#Locking-in-B-Tree&quot; class=&quot;headerlink&quot; title=&quot;Locking in B+Tree&quot;&gt;&lt;/a&gt;Locking in B+Tree&lt;/h2&gt;&lt;p&gt;使用2PL在index上效果会很差，因为每次使用索引时都会lock root，导致其他事务无法访问。Index一般使用&lt;code&gt;Lock crabbing&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&quot;Basic-Lock-Crabbing&quot;&gt;&lt;a href=&quot;#Basic-Lock-Crabbing&quot; class=&quot;headerlink&quot; title=&quot;Basic Lock Crabbing&quot;&gt;&lt;/a&gt;Basic Lock Crabbing&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;search&lt;ul&gt;
&lt;li&gt;获取parent的S lock&lt;/li&gt;
&lt;li&gt;接着到下一层获取child的S lock&lt;/li&gt;
&lt;li&gt;释放上一层parent的S lock，如此循环。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;insert/delete&lt;ul&gt;
&lt;li&gt;获取parent的X lock&lt;/li&gt;
&lt;li&gt;到下一层，获取child的X lock&lt;/li&gt;
&lt;li&gt;如果安全的话则释放parent的X lock。安全即是指child没有分裂或者合并。也就是说有足够的空间插入，或者足够多的节点删除。不然继续到一层，如此循环。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在删除或者插入的情况下，如果节点都满或者都不够的话很有可能整条链上都有锁，一直到leaf节点才会逐级向上释放，并发性比较差，由此引入一种优化的方案。&lt;br&gt;
    
    </summary>
    
    
      <category term="Database" scheme="http://threezj.com/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>Database join algorithm note</title>
    <link href="http://threezj.com/2018/06/20/Database%20join%20algorithm%20note/"/>
    <id>http://threezj.com/2018/06/20/Database join algorithm note/</id>
    <published>2018-06-20T15:01:06.000Z</published>
    <updated>2018-10-20T16:31:00.407Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Join-algorithm"><a href="#Join-algorithm" class="headerlink" title="Join algorithm"></a>Join algorithm</h2><ul><li>Simple Nested Loop Join</li><li>Block Nested Loop Join</li><li>Index Nested Loop Join</li><li>Sort-Merge Join</li><li>Hash Join</li></ul><p>下面以这两张表为例</p><p><img src="http://zhang.nos-eastchina1.126.net/blog/WX20180620-212956.png" alt=""></p><h2 id="Simple-Nested-Loop-Join"><a href="#Simple-Nested-Loop-Join" class="headerlink" title="Simple Nested Loop Join"></a>Simple Nested Loop Join</h2><p>即简单的双重循环。对每一个外层table中的tuple都要scan一遍内层table</p><p><code>Cost: M + (m*N)</code><br><a id="more"></a></p><h2 id="Block-Nested-Loop-Join"><a href="#Block-Nested-Loop-Join" class="headerlink" title="Block Nested Loop Join"></a>Block Nested Loop Join</h2><p>对上面的算法做了简单的优化，从tuple扩大到block。也就是对每一个外层table的block都要scan一遍内层table。减少了一些io次数</p><p><code>Cost: M + (M·N)</code></p><p>若memory比较大，其实可以先一次性将B-2个block都读进来，剩下两个block，一个用来scan内层表，另一个用来join。这样又大幅减少io。</p><h2 id="Index-Nested-Loop-Join"><a href="#Index-Nested-Loop-Join" class="headerlink" title="Index Nested Loop Join"></a>Index Nested Loop Join</h2><p>同样是nested loop的优化，上面两个算法，在做内循环的时候都是通过顺序scan来查找match。如果有index的话，可以直接通过index来查找。</p><p><code>Cost: M + (m·C)</code> </p><p>C代表index查找的代价。</p><h2 id="Sort-Merge-Join"><a href="#Sort-Merge-Join" class="headerlink" title="Sort-Merge Join"></a>Sort-Merge Join</h2><p>这个算法核心思想和归并排序类似。分两步，先排序再合并。</p><ol><li>根据join的key对两个表排序（sort phase）</li><li>通过两个指针索引两张表，都只扫一遍，遇到相同的key则输出，算法类似归并排序的归并阶段（merge phase）</li></ol><p><code>Cost: M + N + (sort cost)</code></p><p>但是要是两张表有很多相同的key，重复的key在merge的时候会变成nested loop join。不过这种情况比较少。</p><p>这个算法比较时候有一张表或者两张都已经有序的情况。</p><h2 id="Hash-Join"><a href="#Hash-Join" class="headerlink" title="Hash Join"></a>Hash Join</h2><p>分为两种情况。</p><ul><li>basic hash join  整个table可以fit进memory</li><li>Grace Hash Join 内存不够，table不能fit进memory</li></ul><p>hash join 只能在等值join的情况下使用</p><h3 id="basic-hash-join"><a href="#basic-hash-join" class="headerlink" title="basic hash join"></a>basic hash join</h3><p>核心思想也较为简单，就是通过对两张表hash以后，比较相同值的tuple进行连接。</p><ol><li>先使用一个较小的表，扫描一遍，建立hash table （build phase）</li><li>扫描另一个表，使用相同的hash函数，定位到相同的bucket，进行match比较 （probe phase）</li></ol><p>注意若hash冲突过于严重，就又变成nested loop join了</p><h4 id="Grace-Hash-Join"><a href="#Grace-Hash-Join" class="headerlink" title="Grace Hash Join"></a>Grace Hash Join</h4><p>当memory不够大时，则需要将table分片，分到足够小能塞进内存，再在内存中使用basic hash join或者其他join算法。</p><ol><li>采用同一个hash函数，对两张表进行hash计算且分片输出 （build phase）</li><li>对于相应分片的内容，已经可以fit入内存，即可直接用上述的join算法进行输出 (probe phase)</li></ol><p>若单个分片还是不能塞入内存，可以递归的换一个hash函数继续分片。</p><p><code>Cost of hash join is 3(M + N)</code></p><ul><li>Partitioning phase 2(M + N)  读一遍，写一遍所以乘2</li><li>Probing Phase: M + N</li></ul><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p><img src="http://zhang.nos-eastchina1.126.net/blog/WX20180620-225634.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Join-algorithm&quot;&gt;&lt;a href=&quot;#Join-algorithm&quot; class=&quot;headerlink&quot; title=&quot;Join algorithm&quot;&gt;&lt;/a&gt;Join algorithm&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Simple Nested Loop Join&lt;/li&gt;
&lt;li&gt;Block Nested Loop Join&lt;/li&gt;
&lt;li&gt;Index Nested Loop Join&lt;/li&gt;
&lt;li&gt;Sort-Merge Join&lt;/li&gt;
&lt;li&gt;Hash Join&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面以这两张表为例&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhang.nos-eastchina1.126.net/blog/WX20180620-212956.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Simple-Nested-Loop-Join&quot;&gt;&lt;a href=&quot;#Simple-Nested-Loop-Join&quot; class=&quot;headerlink&quot; title=&quot;Simple Nested Loop Join&quot;&gt;&lt;/a&gt;Simple Nested Loop Join&lt;/h2&gt;&lt;p&gt;即简单的双重循环。对每一个外层table中的tuple都要scan一遍内层table&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Cost: M + (m*N)&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Database" scheme="http://threezj.com/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>Database Storage and Buffer pools note</title>
    <link href="http://threezj.com/2018/05/23/Database%20Storage%20and%20Buffer%20pools%20note/"/>
    <id>http://threezj.com/2018/05/23/Database Storage and Buffer pools note/</id>
    <published>2018-05-23T09:24:06.000Z</published>
    <updated>2018-10-20T16:31:12.777Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Goals-of-the-DBMS"><a href="#Goals-of-the-DBMS" class="headerlink" title="Goals of the DBMS"></a>Goals of the DBMS</h2><ul><li>Allow the DBMS to manage databases that exceed the amount of memory available</li><li>Reading/writing to disk is expensive, so it must be managed carefully</li></ul><p>DBMS总是希望自己来管理所有东西，而不是依靠操作系统</p><h2 id="File-Storage"><a href="#File-Storage" class="headerlink" title="File Storage"></a>File Storage</h2><ul><li>最简单的形式，一张表存储一个文件。但是也有多个关联的表存在一个文件的实现。</li><li>操作系统对于db的文件内容是不关心。</li></ul><p>每个file由多个page组成，有多种不同的方式来存储，</p><ul><li>Heap File</li><li>Sequential File</li><li>Hashing File</li><li>Log-Structured File <a id="more"></a></li></ul><h4 id="Heap-File"><a href="#Heap-File" class="headerlink" title="Heap File"></a>Heap File</h4><p>page在文件是无序的可以任意放，一般有两种方式组织</p><ul><li>Linker List：用两个链表，data list和free list。这种方式在获取某个page的时候用时较长，需要遍历链表。</li><li>Page Directory：用一个特殊的page，来存所有page的位置。一般采用这种。</li></ul><h4 id="Sequential-File"><a href="#Sequential-File" class="headerlink" title="Sequential File"></a>Sequential File</h4><p>所有Tuple是按照某个特定的键（比如主键）排序存放的。在根据特殊键操作表的时候性能会Heap形式要好</p><h4 id="Log-Structred"><a href="#Log-Structred" class="headerlink" title="Log-Structred"></a>Log-Structred</h4><p>不存储tuple，只存储log（即insert，delete，update操作）。当查找的时候，反向搜索，recreate一个tuple。插入快，读慢。一般会考虑额外建立索引来维护log，并定期压缩。</p><p><img src="http://zhang.nos-eastchina1.126.net/blog/WX20180524-164401.png" alt=""></p><h2 id="Database-Page"><a href="#Database-Page" class="headerlink" title="Database Page"></a>Database Page</h2><ul><li>单个文件分成多个page，每个page的大小是固定大小的</li></ul><p>page的存储格式是多样的。为了支持变长的<code>Tuple</code>，一般的存储格式为<code>slotted-page structure</code>如下图。</p><p><img src="http://zhang.nos-eastchina1.126.net/blog/WX20180524-162444.png" alt=""> </p><p>当中间的Tuple被删除的时候，前面的Tuple需要往后移来对齐。这个移动的性能消耗不是太高，因为一般page大小也就4k。若Tuple过大，超过一个page的大小，一般会考虑采用一个额外的overflow page来保存。</p><h2 id="Tuple-layout"><a href="#Tuple-layout" class="headerlink" title="Tuple layout"></a>Tuple layout</h2><p>tuple才是真实的一条记录，即一串二进制序列，由database负责解释。分为两块。</p><ul><li>header：metadata，每个属性的位置和长度，bitmap来快速发现null属性</li><li>data</li></ul><p><img src="http://zhang.nos-eastchina1.126.net/blog/WX20180524-165218@2x.png" alt=""></p><p>目前普遍是按行存的做法，某些情况不是很好，比如应用只需要一行的其中一个数据，但db会将整行都读入，浪费io带宽。也有一些按列存的数据库。比如单个page只存某个属性的数据。</p><h2 id="Different-type-of-the-DBMS-in-different-workloads"><a href="#Different-type-of-the-DBMS-in-different-workloads" class="headerlink" title="Different type of the DBMS in different workloads"></a>Different type of the DBMS in different workloads</h2><ul><li>OLTP: On-line transaction processing 适合简单增删改操作，事务短，操作快的类型</li><li>OLAP: On-line analyitical processing 适合复杂的分析操作，需要运行较长时间。</li></ul><h2 id="Buffer-pool"><a href="#Buffer-pool" class="headerlink" title="Buffer pool"></a>Buffer pool</h2><p>类似虚拟内存。让database可以管理超出内存大小的数据。也就在内存维护cache，以page为单位，来换入换出。</p><ul><li>脏页换出需要写入磁盘</li><li>pin counter：当有线程在使用这个页的时候，不能换出。</li></ul><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><ul><li>多个buffer pool，减少锁竞争</li><li>根据query plan，进行预读取。</li><li>cursor共享。两个不同query，但是可能读取的东西是相同，可以依附于同一个cursor来读，更好利用缓存。</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>cmu 15445</li><li>Database System Concepts 6th Edition</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Goals-of-the-DBMS&quot;&gt;&lt;a href=&quot;#Goals-of-the-DBMS&quot; class=&quot;headerlink&quot; title=&quot;Goals of the DBMS&quot;&gt;&lt;/a&gt;Goals of the DBMS&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Allow the DBMS to manage databases that exceed the amount of memory available&lt;/li&gt;
&lt;li&gt;Reading/writing to disk is expensive, so it must be managed carefully&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;DBMS总是希望自己来管理所有东西，而不是依靠操作系统&lt;/p&gt;
&lt;h2 id=&quot;File-Storage&quot;&gt;&lt;a href=&quot;#File-Storage&quot; class=&quot;headerlink&quot; title=&quot;File Storage&quot;&gt;&lt;/a&gt;File Storage&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;最简单的形式，一张表存储一个文件。但是也有多个关联的表存在一个文件的实现。&lt;/li&gt;
&lt;li&gt;操作系统对于db的文件内容是不关心。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每个file由多个page组成，有多种不同的方式来存储，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Heap File&lt;/li&gt;
&lt;li&gt;Sequential File&lt;/li&gt;
&lt;li&gt;Hashing File&lt;/li&gt;
&lt;li&gt;Log-Structured File
    
    </summary>
    
    
      <category term="Database" scheme="http://threezj.com/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>论文笔记 [SOSP &#39;91] The Design and Implementation of a Log-Structured File System</title>
    <link href="http://threezj.com/2018/04/28/LFS/"/>
    <id>http://threezj.com/2018/04/28/LFS/</id>
    <published>2018-04-28T12:36:06.000Z</published>
    <updated>2018-10-27T15:28:54.293Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这两天花了点时间读了下<code>The Design and Implementation of a Log-Structured File System</code>，92年的一篇经典文章。Idea其实很简单，就是利用大内存缓存足够多的内容后，然后一次性顺序的写到磁盘中。LFS的所有写入都是顺序添加。极大提升写效率。思想简单，但是实现比较tricky，有各种细节需要注意，却不复杂，很符合人类直觉。</p><h2 id="位置在变化的inode"><a href="#位置在变化的inode" class="headerlink" title="位置在变化的inode"></a>位置在变化的inode</h2><p>LFS比较关键的一个点，在于inode不是存在一个fix的位置，而是每次写入一个新的块的时候，都会生成新的inode。之所以这样做是因为，传统的文件系统将inode放在fix位置，当添加或者更新块的时候，需要seek到多个位置去查找inode，查找间接块等，物理运动极其耗时。而LFS这样做了之后，只需要顺序接下去写就行了，但如果是添加的话，还需要读取一次旧的inode块，来维护新的inode块。</p><p>但是寻找inode又是一个问题，传统文件中，反正inode数组位置是固定的，只需要位置加上filenumber偏移量就可以了。而在LFS中，存在一个叫imap的数组来索引到最新的inode。也就是说当每次写的时候，在最后总会加上一块imap，来索引最新的inode地址（旧的失效）。到最后整个磁盘中有很多分块的imap。</p><p>但是最后还是需要一块fix的位置来存磁盘中所有最新的imap的地址，即checkpoint region(CR)。比如说放在磁盘最开始的地方。CR肯定是需要磁盘seek过去更新，不过这个更新是周期性的，长时间的，比如30秒。而且所有最新imap，是足够小，可以存在内存的。所以只需要磁盘挂载的时候一次性seek到各个位置读入一次所有的imap即可（所有目的都是为了减少seek）。</p><p><img src="http://zhang.nos-eastchina1.126.net/blog/WX20180428-174248@2x.png" alt=""></p><p>大概情况如上图。当然还有目录的情况，目录其实也是个文件(保存file name: file number的映射)    ，所以处理其实是和普通文件一样的。<br><a id="more"></a></p><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>垃圾回收对LFS的性能影响最大的一方面。由于LFS是顺序写的，每次都会产生新的数据块，那么旧的数据块则需要处理掉。处理方式也很简单，比如说一大块连续的磁盘空间(segment)，简单的将一段segment中所有live的数据块，顺序的写出即可，那么原先的segment既可以复用了。这种方式可以尽可能保留大块的连续空间，而是很多的碎片。</p><p>判断数据块是否过期(live)，也是需要处理的问题。论文中提出两种方法，这边讲一种。两种方法都是要在segment中保留一块 <code>segment summary block</code>。<code>segment summary block</code>记录每一个block的file  number和版本号，同时会在imap里保存最新的版本号。每次判断的时候只需要判断版本号有没有过期即可。</p><p>文章中有这么一句话对垃圾回收的性能影响的概括。</p><blockquote><p> Overall, Sprite LFS permits about 65-75% of a disk’s raw bandwidth to be used for writing new data (the rest is used for cleaning). For comparison, Unix systems can only utilize 5-10% of a disk’s raw bandwidth for writing new data; the rest of the time is spent seeking.        </p></blockquote><h2 id="Crash-recovery"><a href="#Crash-recovery" class="headerlink" title="Crash recovery"></a>Crash recovery</h2><p>LFS的恢复也很方便，所有的imap地址都会周期性的更新到CR中，所以恢复的时候只要直接CR中读即可。这里有个问题是有可能在写入CR的时候断电，导致数据不一致。LFS采用了使用两块CR的方式，两块交替着，在写的时候，开头和结尾都会加上时间戳，若没有相匹配的时间戳，说明这块CR数据一致性有问题。则读取另一块。还有一个问题就是，CR更新时间有间隔，所以会损失几秒种的数据，论文中提到可以在log上向前继续扫描恢复数据，因为LFS是只顺序添加的。</p><h2 id="不足之处"><a href="#不足之处" class="headerlink" title="不足之处"></a>不足之处</h2><p>论文中也到了LFS的不足之处，就在随机写一个文件后，会生成很多新的块，相互之间不连续，当需要连续读的时候，将会导致更多的seek。</p><blockquote><p>Even for other workloads, such as those including reads and large-file accesses, Sprite LFS is at least as fast as Unix in all cases but one (files read sequentially after being written randomly).</p></blockquote><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] The Design and Implementation of a Log-Structured File System. SOSP ‘91</p><p>[2] Operating Systems: Three Easy Pieces. Chapter: Log-structured File Systems</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这两天花了点时间读了下&lt;code&gt;The Design and Implementation of a Log-Structured File System&lt;/code&gt;，92年的一篇经典文章。Idea其实很简单，就是利用大内存缓存足够多的内容后，然后一次性顺序的写到磁盘中。LFS的所有写入都是顺序添加。极大提升写效率。思想简单，但是实现比较tricky，有各种细节需要注意，却不复杂，很符合人类直觉。&lt;/p&gt;
&lt;h2 id=&quot;位置在变化的inode&quot;&gt;&lt;a href=&quot;#位置在变化的inode&quot; class=&quot;headerlink&quot; title=&quot;位置在变化的inode&quot;&gt;&lt;/a&gt;位置在变化的inode&lt;/h2&gt;&lt;p&gt;LFS比较关键的一个点，在于inode不是存在一个fix的位置，而是每次写入一个新的块的时候，都会生成新的inode。之所以这样做是因为，传统的文件系统将inode放在fix位置，当添加或者更新块的时候，需要seek到多个位置去查找inode，查找间接块等，物理运动极其耗时。而LFS这样做了之后，只需要顺序接下去写就行了，但如果是添加的话，还需要读取一次旧的inode块，来维护新的inode块。&lt;/p&gt;
&lt;p&gt;但是寻找inode又是一个问题，传统文件中，反正inode数组位置是固定的，只需要位置加上filenumber偏移量就可以了。而在LFS中，存在一个叫imap的数组来索引到最新的inode。也就是说当每次写的时候，在最后总会加上一块imap，来索引最新的inode地址（旧的失效）。到最后整个磁盘中有很多分块的imap。&lt;/p&gt;
&lt;p&gt;但是最后还是需要一块fix的位置来存磁盘中所有最新的imap的地址，即checkpoint region(CR)。比如说放在磁盘最开始的地方。CR肯定是需要磁盘seek过去更新，不过这个更新是周期性的，长时间的，比如30秒。而且所有最新imap，是足够小，可以存在内存的。所以只需要磁盘挂载的时候一次性seek到各个位置读入一次所有的imap即可（所有目的都是为了减少seek）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhang.nos-eastchina1.126.net/blog/WX20180428-174248@2x.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;大概情况如上图。当然还有目录的情况，目录其实也是个文件(保存file name: file number的映射)    ，所以处理其实是和普通文件一样的。&lt;br&gt;
    
    </summary>
    
    
      <category term="File System" scheme="http://threezj.com/tags/File-System/"/>
    
      <category term="paper reading" scheme="http://threezj.com/tags/paper-reading/"/>
    
  </entry>
  
  <entry>
    <title>Raft 共识算法</title>
    <link href="http://threezj.com/2017/06/11/Raft%20%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/"/>
    <id>http://threezj.com/2017/06/11/Raft 共识算法/</id>
    <published>2017-06-11T14:00:00.000Z</published>
    <updated>2018-10-20T16:32:41.719Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Raft"><a href="#Raft" class="headerlink" title="Raft"></a>Raft</h2><p>关于<code>mit 6.824</code>，这门课在找工作期间，又拾起来继续做了，断断续续的把<code>lab2</code>做完了，pass掉所有test。完整的实现了<code>Raft</code>算法，对分布式的了解也算是更进了一步。此文会对<code>Raft</code>做一个归纳总结，大部分的内容基于<a href="https://pdos.csail.mit.edu/6.824/papers/raft-extended.pdf" target="_blank" rel="noopener">raft 论文</a> 。</p><p><code>Raft</code>是一个共识算法，目的是为了保证多个副本在多个服务器的情况下数据的一致性，以及保证一定的容错能力。</p><p><code>Raft</code>的卖点是<code>understandable</code>，论文中一直在强调可理解（这个可理解对没接触过分布式的人来说，其实也不太好理解…）。这个可理解应该是相对于<code>paxos</code>来说的。基于<code>understandable</code>这个目标，<code>Raft</code>把整个共识的过程分成三块，分别是<code>leader election</code>， <code>log replication</code>和<code>safety</code>，下面我们会一一介绍。<br><a id="more"></a></p><h4 id="复制状态机（Replicated-state-machines）"><a href="#复制状态机（Replicated-state-machines）" class="headerlink" title="复制状态机（Replicated state machines）"></a>复制状态机（Replicated state machines）</h4><p>所谓的复制状态机其实并不是指某个服务器，而是一种用来容错的方法。比如说无论是<code>GFS</code>还是<code>HDFS</code>都需要有一个master服务器来保存<code>metadata</code>，那么就会存在这个<code>master</code>宕机的情况，一旦宕机，你的整个服务就不可用。解决方法就是通过复制多个副本到另外的服务器来备用，一旦<code>master</code>宕机，备用的服务器就可以立刻上线来充当<code>master</code>。但是这里存在一个问题，如何保证<code>master</code>和备用服务器的数据一致性？最直接的办法，就是在<code>master</code>上执行的命令，都在备用服务器都执行一遍。那么如何让备用服务器知道执行什么命令？通过<code>log</code>。当<code>master</code>接到客户端的命令之后，把这个命令写到<code>log</code>中，接着把<code>log</code>发给所有的备用服务器，等到大部分备用服务器接收到<code>log</code>，并反馈给<code>master</code>之后，<code>master</code>才提交这个命令（表示这个命令可以执行了）。但是这当中会有一些问题，比如备用服务器宕机，网络丢包等等。这其实就是<code>Raft</code>需要解决的核心问题，保证<code>master</code>和备用服务器的数据一致，也就是所有<code>log</code>都按顺序执行。那么<code>master</code>和备用服务器合在一起，就像是一个服务器一样，无所谓请求哪个服务器都会得到一致的结果。</p><h4 id="Raft的状态"><a href="#Raft的状态" class="headerlink" title="Raft的状态"></a>Raft的状态</h4><p><code>Raft</code>分为以下三个状态。</p><ul><li>Leader</li><li>Candidate</li><li>Follower</li></ul><p>Raft简单的地方在于，日志是由<code>Leader</code>到<code>Follower</code>的单向传递。也就是说<code>Leader</code>相当于一个总控节点，由它负责接受<code>client</code>的请求，并且把日志发送各个<code>Follower</code>，进行复制。也是只有Leader能决定何时提交一个日志。</p><p>其实整个Raft算法都是围绕着<code>Leader</code>进行的，主要分成以下三块。</p><ul><li><p>Leader election</p><p>一开始每个服务器都是<code>Follower</code>，那么需要决定由谁来做<code>Leader</code>，这里延伸出<code>Leader election</code>的问题。而且当Leader宕机的时候也需要重新进行选举。</p></li><li><p>Log replication</p><p>当<code>Leader</code>选举出来之后，需要把日志复制到每个<code>Follower</code>。这里复制需要保证所有日志都有序且正确的复制到<code>Follower</code>上。也就是说<code>Follower</code>上的日志不管是顺序还是内容都要和Leader上的一样。</p></li><li><p>Safety</p><p>一但Leader把一项日志复制到绝大多数（容错）的<code>Follower</code>时，需要执行这个日志。这里的安全性是指所有的服务器都要在这同一个位置执行同一个Log，简单来说就是<code>所有的服务器都要按一样的顺序执行相同的Log</code>。比方说一个log，<code>index = 3, command = x -&gt; 2</code>，那么所有的服务器在<code>Index=3</code>这个位置必须执行<code>x-&gt;2</code>这个操作，不然就会数据不一致了。<code>Safety</code>可能翻译成<code>正确性</code>更容易理解。</p></li></ul><h2 id="Leader-election"><a href="#Leader-election" class="headerlink" title="Leader election"></a>Leader election</h2><h4 id="任期（Term）"><a href="#任期（Term）" class="headerlink" title="任期（Term）"></a>任期（Term）</h4><p>在讲领导选举之前有一个比较关键的概念，就是<code>任期（Term）</code>。按照论文上的说法，<code>term</code>相当于一个逻辑上的时钟，用来检测过时的信息。请仔细理解上面这句话。<code>Follower</code>在超时之后就会成为<code>Candidate</code>，成为<code>Candidate</code>之后，它自增任期，并且把票投给自己，并且发送<code>RPC</code>请求给各个服务器，在得到绝大多数选票之后，成为<code>Leader</code>。为什么是绝大多数选票？因为一个任期只能有一个领导。假如<code>Candidate</code>没有拿到绝大多数选票，即有其他<code>Candidate</code>在竞争选票，那么<code>Candidate</code>会再次自增<code>Term</code>，发起下一轮投票。</p><p>这里有一个关键的点，就是一个任期只能有一个领导。假如领导宕机，会重新进行选举换领导，那么<code>Term</code>也会改变。所以通过这个方式可以用<code>Term</code>来感知过时的信息。假设有这一种情况，一开始a为领导，然后a断开了网络，集群的服务器因收不到a的心跳包，重新选举出一位领导b，b的任期大于a，当a再次加入网络，当发送心跳给b或者接受到b的心跳包时，通过比较<code>Term</code>可知a已经过期，会把a的<code>Term</code>改成b的<code>Term</code>，且状态变回<code>Follower</code>。</p><p><img src="https://camo.githubusercontent.com/f9b80d45d67996bb9ce63ba6e5d37b6a03150097/68747470733a2f2f646e2d307830312d696f2e71626f782e6d652f726166742d254535253942254245352e706e67" alt=""></p><h4 id="选举"><a href="#选举" class="headerlink" title="选举"></a>选举</h4><p>我们再来捋一下这个选举的过程</p><ol><li>服务器刚启动时，状态都是<code>Follower</code>。假如<code>Follower</code>在定时器设定的时间（随机）内，收到来自<code>Leader</code>或者<code>Candidate</code>合法的<code>RPC</code>请求，会继续保持<code>Follower</code>，并重置定时器的时间。</li><li>在定时器设定的时间内，没有收到合法的<code>RPC</code>请求，那么则发生<code>election timeout</code>，表示此时没有<code>Leader</code>。则超时的<code>Follower</code>，转换成<code>Candidate</code>。</li><li>成为<code>Candidate</code>之后，立即开始投票。先<code>Term</code>自增，然后投票给自己，重置定时器，并且并发的发送<code>RequestVote</code>给所有的服务器。接下来有三种情况会发生。<ul><li>A.收到绝大多数服务器的选票，赢得选举，成为<code>Leader</code></li><li>B.另一个服务器成为<code>Leader</code>，选举失败。（如何得知另一个服务器成为<code>Leader</code>？）</li><li>C.定时器超时，仍然没有<code>Leader</code>产生，说明有另外的<code>Candidate</code>竞争，产生平票之类的情况，则进入下一轮选举（也就是重做3）。</li></ul></li></ol><p>这里产生了Raft的第一个特性</p><ul><li><p>Election Safety</p><p>一个任期内只能有一个<code>Leader</code>。（任期不同即表示<code>Leader</code>已经换过了）</p></li></ul><h5 id="情况A"><a href="#情况A" class="headerlink" title="情况A"></a>情况A</h5><p>服务器按照先来先服务的原则进行投票（这里还有<code>Safety</code>的限制，只有含有全部<code>commit log</code>的<code>Candidate</code>才能获得选票）。所谓绝大多数的选票是指大于<code>n/2</code>。一旦赢得选举之后，则转成<code>Leader</code>，并且发送心跳包给另外的服务器来保证不会<code>election timeout</code>。</p><h5 id="情况B"><a href="#情况B" class="headerlink" title="情况B"></a>情况B</h5><p>假设另一个服务器成为了<code>Leader</code>，那么会发生什么？也就是当前这个<code>Candidate</code>会收到来自另一个<code>Leader</code>合法（<code>Term</code>没有落后）的<code>AppendEntries</code>请求。说明当前<code>Term</code>已经选举出<code>Leader</code>了，当前<code>Candidate</code>可以转为<code>Follower</code>了。</p><h5 id="情况C"><a href="#情况C" class="headerlink" title="情况C"></a>情况C</h5><p>也就是多个<code>Follower</code>都成为了<code>Candidate</code>，各自抢了一部分选票，一个都没赢。这种情况会再次发生election timeout，则直接进行下一轮竞选。</p><p>这里有个关键的问题，就是如何保证最终一定会产生一个<code>Leader</code>？办法是定时器设置的时间随机的<code>（150–300 ms）</code>。</p><h2 id="Log-replication"><a href="#Log-replication" class="headerlink" title="Log replication"></a>Log replication</h2><p>当<code>Leader</code>选出来之后，就到了发送log的环节了。这一部分的本质要解决的问题就是让<code>Follower</code>和<code>Leader</code>的日志顺序和内容都完全相同（指提交的部分），这样才能保证一致性。</p><p>阅读以下内容时请牢记<code>Log replication</code>要解决的本质问题是什么，也就是上面那句话。</p><p><code>Raft</code>维护了两个属性来保证<code>Follower</code>和<code>Leader</code>的日志顺序和内容完全相同（提交的部分）。</p><ul><li>如果两个entry在不同的服务器中，拥有同样的index和term，则保证他们保存了相同的命令</li><li>如果两个entry在不同的服务器中，拥有同样的index和term，则保证在两个entry之前的所有entry都相等。</li></ul><p>第一个属性要保证很简单，leader每次创建entry时，都只会使用新的index，而不会去改写之前index的内容。这也就是在给定index和term的情况下，只会创建一个entry。那么也就保证了相同index和term，相同命令。</p><p>第二个属性需要在每次<code>AppendEntries</code>的时候进行检查。<code>Leader</code>每次发送entry给follower时，会带上前一个entry的index和term。当<code>Follower</code>收到<code>RPC</code>时，会检查最后一个entry的index和term是不是和<code>AppendEntries</code>中的<code>prevIndex</code>和<code>prevTerm</code>相同，不相同则拒绝。若不相同则说明该entry保存的命令和<code>Leader</code>上保存的命令不同，则自然要拒绝。这个也就是所谓的一致性检查<code>（the consistency check）</code>。</p><p>正常情况下（没有机器宕机的情况），follower的日志是和leader同步的，不会有check失败的情况，但是如果考虑宕机的情况，就各种情况都有可能发生，参考下面一张图。</p><p><img src="https://camo.githubusercontent.com/a82fb45bde23f6b51ccca37f9dde7d5c5c547e90/68747470733a2f2f646e2d307830312d696f2e71626f782e6d652f726166742d254535253942254245372e706e67" alt=""></p><p><code>Follower</code>可能会缺少log，也可能会有多余的log，甚至都发生。</p><p>要解决这种情况，<code>Follower</code>需要从最后一次确认的entry之后，删除多余的entry，并且继续追加缺失的entry。</p><p><code>Raft</code>简单的地方在于，<code>Leader</code>从来不会修改自己log，而是让<code>Follower</code>自己去修改log。</p><p>方法就是<code>Leader</code>维护一个<code>nextIndex[i]</code>数组，用来保存下个发给<code>Follower[i]</code>的Index，如果<code>consistency check</code>通过，则<code>nextIndex[i]++</code>，不然的话则<code>nextIndex[i]--</code>，直到双方同步log位置。这个感觉有点类似于<code>tcp</code>传数据时的<code>ack</code>，总是返回下一个期望收到的数据包。</p><p>也就是说这里除了<code>nextIndex</code>的更新之外，<code>Leader</code>不需要做什么额外的动作。这就是<code>Raft</code>可理解的地方了。</p><h2 id="Safety"><a href="#Safety" class="headerlink" title="Safety"></a>Safety</h2><h4 id="选举限制"><a href="#选举限制" class="headerlink" title="选举限制"></a>选举限制</h4><p>那么是不是这样就能保证，<code>Follower</code>和<code>Leader</code>都按顺序执行相同的命令呢？不一定！考虑上面那张图的情况。假设这个时候<code>Leader</code>宕机，<code>Follower(f)</code>被选举成为<code>Leader</code>，那么会发生什么？<code>nextIndex</code>会一直<code>uncheck</code>直到<code>index=4</code>的<code>entry</code>，把2发给每个<code>Follower</code>，但是之前4已经复制到了大部分机器上，已经<code>commit</code>了，这时候会发生覆盖已经<code>commit</code>的<code>entry</code>的情况了！</p><p>所以在选举的时候会加上限制，在<code>RequestVote</code>中加上<code>Candidate</code>的最后一个entry的index以及term。<code>Follower</code>会与自己的最后一个<code>entry</code>的<code>index</code>和<code>term</code>进行比较。假设<code>term</code>不相等，那么只有拥有最新<code>term</code>的<code>Candidate</code>才能获得选票。若假设<code>term</code>相等，则比较<code>index</code>，最长的那个获得选票。</p><p>也就是说只有一个<code>Candidate</code>包含了全部已经<code>commit</code>的<code>entry</code>的情况下，才能获得选票。这就是所谓的<code>at least up-to-date</code>，其实也就是保证<code>term</code>最新，若<code>term</code>相同，则保证<code>log</code>最长。这样选出来的<code>leader</code>肯定包含所有<code>commit</code>的<code>entry</code>。（其实这个命题，同样要加上一点约束才是正确的，也就是下面的<code>commit</code>限制）</p><h4 id="commit限制"><a href="#commit限制" class="headerlink" title="commit限制"></a>commit限制</h4><p>我们先来看下面的图。</p><p><img src="https://camo.githubusercontent.com/14df99e543c71ee75cafd614e1c55c25ac580ec8/68747470733a2f2f646e2d307830312d696f2e71626f782e6d652f726166742d254535253942254245382e706e67" alt="图 8"></p><p>黑框表示为<code>Leader</code>。注意c的时候，2已经拷贝到大部分服务器上，提交以后，s1宕机，然后此时s5仍然能获得s2，s3，s4的选票成为<code>Leader</code>，但是这种情况s5不知道2已经被提交了，那么2就会被3覆盖！</p><p>这里限制的条件就是，在c的时候2无法提交！<code>Leader</code>仅仅只能提交当前<code>Term</code>的<code>entry</code>!这样的话如果没提交，即使被覆盖也没什么。如果到e这种情况，s5已经无法获得选票了。</p><p>通过上述两个限制保证<code>Leader</code>选举成功时一定会包含全部已经<code>commit</code>的<code>entry</code>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>此文大致描述了<code>Raft</code>算法的基本样貌。我觉得理解Raft最重要的还是理解下面五个性质。</p><p><img src="http://zhang.nos-eastchina1.126.net/blog/2017-06-11%2021-36-40%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p><p>最后再上一张pass所有test的截图！</p><p><img src="http://zhang.nos-eastchina1.126.net/blog/2017-06-11%2021-38-07%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://raft.github.io/raft.pdf" target="_blank" rel="noopener">In Search of an Understandable Consensus Algorithm</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Raft&quot;&gt;&lt;a href=&quot;#Raft&quot; class=&quot;headerlink&quot; title=&quot;Raft&quot;&gt;&lt;/a&gt;Raft&lt;/h2&gt;&lt;p&gt;关于&lt;code&gt;mit 6.824&lt;/code&gt;，这门课在找工作期间，又拾起来继续做了，断断续续的把&lt;code&gt;lab2&lt;/code&gt;做完了，pass掉所有test。完整的实现了&lt;code&gt;Raft&lt;/code&gt;算法，对分布式的了解也算是更进了一步。此文会对&lt;code&gt;Raft&lt;/code&gt;做一个归纳总结，大部分的内容基于&lt;a href=&quot;https://pdos.csail.mit.edu/6.824/papers/raft-extended.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;raft 论文&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Raft&lt;/code&gt;是一个共识算法，目的是为了保证多个副本在多个服务器的情况下数据的一致性，以及保证一定的容错能力。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Raft&lt;/code&gt;的卖点是&lt;code&gt;understandable&lt;/code&gt;，论文中一直在强调可理解（这个可理解对没接触过分布式的人来说，其实也不太好理解…）。这个可理解应该是相对于&lt;code&gt;paxos&lt;/code&gt;来说的。基于&lt;code&gt;understandable&lt;/code&gt;这个目标，&lt;code&gt;Raft&lt;/code&gt;把整个共识的过程分成三块，分别是&lt;code&gt;leader election&lt;/code&gt;， &lt;code&gt;log replication&lt;/code&gt;和&lt;code&gt;safety&lt;/code&gt;，下面我们会一一介绍。&lt;br&gt;
    
    </summary>
    
    
      <category term="Distributed System" scheme="http://threezj.com/tags/Distributed-System/"/>
    
  </entry>
  
  <entry>
    <title>数据库事务与并发控制</title>
    <link href="http://threezj.com/2016/12/30/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"/>
    <id>http://threezj.com/2016/12/30/数据库事务与并发控制/</id>
    <published>2016-12-30T08:20:06.000Z</published>
    <updated>2018-10-20T16:27:25.138Z</updated>
    
    <content type="html"><![CDATA[<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><blockquote><p>数据库事务是<code>DBMS</code>执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。</p></blockquote><p>事务必须要满足<code>ACID</code>四个特性。</p><ul><li><p><code>Atomicity</code>(原子性)</p><p>也就是所谓的<code>all-or-nothing</code>。单个事务有一系列的操作，比如查找，增加，更新等。当事务提交之后事务中所有对数据库的操作必须反映到数据库上。但如果由于某些原因中断，那么所有对数据的操作必须恢复到这个事务开始之前。也就是事务对数据库的操作，要么全部执行，要么都不执行。</p></li><li><p><code>Consistency</code>(一致性)</p><p>事务开始之前数据满足的完整性约束，在事务结束之后也需要满足。其实也就是事务得到了正确的执行。</p></li><li><p><code>Isolation</code>(隔离性)</p><p>每个事务之间是相互独立的。有点类似于进程的概念。因为事务是并发执行的，所以事务之间不能相互影响不然就有可能破坏<code>一致性</code>。</p></li><li><p><code>Durability</code>(持久性)</p><p>已被提交的事务对数据库的修改应该永久保存在数据库中。这里的关键应该在于永久二字，也就是说即使系统崩溃、硬盘损坏等不可控因素发生，也要保证数据仍然存在数据库中。所以备份很重要啊。</p><a id="more"></a></li></ul><h2 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h2><p>考虑一下当多个事务并发执行的情况，是否能保证<code>ACID</code>。如果完全不加控制，因为系统的线程调度是无法预知的，那么多个事务之间的执行顺序也不可控，即破坏了<code>隔离性</code>，随之而来的<code>一致性</code>也无法满足，比如事务可能写入脏数据破坏完整性约束。<code>原子性</code>和<code>持久性</code>需要靠<code>恢复系统</code>来保证，这篇文章不过多讨论<code>恢复系统</code>。</p><p>最简单的能想到的保持<code>隔离性</code>的方式即一次只运行一个事务，也就是说没有并发，<code>串行</code>调度，一个接一个。完全不需要并发控制，可是很明显不现实，因为效率极低。当事务并发执行时，任何调度顺序都是可能的。<code>并发控制</code>的任务是让并发的事务执行结果与串行调度的执行结果相同。这种调度称为<code>可串行化</code>。</p><p>并发控制的目标即<code>可串行化</code>。</p><h4 id="可串行化"><a href="#可串行化" class="headerlink" title="可串行化"></a>可串行化</h4><p>如何检测调度是否为<code>可串行化</code>？有很多方法，这里只说一种<code>冲突可串行化(conflict serializability)</code>。</p><p>先定义<code>冲突</code>，即假设不同事务的两种操作访问同一个对象，如果交换他们的操作顺序，会得到不同的结果，则<code>冲突</code>。</p><p>考虑事务最本质的两种操作，<code>read</code>和<code>write</code>，则总共有四种情况。</p><p><img src="http://zhang.nos-eastchina1.126.net/blog/2016-12-28%2023-29-27%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p><p>很明显，只要涉及到<code>write</code>则<code>冲突</code>。那么当交换调度中<code>未冲突操作</code>的顺序，能得到<code>串行</code>的调度，那么原先的调度则称为<code>冲突可串行化</code>。</p><p>好的，那么如何检测<code>冲突可串行化</code>，当然选择去交换<code>未冲突的操作</code>然后判断是否串行，但效率不高。比较高效的做法是通过<code>优先图</code>检测。维护一个<code>图</code>，当符合特定规则时，放入<code>边</code>。假设有两个事务<code>Ti/Tj</code>，一个对象A，规则如下。</p><ol><li>Ti在Tj之前读或者写A</li><li>Ti在Tj读A之前写A</li></ol><p>有些拗口。若无环，则是<code>冲突可串行化</code>，有环则不是，实例如下。</p><p><img src="http://zhang.nos-eastchina1.126.net/blog/2016-12-29%2021-04-17%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p><h4 id="可恢复与无级联"><a href="#可恢复与无级联" class="headerlink" title="可恢复与无级联"></a>可恢复与无级联</h4><p>考虑下面一种情况</p><p><img src="http://zhang.nos-eastchina1.126.net/blog/2016-12-30%2015-26-46%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p><p>上面这个调度的问题在于，事务2在读取了事务1的数据之后提交了，然而事务2因为某些原因终止了，那么事务2就要进行回滚。但是事务1已经提交了，提交意味着，数据已经被写入磁盘，原有的数据被覆盖，回滚会出错。这种调度则称为<code>不可恢复的调度</code>。若要实现<code>可恢复的调度</code>，则必须让事务2等待事务1提交之后，再进行提交。</p><p>所以<code>可恢复调度</code>即是指，若某事务A读取事务B写入的内容，则需在事务B提交之后，再提交。</p><p><code>可恢复调度</code>同时会带来一定的问题，即<code>级联</code>问题。若T2读了T1写的数据，T3读了T2写的数据，T4读了T3写的数据，以此类推，假设这时T1终止，则需要回滚一系列事务。这样效率是很低的。所以我们希望的是<code>无级联调度</code>，能避免这种情况。</p><p><code>无级联调度</code>即是指，若事务A读取事务B写入的内容，那么事务B需要在事务A读操作之前提交。注意这里的区别，把事务提交提前了。</p><p>并发控制希望做到<code>可串行化</code>，<code>可恢复</code>和<code>无级联</code>。<code>无级联调度</code>必定是<code>可恢复调度</code>。</p><h4 id="两阶段封锁-Two-phase-locking"><a href="#两阶段封锁-Two-phase-locking" class="headerlink" title="两阶段封锁(Two phase locking)"></a>两阶段封锁(Two phase locking)</h4><p><code>Two phase locking</code>是一种可以实现<code>可串行化</code>的协议。此协议把事务分成两个阶段，<code>增长阶段</code>以及<code>缩减阶段</code>。<code>增长阶段</code>是获得锁的阶段，而<code>缩减阶段</code>则反之，是释放锁的阶段。也就说当一个事务一旦释放了一个锁之后就不能继续加锁了。具体定义如下。</p><ul><li><code>增长阶段(growing phase)</code>: 事务可以获得锁，但不能释放锁</li><li><code>缩减阶段(shrinking phase)</code>: 事务可以释放锁，但不能获得锁</li></ul><p><code>两阶段封锁</code>最主要的作用是推迟了锁的释放时间。可以试想下如果在中间就释放锁，那则有可能调度给其他事务读到脏数据。</p><p><code>两阶段封锁</code>可以保证<code>可串行化</code>，这是可以证明的。但是<code>两阶段封锁</code>不保证<code>死锁</code>，所以需要额外的工作来检测或者预防<code>死锁</code>。</p><p><code>两阶段封锁</code>无法保证<code>无级联</code>，我们可以通过<code>严格两阶段封锁</code>来保证，即在<code>两阶段封锁</code>的前提下，约束在事务提交之前不得释放<code>排他锁</code>。也就是说如果事务不提交的话，他写的数据，别的事务就没法读，符合<code>无级联</code>的定义。</p><p>另个一个变种是<code>强两阶段封锁</code>在严格的基础上更进一步，约束事务在提交之前不得释放任何锁。</p><p>还有个问题，假如某个数据在之前很长一段时间都是只读的，到最后才需要写，如果按照目前的规则，事务在一开始就要获得对数据的<code>排他锁</code>，但是之前数据是只读的，这样影响了一定的效率。我们采取了<code>锁升级</code>的策略。可以先获得<code>共享锁</code>，直到需要写入时再获取排他锁，大大提高并发效率。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://db.csail.mit.edu/6.830/lectures/lec12-notes.pdf" target="_blank" rel="noopener">mit 6.830 lec12</a><br>《数据库系统概念》</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;事务&quot;&gt;&lt;a href=&quot;#事务&quot; class=&quot;headerlink&quot; title=&quot;事务&quot;&gt;&lt;/a&gt;事务&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;数据库事务是&lt;code&gt;DBMS&lt;/code&gt;执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;事务必须要满足&lt;code&gt;ACID&lt;/code&gt;四个特性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Atomicity&lt;/code&gt;(原子性)&lt;/p&gt;
&lt;p&gt;也就是所谓的&lt;code&gt;all-or-nothing&lt;/code&gt;。单个事务有一系列的操作，比如查找，增加，更新等。当事务提交之后事务中所有对数据库的操作必须反映到数据库上。但如果由于某些原因中断，那么所有对数据的操作必须恢复到这个事务开始之前。也就是事务对数据库的操作，要么全部执行，要么都不执行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Consistency&lt;/code&gt;(一致性)&lt;/p&gt;
&lt;p&gt;事务开始之前数据满足的完整性约束，在事务结束之后也需要满足。其实也就是事务得到了正确的执行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Isolation&lt;/code&gt;(隔离性)&lt;/p&gt;
&lt;p&gt;每个事务之间是相互独立的。有点类似于进程的概念。因为事务是并发执行的，所以事务之间不能相互影响不然就有可能破坏&lt;code&gt;一致性&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Durability&lt;/code&gt;(持久性)&lt;/p&gt;
&lt;p&gt;已被提交的事务对数据库的修改应该永久保存在数据库中。这里的关键应该在于永久二字，也就是说即使系统崩溃、硬盘损坏等不可控因素发生，也要保证数据仍然存在数据库中。所以备份很重要啊。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Database System" scheme="http://threezj.com/tags/Database-System/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络自顶向下之可靠传输协议的笔记</title>
    <link href="http://threezj.com/2016/12/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E4%B9%8B%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%AC%94%E8%AE%B0/"/>
    <id>http://threezj.com/2016/12/18/计算机网络自顶向下之可靠传输协议的笔记/</id>
    <published>2016-12-18T15:16:06.000Z</published>
    <updated>2018-10-20T16:26:23.523Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>此篇文章是<code>计算机网络 自顶向下方法</code>第三章的简略版笔记，这一章非常精彩。个人认为运输层可以说是计算网络中最重要的一层，分别面向应用层以及网络层。众所周知，网络层是无法保证可靠传输的。所以运输层根本的问题在于<code>如何能够在不可靠的网络层之上进行可靠的网络</code>。</p><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p><code>UDP</code>几乎没有做事情，仅仅只是把应用层的数据加上报文段，然后交付给网络层，虽然<code>UDP</code>有差错检查，但它也只是丢弃这个包而已。应用程序采用<code>UDP</code>的主要是基于效率的考虑。<code>UDP</code>简单，所以效率高。本文不讨论<code>UDP</code>。</p><h2 id="可靠数据传输"><a href="#可靠数据传输" class="headerlink" title="可靠数据传输"></a>可靠数据传输</h2><p>这一节我们从最简单的情况开始，针对各种情况，慢慢完善，最终形成一个可靠的数据传输协议。<code>TCP</code>是一个<code>全双工</code>的协议，双方可以互相发送信息。目前我们只考虑单向的传输。</p><h4 id="假设网络层可靠"><a href="#假设网络层可靠" class="headerlink" title="假设网络层可靠"></a>假设网络层可靠</h4><p>最开始我们先假设网络层是可靠的，也就是说我们交付给网络层的包不会丢失且完好无损，同时假设发送和接受双方速率是一样的。这种情况下我们需要考虑什么？什么都不需要考虑。就像<code>UDP</code>一样，打包好交付给网络层即可。相当于在网络层实现了可靠传输。<br><a id="more"></a></p><h4 id="假设网络层只存在数据损坏的情况"><a href="#假设网络层只存在数据损坏的情况" class="headerlink" title="假设网络层只存在数据损坏的情况"></a>假设网络层只存在数据损坏的情况</h4><p>现在我们假设网络层只存在数据损坏的情况，也就是每个包都能到达目标主机，但是数据正确性却不受控制。这种情况我们需要考虑两个问题。</p><ul><li>如何判断数据损坏？</li><li>如何通知发送方数据损坏？</li></ul><p>其实很容易理解，日常对话中，如果我们听清，最常见的就是让对话再说一遍。所以这里需要做三件事<code>差错检查</code>，<code>反馈给发送方</code>，<code>发送方重传</code>。这里开始是和<code>UDP</code>不同了，<code>UDP</code>进行差错检查后，如果发生错误丢掉这个包就完事了。<code>TCP</code>则会进行重传。</p><ul><li><p>差错检查</p><p>基本原理是用额外的<code>bit</code>来判断数据是否损坏，这里并不多解释。</p></li><li><p>反馈给发送方</p><p>当<code>差错检查</code>发现数据损坏时，我们需要通知发送方。也就是发送<code>ACK数据包</code>，所谓的<code>ACK数据包</code>也就是在报文段把一个标志位改成为1而已。或者发送<code>NAK数据包</code>。<code>ACK</code>表示数据发送成功，<code>NAK</code>表示失败。</p></li><li><p>重传</p><p>当发送方接受到反馈之后，若失败则要进行重传。</p></li></ul><p>现在的情况是这样的，发送方发送数据之后，开始阻塞等待接收方反馈，若得到<code>NAK</code>则进行重传，然后继续阻塞等待反馈。直接接受到<code>ACK</code>则开始发送下一个数据。这里有一个问题就是，当发送一个数据包后，发送方会阻塞，效率很低，这个问题我们下面会解决。</p><p>接收方很简单，接收到数据以后进行<code>差错检查</code>，若错误则进行反馈<code>NAK</code>，反之则发送<code>ACK</code>。</p><h4 id="反馈出错的情况"><a href="#反馈出错的情况" class="headerlink" title="反馈出错的情况"></a>反馈出错的情况</h4><p>新的问题，那就是反馈的<code>ACK</code>或者<code>NAK</code>出错！改如何解决，最先想到的就是发送方再问一遍，也就是再发一个包给接收方，问他刚刚说了什么，那如果这个包再出错的？这个方案显然有问题。另一种方法是当收到错误的<code>ACK</code>或者<code>NAK</code>，则直接进行重发。这种方法的问题是接受方不知道新接收的包是重传还是新发送的包。比如说接收方反馈<code>ACK</code>给发送方，但数据损坏发送方直接进行重发，那么接受方会认为这个新的包是全新的数据，而不是重发的，造成<code>冗余分组</code>。</p><p>解决这种情况一个很巧妙的方法，加入<code>序号</code>。也就是说对需要发送的数据包按顺序编号，那么接受方只需要检查<code>序号</code>即可确实这是否是一个重传的包。即检查新接受的包与上一次正确接受的包的<code>序号</code>进行比对，若相同则是重发，若大与则是新的包。有了<code>序号</code>之后，我们可以不用<code>NAK</code>，只用<code>ACK</code>，也能达到<code>NCK</code>的效果，即重发上一次正确接收的<code>ACK</code>，接收方比对<code>序号</code>可知数据包受损。</p><h4 id="网络层发送数据丢失"><a href="#网络层发送数据丢失" class="headerlink" title="网络层发送数据丢失"></a>网络层发送数据丢失</h4><p>好，新的问题来了。数据包丢失怎么办？按照之前的讨论，发送方会一直等待接收方进行<code>ACK反馈</code>，若数据包丢失，发送方则会一直阻塞。很自然的就想到采用定时器，等待一定时间之后，若发送方没得到反馈，则自动进行重传。但是如何确定等待时间又是个问题。可以确定的是，等待时间一定大于往返时延加上接受端处理数据包的时间。这是个比较复杂的问题，之后再讨论。</p><h4 id="超时处理"><a href="#超时处理" class="headerlink" title="超时处理"></a>超时处理</h4><p>还记得前面提到的，当发送方发送数据之后需要阻塞等待接受确认。这种方式叫做<code>停等协议</code>。可想而知效率很低，几乎大部分的时间都用来等待了。根据<code>计算机网络 自顶向下方法</code>上面的描述，采用<code>停等协议</code>的情况下，发送方只有<code>万分之2.7</code>的时间是在真正工作的！</p><p>之前的方法是一次发送一个数据包，然后进行阻塞等待。现在解决方法是发送多个数据包，然后再进行阻塞等待。注意这里是有本质的区别的。先前都是发一个等一个。现在是发送<code>n</code>个分组，并一起进行等待确认。区别在于发送的数据包的<code>ACK</code>可以在阻塞之前返回，那么则不需要等待之前发送的分组，可以继续向前移动。就好像铺铁路一样，其实并不需要那么长的铁轨，只需要很短一段铁轨就可以让火车绕世界一圈，只要你铺的够快。下面的图更加形象。</p><p><img src="http://zhang.nos-eastchina1.126.net/blog/2016-12-13%2023-20-07%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p><p>当遇到数据丢失或的情况，有两种方法可以解决。分别是<code>回退N步</code>和<code>选择重传</code></p><h4 id="回退N步"><a href="#回退N步" class="headerlink" title="回退N步"></a>回退N步</h4><p>发送多个分组且不用等待的数量是有限制的，因为考虑到需要<code>流量控制</code>，所以不能无限制的发送。假设发送<code>N</code>个分组，<code>N</code>通常被称为<code>窗口长度</code>。当<code>N</code>个分组中的<code>序号</code>最小的分组被确认之后，才能继续发送，这就是所谓的<code>滑动窗口协议</code>。</p><p>我们先来看接收方是如何处理的。接收方采用<code>累积确认</code>的方式，接收方只接收按序到达的数据包。接收方会把接收到的数据包与上次确认接收的数据包序号进行比对，若序号正好是按序到达的，则发送<code>ACK</code>确认接受，若不按序，则发送最后一次确认接收的<code>ACK</code>，并且丢弃这个包。注意这里虽然都是<code>ACK</code>，但是<code>ACK</code>包中带的<code>序号</code>是不同的。</p><p>发送方需要维护一个滑动窗口<code>[base,N]</code>，我们用<code>nextseq</code>表示下一个可以发送的序号。那么<code>[base, nextseq)</code>表示已经发送但未被确认,<code>[nextseq,N]</code>表示可以发送但是还未发送。<code>base</code>之前的则表示已经发送且确认的。<code>N</code>之后的则表示还不能发送的。若<code>base</code>被确认，则窗口向前移动。<code>回退N步</code>的主要动作在于数据丢失，定时器超时的情况，这个时候会重传所有已经发送但未被确认的<code>数据包</code>。因为上面接收方会把所有未按序到达的数据包丢弃。</p><p><img src="http://zhang.nos-eastchina1.126.net/blog/2016-12-14%2014-30-16%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p><h4 id="选择重传"><a href="#选择重传" class="headerlink" title="选择重传"></a>选择重传</h4><p><code>选择重传</code>解决了<code>回退N步</code>的效率问题，<code>回退N步</code>虽然实现简单，但是效率不高，在某些情况下需要重传大量分组。</p><p><code>选择重传</code>在接收方也维护了滑动窗口来缓存<code>正确到达但是乱序的分组</code>，而不是简单的丢弃。接收方分两种情况，如果是按序到达，则返回<code>ACK</code>确认这个包，并且一起交付与之相连续的之前缓存的数据包，同时滑动窗口向前移动。若未按序到达，则缓存这个<code>数据包</code>，并且返回<code>ACK</code>确认到达。</p><p>在发送方，和之前差不多，但是不会重发之前正确发送但是乱序的分组，而是只发送未确认的分组。</p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>终于轮到<code>TCP</code>了，但核心在上面。<code>TCP</code>用到了上述的所有原理比如<code>差错检查</code>，<code>累计确认</code>，<code>重传</code>，<code>定时器</code>等。<code>TCP</code>是面向连接的全双工运输层协议。也就是说<code>TCP</code>在通信之前，必须要建立一条可靠的连接，通过这条连接来进行通信。这点在使用<code>socket</code>编程的时候，十分明显。当客户端想发送消息给服务端时，必须先调用<code>connect</code>函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self.socket.connect((self.address, self.port))</span><br><span class="line">self.send(self.name)</span><br></pre></td></tr></table></figure><p><code>socket</code>是操作系统对<code>TCP</code>的一层抽象，提供接口让应用更加方便的使用<code>TCP</code>。</p><h4 id="TCP报文段"><a href="#TCP报文段" class="headerlink" title="TCP报文段"></a>TCP报文段</h4><p><img src="http://www.nosa.me/wp-content/uploads/2015/08/C9FBBF9A-04FE-4F2B-81E8-559391153C73.jpg" alt=""></p><ul><li><p>源端口号和目标端口号</p><p>各占用<code>16</code>位，源端口号和目标端口号再加上源地址和目的地址构成<code>socket</code>的唯一标识。</p></li><li><p>顺序号和确认号</p><p>这里就用到了上面的原理，即采用<code>序号</code>编码。<code>顺序号</code>标示当前数据包的<code>序号</code>，<code>确认号</code>表示期望收到的下一个数据包的<code>序号</code>。</p></li><li><p>头部长度</p><p>表明<code>TCP</code>首部的长度，因为可选项的存在，所以首部的长度是可变的。</p></li><li><p>控制位</p><p>设置为<code>1</code>时有效，作用如下图。</p><p><img src="http://www.nosa.me/wp-content/uploads/2015/08/AED89D8A-403B-42F4-AA2E-3EC23D20FAB7.jpg" alt=""></p></li><li><p>窗口大小</p><p>即滑动窗口的长度，用于<code>累积确认</code>以及<code>拥塞控制</code>。</p></li><li><p>校验和</p><p>用于差错检查</p></li><li><p>紧急指针</p><p>只有控制位的<code>URG</code>设置为<code>1</code>才有用，表示数据要优先处理，代表紧急数据最后一个字节的序号。</p></li><li><p>选项</p><p>这里可以填<code>MSS</code>之类的数据。</p></li></ul><h4 id="TCP的三次握手"><a href="#TCP的三次握手" class="headerlink" title="TCP的三次握手"></a>TCP的三次握手</h4><p>先来讨论下<code>TCP</code>的链接建立，为了建立可靠的通信链接，<code>TCP</code>需要发送三个分组，前两个分组不能携带数据，最后一个是可以携带数据的。也就是所谓的三次握手了。</p><ul><li><p>第一次</p><p>客户端向服务端发送<code>TCP</code>报文段，注意这里是不能包含有效数据的。报文段首部的控制位中<code>SYN</code>位会设置成<code>1</code>，表明这是连接请求报文段。还有就是初始化客户端的<code>起始序号</code>放在<code>顺序位</code>中，一般是随机选的。</p></li><li><p>第二次</p><p>当服务端收到<code>SYN报文段</code>之后，会回发一个报文段，表示允许链接，并且依旧不能携带数据。同样的<code>SYN</code>控制位设为<code>1</code>，并且初始化服务端的<code>起始序号</code>和缓存空间。另外<code>确认号</code>设置为<code>客户端的起始序号加1</code>，并且<code>ACK</code>的控制位设为<code>1</code>。</p></li><li><p>第三次</p><p>客户端收到服务端的允许连接报文之后，可以开始初始化客户端的缓存空间，并且回发一个报文段，这个报文段可以携带数据。这个报文段的确认号设置为<code>服务端的起始序号加1</code>。</p></li></ul><p>到这里不得不谈网上经典的面试题，<code>TCP建立连接为什么需要三次握手？</code>。让我们回到<code>TCP</code>的目的，是为了在不可靠的网络层之上建立可靠的运输协议。那么从这个角度来考虑，如果客户端不确认服务端的允许连接报文会发生什么？假设现在<code>TCP</code>经过服务端允许连接以后，连接就已经建立了。如果现在有一个无效的<code>TCP</code>请求连接发送到服务端，有可能是因为网络阻塞等原因。服务端则会认为这是一个客户端的新的连接请求，因为不需要客户端确认，则直接建立连接，然而这个连接其实是不需要的，白白浪费资源。如果加上第三次，客户端会确认这个请求是失效的，则不会建立连接。</p><h4 id="TCP的数据传输"><a href="#TCP的数据传输" class="headerlink" title="TCP的数据传输"></a>TCP的数据传输</h4><p><code>TCP</code>的可靠数据传输基本原理可以说已经包含在上半部分的介绍当中了。主要是三大原理<code>序号</code>，<code>累计确认</code>和<code>超时重传</code>。但是<code>TCP</code>根据实际情况加入了一些比较有趣的东西，比如<code>快速重传</code>，<code>冗余确认</code>等。</p><h4 id="简化版的TCP传输"><a href="#简化版的TCP传输" class="headerlink" title="简化版的TCP传输"></a>简化版的TCP传输</h4><p><img src="http://zhang.nos-eastchina1.126.net/blog/2016-12-14%2023-16-55%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p><p>首先初始化序号位，以及<code>sendBase</code>(也就是第一位未被确认的序号或者说下一个需要发送的序号)。比如说发送<code>seq=1</code>，<code>seq=2</code>,<code>seq=3</code>都未被确认，那么<code>sendBase</code>就为<code>1</code>，然后之后得到一个<code>seq=3</code>的<code>ACK=4</code>，那么则认为<code>seq=1</code>和<code>seq=2</code>都被收到了，则<code>sendBase</code>变为<code>4</code>。避免了重传，原因是接收方采用了<code>累积确认</code>。</p><p>考虑到实际使用中的情况，<code>TCP</code>增加了一些功能。</p><h4 id="超时加倍等待时间"><a href="#超时加倍等待时间" class="headerlink" title="超时加倍等待时间"></a>超时加倍等待时间</h4><p>这种方法其实很好理解，一旦发生超时事件，其实就说明网络拥堵，那么就加倍定时器的等待时间，让<code>TCP</code>发的慢一点以缓解网络拥塞。</p><h4 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h4><p>快速重传是当<code>TCP</code>连续收到<code>3</code>个<code>冗余ACK</code>会触发，即立刻重传未被确认的报文段(不等定时器超时)。所谓的<code>冗余ACK</code>其实也很明了，就是说明之前发送的报文段一直未被客户端收到，所以客户端一直重发期望收到的下一个报文段。</p><h4 id="选择重传还是回退N步"><a href="#选择重传还是回退N步" class="headerlink" title="选择重传还是回退N步"></a>选择重传还是回退N步</h4><p>答案是混合体！因为是<code>TCP</code>是<code>累计确认</code>的，从这一点来看<code>TCP</code>是<code>回退N步</code>的。但是<code>TCP</code>不重传<code>已经发送但未被确认</code>的数据，这一点又和<code>选择重传</code>很像。这里有个问题，既然<code>TCP</code>是<code>累计确认</code>的，那么如何保证那些<code>已经发送但未被确认</code>的数据已经到达接收方了呢？答案是<code>TCP</code>会缓存这些数据包，但是不会发送确认到达。直到<code>TCP</code>收到那个丢失的包后，会重排序缓存的包，并发送<code>ACK</code>。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>《计算机网络 自顶向下方法》</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;此篇文章是&lt;code&gt;计算机网络 自顶向下方法&lt;/code&gt;第三章的简略版笔记，这一章非常精彩。个人认为运输层可以说是计算网络中最重要的一层，分别面向应用层以及网络层。众所周知，网络层是无法保证可靠传输的。所以运输层根本的问题在于&lt;code&gt;如何能够在不可靠的网络层之上进行可靠的网络&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;UDP&quot;&gt;&lt;a href=&quot;#UDP&quot; class=&quot;headerlink&quot; title=&quot;UDP&quot;&gt;&lt;/a&gt;UDP&lt;/h2&gt;&lt;p&gt;&lt;code&gt;UDP&lt;/code&gt;几乎没有做事情，仅仅只是把应用层的数据加上报文段，然后交付给网络层，虽然&lt;code&gt;UDP&lt;/code&gt;有差错检查，但它也只是丢弃这个包而已。应用程序采用&lt;code&gt;UDP&lt;/code&gt;的主要是基于效率的考虑。&lt;code&gt;UDP&lt;/code&gt;简单，所以效率高。本文不讨论&lt;code&gt;UDP&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;可靠数据传输&quot;&gt;&lt;a href=&quot;#可靠数据传输&quot; class=&quot;headerlink&quot; title=&quot;可靠数据传输&quot;&gt;&lt;/a&gt;可靠数据传输&lt;/h2&gt;&lt;p&gt;这一节我们从最简单的情况开始，针对各种情况，慢慢完善，最终形成一个可靠的数据传输协议。&lt;code&gt;TCP&lt;/code&gt;是一个&lt;code&gt;全双工&lt;/code&gt;的协议，双方可以互相发送信息。目前我们只考虑单向的传输。&lt;/p&gt;
&lt;h4 id=&quot;假设网络层可靠&quot;&gt;&lt;a href=&quot;#假设网络层可靠&quot; class=&quot;headerlink&quot; title=&quot;假设网络层可靠&quot;&gt;&lt;/a&gt;假设网络层可靠&lt;/h4&gt;&lt;p&gt;最开始我们先假设网络层是可靠的，也就是说我们交付给网络层的包不会丢失且完好无损，同时假设发送和接受双方速率是一样的。这种情况下我们需要考虑什么？什么都不需要考虑。就像&lt;code&gt;UDP&lt;/code&gt;一样，打包好交付给网络层即可。相当于在网络层实现了可靠传输。&lt;br&gt;
    
    </summary>
    
    
      <category term="Computer Network" scheme="http://threezj.com/tags/Computer-Network/"/>
    
  </entry>
  
  <entry>
    <title>MIT 6.828 lab5</title>
    <link href="http://threezj.com/2016/12/07/MIT%206.828%20lab5/"/>
    <id>http://threezj.com/2016/12/07/MIT 6.828 lab5/</id>
    <published>2016-12-07T08:03:06.000Z</published>
    <updated>2018-04-17T15:40:27.885Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>lab5</code>比较简单，相对于之前的<code>lab</code>来说。主要就是完成简单的文件系统。大部分代码<code>mit</code>都已经帮你搭好了。</p><h2 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise 1"></a>Exercise 1</h2><blockquote><p><code>i386_init</code> identifies the file system environment by passing the type <code>ENV_TYPE_FS</code> to your environment creation function, <code>env_create</code>. Modify <code>env_create</code> in env.c, so that it gives the file system environment I/O privilege, but never gives that privilege to any other environment</p></blockquote><p>启动<code>IO</code>驱动器，设置一下标志位即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(type == ENV_TYPE_FS)&#123;</span><br><span class="line">       e-&gt;env_tf.tf_eflags |= FL_IOPL_3;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="Question-1"><a href="#Question-1" class="headerlink" title="Question 1"></a>Question 1</h4><blockquote><p>Do you have to do anything else to ensure that this I/O privilege setting is saved and restored properly when you subsequently switch from one environment to another? Why?</p></blockquote><p>不需要。因为进程切换时会保存<code>Trapframe</code>。</p><h2 id="Exercise-2"><a href="#Exercise-2" class="headerlink" title="Exercise 2"></a>Exercise 2</h2><blockquote><p>Implement the <code>bc_pgfault</code> and <code>flush_block</code> functions in fs/bc.c. <code>bc_pgfault</code> is a page fault handler, just like the one your wrote in the previous lab for copy-on-write fork, except that its job is to load pages in from the disk in response to a page fault. When writing this, keep in mind that (1) <code>addr</code> may not be aligned to a block boundary and (2) <code>ide_read</code> operates in sectors, not blocks.</p></blockquote><p>我们用<code>3G</code>的内存地址来映射磁盘。从<code>DISKMAP</code>至<code>DISKMAP+DISKMAX</code>。但是不可能把整块磁盘的内容都加载到内存中来。所以我们采用类似于<code>COW</code>的方式，延迟到<code>page fault</code>时，再从磁盘中读取，这种方式抽象了整个磁盘都在内存中的假象，并且以有限的内存空间，支持更大的磁盘读取。</p><p><code>bc_pgfault</code> 当产生<code>page fault</code>，说明这一页还未读取到内存中，则先分配一页，然后进行读取。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">addr = ROUNDDOWN(addr, PGSIZE);</span><br><span class="line">   r = sys_page_alloc(<span class="number">0</span>, addr, PTE_P | PTE_U | PTE_W);</span><br><span class="line">   <span class="keyword">if</span>(r != <span class="number">0</span>)</span><br><span class="line">       panic(<span class="string">"bc.c: paga_alloc failed %e"</span>, r);</span><br><span class="line">   r = ide_read(blockno * BLKSECTS, addr, BLKSECTS);</span><br><span class="line">   <span class="keyword">if</span>(r != <span class="number">0</span>)</span><br><span class="line">       panic(<span class="string">"bc.c: ide_read failed %e"</span>, r);</span><br></pre></td></tr></table></figure><p><code>flush_block</code> 内存中的内容被修改之后，需要写回到磁盘中。因为本质上它就是一块<code>Cache</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flush_block</span><span class="params">(<span class="keyword">void</span> *addr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> blockno = ((<span class="keyword">uint32_t</span>)addr - DISKMAP) / BLKSIZE;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">if</span> (addr &lt; (<span class="keyword">void</span>*)DISKMAP || addr &gt;= (<span class="keyword">void</span>*)(DISKMAP + DISKSIZE))</span><br><span class="line">        panic(<span class="string">"flush_block of bad va %08x"</span>, addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(va_is_mapped(addr) &amp;&amp; va_is_dirty(addr)))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    addr = ROUNDDOWN(addr, PGSIZE);</span><br><span class="line">    <span class="keyword">if</span>(va_is_mapped(addr) &amp;&amp; va_is_dirty(addr))&#123;</span><br><span class="line">        r = ide_write(blockno * BLKSECTS, addr, BLKSECTS);</span><br><span class="line">        <span class="keyword">if</span>(r != <span class="number">0</span>)</span><br><span class="line">            panic(<span class="string">"flush_block: ide_write failed %e"</span>, r);</span><br><span class="line">        r = sys_page_map(<span class="number">0</span>, addr, <span class="number">0</span>, addr, uvpt[PGNUM(addr)] &amp; PTE_SYSCALL);</span><br><span class="line">        <span class="keyword">if</span>(r != <span class="number">0</span>)</span><br><span class="line">            panic(<span class="string">"flush_block: sys_page_map failed %e"</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise 3"></a>Exercise 3</h2><blockquote><p>Use <code>free_block</code> as a model to implement <code>alloc_block</code> in fs/fs.c, which should find a free disk block in the bitmap, mark it used, and return the number of that block. When you allocate a block, you should immediately flush the changed bitmap block to disk with <code>flush_block</code>, to help file system consistency.</p></blockquote><p><code>Jos</code>用<code>bitmap</code>来跟踪空闲块，这里比较简单，模仿<code>block_is_free</code>写即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">alloc_block</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; super-&gt;s_nblocks; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (block_is_free(i)) &#123;</span><br><span class="line">            bitmap[i / <span class="number">32</span>] &amp;= ~(<span class="number">1</span> &lt;&lt; ( i %<span class="number">32</span>));</span><br><span class="line">            flush_block(diskaddr(i + <span class="number">2</span>));</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -E_NO_DISK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise 4"></a>Exercise 4</h2><blockquote><p>Implement <code>file_block_walk</code> and <code>file_get_block</code>. <code>file_block_walk</code> maps from a block offset within a file to the pointer for that block in the <code>struct File</code> or the indirect block, very much like what <code>pgdir_walk</code> did for page tables. <code>file_get_block</code> goes one step further and maps to the actual disk block, allocating a new one if necessary.</p></blockquote><p><code>file_block_walk</code>查找文件的磁盘块。分为两种情况，一种是<code>direct blocks</code>，也就是前十个块，是直接存在<code>File</code>数据结构中的，而<code>indirect block</code>，是一个指针指向额外的数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">file_block_walk(struct File *f, <span class="keyword">uint32_t</span> filebno, <span class="keyword">uint32_t</span> **ppdiskbno, <span class="keyword">bool</span> alloc) &#123;</span><br><span class="line">    <span class="keyword">int</span> blockno;</span><br><span class="line">    <span class="keyword">if</span> (filebno &gt; NDIRECT + NINDIRECT)</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    <span class="keyword">if</span>(filebno &lt; NDIRECT)</span><br><span class="line">        *ppdiskbno = &amp;f-&gt;f_direct[filebno];</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!f-&gt;f_indirect) &#123;</span><br><span class="line">            <span class="keyword">if</span>(alloc)&#123;</span><br><span class="line">                blockno = alloc_block();</span><br><span class="line">                <span class="keyword">if</span>(blockno &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> -E_NO_DISK;</span><br><span class="line">                <span class="built_in">memset</span>(diskaddr(blockno), <span class="number">0</span>, BLKSIZE);</span><br><span class="line">                f-&gt;f_indirect = blockno;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> -E_NOT_FOUND;</span><br><span class="line">        &#125;</span><br><span class="line">        *ppdiskbno = &amp;((<span class="keyword">uintptr_t</span> *) diskaddr(f-&gt;f_indirect))[filebno - NDIRECT];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>file_get_block</code> 是对<code>file_block_walk</code>的调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">file_get_block(struct File *f, <span class="keyword">uint32_t</span> filebno, <span class="keyword">char</span> **blk) &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> *ppdiskbno;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    r = file_block_walk(f, filebno, &amp;ppdiskbno, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(r &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    <span class="keyword">if</span>(! (*ppdiskbno))&#123;</span><br><span class="line">        r = alloc_block();</span><br><span class="line">        <span class="keyword">if</span>(r &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -E_NO_DISK;</span><br><span class="line">        *ppdiskbno = r;</span><br><span class="line">    &#125;</span><br><span class="line">    *blk = diskaddr(*ppdiskbno);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Exercise-5"><a href="#Exercise-5" class="headerlink" title="Exercise 5"></a>Exercise 5</h2><blockquote><p>Implement <code>serve_read</code> in fs/serv.c。</p></blockquote><p>本质上所谓的文件系统，其实就是一个独立的进程负责读写磁盘。所以当其他进程想要通过文件系统来进行读写，那么只能通过<code>IPC</code>。更详细的过程，<code>MIT</code>讲义上写的很清楚。</p><p><code>serve_read</code>没什么难度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">serve_read(<span class="keyword">envid_t</span> envid, <span class="keyword">union</span> Fsipc *ipc) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_read</span> *<span class="title">req</span> = &amp;<span class="title">ipc</span>-&gt;<span class="title">read</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Fsret_read</span> *<span class="title">ret</span> = &amp;<span class="title">ipc</span>-&gt;<span class="title">readRet</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (debug)</span><br><span class="line">        cprintf(<span class="string">"serve_read %08x %08x %08x\n"</span>, envid, req-&gt;req_fileid, req-&gt;req_n);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">OpenFile</span> *<span class="title">o</span>;</span></span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">if</span> ((r = openfile_lookup(envid, req-&gt;req_fileid, &amp;o)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    r = file_read(o-&gt;o_file, ret-&gt;ret_buf, req-&gt;req_n, o-&gt;o_fd-&gt;fd_offset);</span><br><span class="line">    <span class="keyword">if</span>(r &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    o-&gt;o_fd-&gt;fd_offset += r;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Exercise-6"><a href="#Exercise-6" class="headerlink" title="Exercise 6"></a>Exercise 6</h2><blockquote><p>Implement <code>serve_write</code> in fs/serv.c and <code>devfile_write</code> in lib/file.c.</p></blockquote><p><code>serve_write</code> 参照着<code>serve_read</code>写就行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">serve_write(<span class="keyword">envid_t</span> envid, struct Fsreq_write *req) &#123;</span><br><span class="line">    <span class="keyword">if</span> (debug)</span><br><span class="line">        cprintf(<span class="string">"serve_write %08x %08x %08x\n"</span>, envid, req-&gt;req_fileid, req-&gt;req_n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LAB 5: Your code here.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">OpenFile</span> *<span class="title">o</span>;</span></span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">if</span> ((r = openfile_lookup(envid, req-&gt;req_fileid, &amp;o)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    r = file_write(o-&gt;o_file, req-&gt;req_buf, req-&gt;req_n, o-&gt;o_fd-&gt;fd_offset);</span><br><span class="line">    <span class="keyword">if</span>(r &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    o-&gt;o_fd-&gt;fd_offset += r;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>devfile_write</code>也一样。注意<code>fsipcbuf</code>是存放各种读写操作的联合体。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static ssize_t</span><br><span class="line">devfile_write(struct Fd *fd, const void *buf, size_t n) &#123;</span><br><span class="line">    int r;</span><br><span class="line"></span><br><span class="line">    fsipcbuf.write.req_fileid = fd-&gt;fd_file.id;</span><br><span class="line">    fsipcbuf.write.req_n = n &lt; PGSIZE ? n: PGSIZE;</span><br><span class="line">    memmove(fsipcbuf.write.req_buf, buf, fsipcbuf.write.req_n);</span><br><span class="line">    r = fsipc(FSREQ_WRITE, NULL);</span><br><span class="line">    return r;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Exercise-7"><a href="#Exercise-7" class="headerlink" title="Exercise 7"></a>Exercise 7</h2><blockquote><p><code>spawn</code> relies on the new syscall <code>sys_env_set_trapframe</code> to initialize the state of the newly created environment. Implement <code>sys_env_set_trapframe</code> in kern/syscall.c(don’t forget to dispatch the new system call in <code>syscall()</code>).</p></blockquote><p>这里我们简单来看下<code>spawn</code>函数，它的主要工作就是把从磁盘上加载用户与程序，并运行它。相当于把<code>fork</code>和<code>exec</code>结合到一个函数。</p><ol><li>打开文件，获取<code>Fd</code></li><li>读取<code>ELF</code>头，这一步和<code>load_icode</code>，只不过这里是从磁盘中读</li><li>创建子进程</li><li>把子进程的<code>eip</code>设置到程序的入口点</li><li>初始化栈</li><li>把所有需要加载的程序段加载到子程序的地址空间。到这里，文件操作完毕。</li><li>初始化进程状态</li></ol><p>更详细的大家去看代码，这里不赘述。</p><p> <code>sys_env_set_trapframe</code>很简单</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_env_set_trapframe(<span class="keyword">envid_t</span> envid, struct Trapframe *tf) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line">    <span class="keyword">int</span> r = envid2env(envid, &amp;env, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(r!=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    env-&gt;env_tf = *tf;</span><br><span class="line">    env-&gt;env_tf.tf_eflags |= FL_IF;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Exercise-8"><a href="#Exercise-8" class="headerlink" title="Exercise 8"></a>Exercise 8</h2><blockquote><p>Change <code>duppage</code> in lib/fork.c to follow the new convention. If the page table entry has the <code>PTE_SHARE</code> bit set, just copy the mapping directly. (You should use<code>PTE_SYSCALL</code>, not <code>0xfff</code>, to mask out the relevant bits from the page table entry. <code>0xfff</code> picks up the accessed and dirty bits as well.)</p><p>Likewise, implement <code>copy_shared_pages</code> in lib/spawn.c. It should loop through all page table entries in the current process (just like <code>fork</code> did), copying any page mappings that have the <code>PTE_SHARE</code> bit set into the child process.</p></blockquote><p>这里需要让<code>Fd</code>在进程之间共享。多添加了一个标志位，使其在<code>fork</code>时并不进行<code>COW</code>映射，而是直接映射，所以当<code>page fault</code>时，也不会进行<code>copy</code>.</p><p><code>duppage</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(uvpt[pn] &amp; PTE_SHARE)&#123;</span><br><span class="line">       <span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, addr, envid, addr, uvpt[pn] &amp; PTE_SYSCALL)) &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span> r;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><code>copy_shared_pages</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">copy_shared_pages(<span class="keyword">envid_t</span> child) &#123;</span><br><span class="line">    <span class="keyword">uintptr_t</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; USTACKTOP; i += PGSIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((uvpd[PDX(i)] &amp; PTE_P) &amp;&amp;</span><br><span class="line">            (uvpt[PGNUM(i)] &amp; PTE_P) &amp;&amp;</span><br><span class="line">            (uvpt[PGNUM(i)] &amp; PTE_SHARE))</span><br><span class="line">        &#123;</span><br><span class="line">            sys_page_map(<span class="number">0</span>, (<span class="keyword">void</span>*)i,</span><br><span class="line">                     child, (<span class="keyword">void</span>*)i,</span><br><span class="line">                     (uvpt[PGNUM(i)] &amp; PTE_SYSCALL));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Exercise-9"><a href="#Exercise-9" class="headerlink" title="Exercise 9"></a>Exercise 9</h2><blockquote><p>In your kern/trap.c, call <code>kbd_intr</code> to handle trap <code>IRQ_OFFSET+IRQ_KBD</code> and <code>serial_intr</code> to handle trap <code>IRQ_OFFSET+IRQ_SERIAL</code>.</p></blockquote><p>不解释</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (tf-&gt;tf_trapno == IRQ_OFFSET + IRQ_KBD) &#123;</span><br><span class="line">       kbd_intr();</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (tf-&gt;tf_trapno == IRQ_OFFSET + IRQ_SERIAL) &#123;</span><br><span class="line">       serial_intr();</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="Exercise-10"><a href="#Exercise-10" class="headerlink" title="Exercise 10"></a>Exercise 10</h2><blockquote><p>The shell doesn’t support I/O redirection. It would be nice to run sh &lt;script instead of having to type in all the commands in the script by hand, as you did above. Add I/O redirection for &lt; to <code>user/sh.c</code>.</p></blockquote><p>这个也不解释，在<code>xv6</code>那本书第一章中就有提到过实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((fd = open(t, O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           cprintf(<span class="string">"open %s for read: %e"</span>, t, fd);</span><br><span class="line">           <span class="built_in">exit</span>();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (fd != <span class="number">0</span>) &#123;</span><br><span class="line">           dup(fd, <span class="number">0</span>);</span><br><span class="line">           close(fd);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;lab5&lt;/code&gt;比较简单，相对于之前的&lt;code&gt;lab&lt;/code&gt;来说。主要就是完成简单的文件系统。大部分代码&lt;code&gt;mit&lt;/code&gt;都已经帮你搭好了。&lt;/p&gt;
&lt;h2 id=&quot;Exercise-1&quot;&gt;&lt;a href=&quot;#Exercise-1&quot; class=&quot;headerlink&quot; title=&quot;Exercise 1&quot;&gt;&lt;/a&gt;Exercise 1&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;i386_init&lt;/code&gt; identifies the file system environment by passing the type &lt;code&gt;ENV_TYPE_FS&lt;/code&gt; to your environment creation function, &lt;code&gt;env_create&lt;/code&gt;. Modify &lt;code&gt;env_create&lt;/code&gt; in env.c, so that it gives the file system environment I/O privilege, but never gives that privilege to any other environment&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;启动&lt;code&gt;IO&lt;/code&gt;驱动器，设置一下标志位即可。&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(type == ENV_TYPE_FS)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       e-&amp;gt;env_tf.tf_eflags |= FL_IOPL_3;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;Question-1&quot;&gt;&lt;a href=&quot;#Question-1&quot; class=&quot;headerlink&quot; title=&quot;Question 1&quot;&gt;&lt;/a&gt;Question 1&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;Do you have to do anything else to ensure that this I/O privilege setting is saved and restored properly when you subsequently switch from one environment to another? Why?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不需要。因为进程切换时会保存&lt;code&gt;Trapframe&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;Exercise-2&quot;&gt;&lt;a href=&quot;#Exercise-2&quot; class=&quot;headerlink&quot; title=&quot;Exercise 2&quot;&gt;&lt;/a&gt;Exercise 2&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Implement the &lt;code&gt;bc_pgfault&lt;/code&gt; and &lt;code&gt;flush_block&lt;/code&gt; functions in fs/bc.c. &lt;code&gt;bc_pgfault&lt;/code&gt; is a page fault handler, just like the one your wrote in the previous lab for copy-on-write fork, except that its job is to load pages in from the disk in response to a page fault. When writing this, keep in mind that (1) &lt;code&gt;addr&lt;/code&gt; may not be aligned to a block boundary and (2) &lt;code&gt;ide_read&lt;/code&gt; operates in sectors, not blocks.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们用&lt;code&gt;3G&lt;/code&gt;的内存地址来映射磁盘。从&lt;code&gt;DISKMAP&lt;/code&gt;至&lt;code&gt;DISKMAP+DISKMAX&lt;/code&gt;。但是不可能把整块磁盘的内容都加载到内存中来。所以我们采用类似于&lt;code&gt;COW&lt;/code&gt;的方式，延迟到&lt;code&gt;page fault&lt;/code&gt;时，再从磁盘中读取，这种方式抽象了整个磁盘都在内存中的假象，并且以有限的内存空间，支持更大的磁盘读取。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bc_pgfault&lt;/code&gt; 当产生&lt;code&gt;page fault&lt;/code&gt;，说明这一页还未读取到内存中，则先分配一页，然后进行读取。&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;addr = ROUNDDOWN(addr, PGSIZE);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   r = sys_page_alloc(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, addr, PTE_P | PTE_U | PTE_W);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(r != &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       panic(&lt;span class=&quot;string&quot;&gt;&quot;bc.c: paga_alloc failed %e&quot;&lt;/span&gt;, r);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   r = ide_read(blockno * BLKSECTS, addr, BLKSECTS);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(r != &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       panic(&lt;span class=&quot;string&quot;&gt;&quot;bc.c: ide_read failed %e&quot;&lt;/span&gt;, r);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;flush_block&lt;/code&gt; 内存中的内容被修改之后，需要写回到磁盘中。因为本质上它就是一块&lt;code&gt;Cache&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;flush_block&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *addr)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;uint32_t&lt;/span&gt; blockno = ((&lt;span class=&quot;keyword&quot;&gt;uint32_t&lt;/span&gt;)addr - DISKMAP) / BLKSIZE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; r;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (addr &amp;lt; (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;*)DISKMAP || addr &amp;gt;= (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;*)(DISKMAP + DISKSIZE))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        panic(&lt;span class=&quot;string&quot;&gt;&quot;flush_block of bad va %08x&quot;&lt;/span&gt;, addr);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!(va_is_mapped(addr) &amp;amp;&amp;amp; va_is_dirty(addr)))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    addr = ROUNDDOWN(addr, PGSIZE);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(va_is_mapped(addr) &amp;amp;&amp;amp; va_is_dirty(addr))&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        r = ide_write(blockno * BLKSECTS, addr, BLKSECTS);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(r != &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            panic(&lt;span class=&quot;string&quot;&gt;&quot;flush_block: ide_write failed %e&quot;&lt;/span&gt;, r);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        r = sys_page_map(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, addr, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, addr, uvpt[PGNUM(addr)] &amp;amp; PTE_SYSCALL);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(r != &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            panic(&lt;span class=&quot;string&quot;&gt;&quot;flush_block: sys_page_map failed %e&quot;&lt;/span&gt;, r);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Operating system" scheme="http://threezj.com/tags/Operating-system/"/>
    
      <category term="MIT 6.828" scheme="http://threezj.com/tags/MIT-6-828/"/>
    
  </entry>
  
  <entry>
    <title>MIT 6.828 lab4</title>
    <link href="http://threezj.com/2016/12/02/MIT%206.828%20lab4/"/>
    <id>http://threezj.com/2016/12/02/MIT 6.828 lab4/</id>
    <published>2016-12-02T15:04:06.000Z</published>
    <updated>2018-04-17T15:41:46.389Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>lab4</code>终于完成了。<code>lab4</code>是到目前为止，比较复杂而且代码最多的<code>lab</code>。总共需要完成三个部分。<code>part A</code>添加多核支持，实现<code>RR</code>调度。<code>part B</code>实现<code>Copy-On-Write fork</code>。<code>part C</code> 实现时钟中断以及支持基本的<code>IPC</code>。</p><h2 id="Part-A"><a href="#Part-A" class="headerlink" title="Part A"></a>Part A</h2><h4 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise 1"></a>Exercise 1</h4><blockquote><p>Implement <code>mmio_map_region</code> in kern/pmap.c. To see how this is used, look at the beginning of <code>lapic_init</code> in kern/lapic.c. You’ll have to do the next exercise, too, before the tests for <code>mmio_map_region</code> will run.</p></blockquote><p>实现需要让<code>Jos</code>支持<code>symmetric multiprocessing</code>，也就是所有的<code>cpu</code>都拥有相同的权限去访问资源。<code>Jos</code>使用<code>LAPIC</code>来分发中断，以及通过它来知道当前使用的<code>cpu</code>。而处理器访问<code>LAPIC</code>，需要使用<code>MMIO</code>。所以我们需要对<code>MMIO</code>进行内存映射，这个函数比较简单。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line">mmio_map_region(<span class="keyword">physaddr_t</span> pa, <span class="keyword">size_t</span> size) &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">uintptr_t</span> base = MMIOBASE;</span><br><span class="line"></span><br><span class="line">    size = ROUNDUP(size, PGSIZE);</span><br><span class="line">    <span class="keyword">if</span>(base + size &gt; MMIOLIM)&#123;</span><br><span class="line">        panic(<span class="string">"mmio_map_region: reservation mem overflow"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    boot_map_region(kern_pgdir, base, size, pa, PTE_W | PTE_PCD | PTE_P);</span><br><span class="line">    <span class="keyword">uintptr_t</span> b = base;</span><br><span class="line">    base += size;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span> *) b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="Exercise-2"><a href="#Exercise-2" class="headerlink" title="Exercise 2"></a>Exercise 2</h4><blockquote><p>Read <code>boot_aps()</code> and <code>mp_main()</code> in kern/init.c, and the assembly code in kern/mpentry.S. Make sure you understand the control flow transfer during the bootstrap of APs. Then modify your implementation of <code>page_init()</code> in kern/pmap.c to avoid adding the page at <code>MPENTRY_PADDR</code> to the free list, so that we can safely copy and run AP bootstrap code at that physical address. Your code should pass the updated <code>check_page_free_list()</code> test (but might fail the updated <code>check_kern_pgdir()</code> test, which we will fix soon).</p></blockquote><p><code>boot_aps()</code>首先把<code>mpentry.S</code>的代码复制到内存<code>MPENTRY_PADDR</code>中。然后对每个<code>cpu</code>都启动一个进程，也就是<code>APS</code>，进程栈保存在<code>percpu_kstacks</code>。最后通过<code>lapic_startap</code>发生中断跳到<code>mpentry.S</code>去执行。然后进行死循环等待<code>cpu进程</code>启动。<code>mpentry.S</code>的功能与<code>bootloader</code>类似，最后会跳转到<code>mp_main</code>。然后就是进行一些初始化，改变<code>cpu</code>状态为启动，通知<code>boot_aps()</code>可以进行<code>boot</code>下一个进程了。</p><p>所以这里我门需要为<code>MPENTRY_PADDR</code>留出一块空间来放<code>mpentry.S</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mpentry_i = PGNUM(MPENTRY_PADDR);</span><br><span class="line">   pages[mpentry_i + <span class="number">1</span>].pp_link = pages[mpentry_i].pp_link;</span><br><span class="line">   pages[mpentry_i].pp_link = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><h4 id="Question-1"><a href="#Question-1" class="headerlink" title="Question 1"></a>Question 1</h4><blockquote><p>Compare kern/mpentry.S side by side with boot/boot.S. Bearing in mind that kern/mpentry.S is compiled and linked to run above <code>KERNBASE</code> just like everything else in the kernel, what is the purpose of macro <code>MPBOOTPHYS</code>? Why is it necessary in kern/mpentry.S but not in boot/boot.S? In other words, what could go wrong if it were omitted in kern/mpentry.S?<br>Hint: recall the differences between the link address and the load address that we have discussed in Lab 1.</p></blockquote><p><code>MPBOOTPHYS</code>的作用是将高地址变为地址。因为根据注释上的说明，此次还处于实模式，但是代码中的地址已经经过重定位，所以需要进行地址翻译。</p><h4 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise 3"></a>Exercise 3</h4><blockquote><p>Modify <code>mem_init_mp()</code> (in kern/pmap.c) to map per-CPU stacks starting at <code>KSTACKTOP</code>, as shown in inc/memlayout.h. The size of each stack is <code>KSTKSIZE</code> bytes plus<code>KSTKGAP</code> bytes of unmapped guard pages. Your code should pass the new check in <code>check_kern_pgdir()</code>.</p></blockquote><p>为每个cpu栈分配内存，比较简单，按照<code>memlayout</code>来就行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">mem_init_mp(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="keyword">uintptr_t</span> kstacktop_i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NCPU; i++)&#123;</span><br><span class="line">        kstacktop_i = KSTACKTOP - i * (KSTKSIZE + KSTKGAP);</span><br><span class="line">        boot_map_region(kern_pgdir, kstacktop_i - KSTKSIZE, KSTKSIZE,</span><br><span class="line">        PADDR(percpu_kstacks[i]), PTE_W);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise 4"></a>Exercise 4</h4><blockquote><p>The code in <code>trap_init_percpu()</code> (kern/trap.c) initializes the TSS and TSS descriptor for the BSP. It worked in Lab 3, but is incorrect when running on other CPUs. Change the code so that it can work on all CPUs. (Note: your new code should not use the global <code>ts</code> variable any more.)</p></blockquote><p>初始化每个cpu进程，这里也没什么好说的，照着注释写即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">trap_init_percpu(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> i = cpunum();</span><br><span class="line">    <span class="comment">// Setup a TSS so that we get the right stack</span></span><br><span class="line">    <span class="comment">// when we trap to the kernel.</span></span><br><span class="line">    thiscpu-&gt;cpu_ts.ts_esp0 = (<span class="keyword">uintptr_t</span>)percpu_kstacks[i];</span><br><span class="line">    <span class="comment">//thiscpu-&gt;cpu_ts.ts_esp0 = KSTACKTOP - i * (KSTKSIZE + KSTKGAP);</span></span><br><span class="line">    thiscpu-&gt;cpu_ts.ts_ss0 = GD_KD;</span><br><span class="line">    thiscpu-&gt;cpu_ts.ts_iomb = <span class="keyword">sizeof</span>(struct Taskstate);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize the TSS slot of the gdt.</span></span><br><span class="line">    gdt[(GD_TSS0 &gt;&gt; <span class="number">3</span>) + i] = SEG16(STS_T32A, (<span class="keyword">uint32_t</span>) (&amp;thiscpu-&gt;cpu_ts),</span><br><span class="line">                    <span class="keyword">sizeof</span>(struct Taskstate) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    gdt[(GD_TSS0 &gt;&gt; <span class="number">3</span>) + i].sd_s = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Load the TSS selector (like other segment selectors, the</span></span><br><span class="line">    <span class="comment">// bottom three bits are special; we leave them 0)</span></span><br><span class="line">    ltr(GD_TSS0 + (i &lt;&lt; <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Load the IDT</span></span><br><span class="line">    lidt(&amp;idt_pd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Exercise-5"><a href="#Exercise-5" class="headerlink" title="Exercise 5"></a>Exercise 5</h4><blockquote><p>Apply the big kernel lock as described above, by calling <code>lock_kernel()</code> and <code>unlock_kernel()</code> at the proper locations.</p></blockquote><p>现在有多个<code>cpu</code>进程都能运行<code>kernel</code>，所以现在必须要解决进程间资源竞争的问题，这里直接套了一个大锁，进程进入<code>kernel</code>的时候上锁，退出的时候释放。。。略邪恶。这里需要贴的地方比较多，但代码比较简单，我就不放了。需要的可以去<code>github</code>上找。</p><h4 id="Question-2"><a href="#Question-2" class="headerlink" title="Question 2"></a>Question 2</h4><blockquote><p>It seems that using the big kernel lock guarantees that only one CPU can run the kernel code at a time. Why do we still need separate kernel stacks for each CPU? Describe a scenario in which using a shared kernel stack will go wrong, even with the protection of the big kernel lock.</p></blockquote><p>这个问题采用了<a href="https://github.com/Al--Zn/JOS/tree/lab4" target="_blank" rel="noopener">AL–Zn</a>的回答。中断发生时会自动压栈，而这时候还没有取得锁，若多个CPU同时发生中断，共享内核栈将会出错。</p><h4 id="Exercise-6"><a href="#Exercise-6" class="headerlink" title="Exercise 6"></a>Exercise 6</h4><blockquote><p>Implement round-robin scheduling in <code>sched_yield()</code> as described above. Don’t forget to modify <code>syscall()</code> to dispatch <code>sys_yield()</code>.<br>Make sure to invoke <code>sched_yield()</code> in <code>mp_main</code>.<br>Modify <code>kern/init.c</code> to create three (or more!) environments that all run the program <code>user/yield.c</code></p></blockquote><p>实现<code>RR</code>调度。顺序循环进行遍历进程，从当前进程开始找，直到找到第一个<code>ENV_RUNNABLE</code>的进程，并运行它。具体细节参照注释。实现如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">sched_yield(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> cur_idx;</span><br><span class="line">    <span class="keyword">if</span> (curenv)</span><br><span class="line">        cur_idx = ENVX(curenv-&gt;env_id);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cur_idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(envs[cur_idx].env_status == ENV_RUNNABLE)&#123;</span><br><span class="line">        env_run(&amp;envs[cur_idx]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = cur_idx + <span class="number">1</span>; i != cur_idx; i = (i + <span class="number">1</span>) % NENV)&#123;</span><br><span class="line">        <span class="keyword">if</span>(envs[i].env_status == ENV_RUNNABLE)&#123;</span><br><span class="line">            env_run(&amp;envs[i]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(curenv &amp;&amp; curenv-&gt;env_status == ENV_RUNNING) &#123;</span><br><span class="line">        env_run(curenv);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sched_halt never returns</span></span><br><span class="line">    sched_halt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Question-3"><a href="#Question-3" class="headerlink" title="Question 3"></a>Question 3</h4><blockquote><p>In your implementation of <code>env_run()</code> you should have called <code>lcr3()</code>. Before and after the call to <code>lcr3()</code>, your code makes references (at least it should) to the variable<code>e</code>, the argument to <code>env_run</code>. Upon loading the <code>%cr3</code> register, the addressing context used by the MMU is instantly changed. But a virtual address (namely <code>e</code>) has meaning relative to a given address context–the address context specifies the physical address to which the virtual address maps. Why can the pointer <code>e</code> be dereferenced both before and after the addressing switch?</p></blockquote><p>因为<code>mem_init()</code>时是以<code>kernel pgdir</code>为模板的</p><h4 id="Question-4"><a href="#Question-4" class="headerlink" title="Question 4"></a>Question 4</h4><blockquote><p>Whenever the kernel switches from one environment to another, it must ensure the old environment’s registers are saved so they can be restored properly later. Why? Where does this happen?</p></blockquote><p>当然需要保存。不然进程切换时无法恢复啊。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy trap frame (which is currently on the stack)</span></span><br><span class="line"><span class="comment">// into 'curenv-&gt;env_tf', so that running the environment</span></span><br><span class="line">   <span class="comment">// will restart at the trap point.</span></span><br><span class="line">   curenv-&gt;env_tf = *tf;</span><br></pre></td></tr></table></figure><h4 id="Exercise-7"><a href="#Exercise-7" class="headerlink" title="Exercise 7"></a>Exercise 7</h4><blockquote><p>Implement the system calls described above in kern/syscall.c. You will need to use various functions in kern/pmap.c and kern/env.c, particularly <code>envid2env()</code>. For now, whenever you call <code>envid2env()</code>, pass 1 in the <code>checkperm</code> parameter. Be sure you check for any invalid system call arguments, returning <code>-E_INVAL</code> in that case. Test your JOS kernel with user/dumbfork and make sure it works before proceeding.</p></blockquote><p>这里虽然看起来需要实现的代码很多，其实并不难，因为注释很详细，需要完成的任务也简单。</p><p><code>sys_exofork</code>这里的<code>fork</code>，只是单纯分配了一块地址空间给进程，但里面是空的，所以目前进程还是不可运行。具体做法也很直观，下面是实现，注意要把子进程返回值的寄存器设为0.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">envid_t</span></span><br><span class="line">sys_exofork(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">child_env</span>;</span></span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    r = env_alloc(&amp;child_env, curenv-&gt;env_id);</span><br><span class="line">    <span class="keyword">if</span>(r!=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    child_env-&gt;env_status = ENV_NOT_RUNNABLE;</span><br><span class="line">    child_env-&gt;env_tf = curenv-&gt;env_tf;</span><br><span class="line">    child_env-&gt;env_tf.tf_regs.reg_eax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> child_env-&gt;env_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sys_env_set_status</code>设置状态，不多说。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_env_set_status(<span class="keyword">envid_t</span> envid, <span class="keyword">int</span> status) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line">    <span class="keyword">int</span> r = envid2env(envid, &amp;env, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(r!=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    <span class="keyword">if</span>(env-&gt;env_status == ENV_RUNNABLE || env-&gt;env_status == ENV_NOT_RUNNABLE)&#123;</span><br><span class="line">        env-&gt;env_status = status;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sys_page_alloc</code> 分配页的系统调用，不难，比较烦的是权限检查。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_page_alloc(<span class="keyword">envid_t</span> envid, <span class="keyword">void</span> *va, <span class="keyword">int</span> perm) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line">    <span class="keyword">int</span> r = envid2env(envid, &amp;env, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(r!=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    <span class="keyword">if</span> (va &gt; (<span class="keyword">void</span> *) UTOP || va != ROUNDDOWN(va, PGSIZE))</span><br><span class="line">       <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    <span class="keyword">int</span> flag = PTE_U | PTE_P;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((perm &amp; flag) != flag)</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (perm &amp; (~(PTE_U | PTE_P | PTE_AVAIL | PTE_W)))</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp</span> = <span class="title">page_alloc</span>(1);</span></span><br><span class="line">    <span class="keyword">if</span>(pp == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">    pp-&gt;pp_ref ++;</span><br><span class="line">    r = page_insert(env-&gt;env_pgdir, pp, va, perm);</span><br><span class="line">    <span class="keyword">if</span>(r!=<span class="number">0</span>)&#123;</span><br><span class="line">        page_free(pp);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sys_page_map</code>，页的映射，用来两个进程通信时使用，使两块地址空间的部分内容映射到同一块物理地址。也不难。。还是烦在地址检查。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_page_map(<span class="keyword">envid_t</span> srcenvid, <span class="keyword">void</span> *srcva,</span><br><span class="line">         <span class="keyword">envid_t</span> dstenvid, <span class="keyword">void</span> *dstva, <span class="keyword">int</span> perm) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">srcenv</span>, *<span class="title">dstenv</span>;</span></span><br><span class="line">    <span class="keyword">int</span> r = envid2env(srcenvid, &amp;srcenv, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(r!=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    r = envid2env(dstenvid, &amp;dstenv, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(r!=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (srcva &gt;= (<span class="keyword">void</span> *) UTOP || dstva &gt;= (<span class="keyword">void</span> *) UTOP ||</span><br><span class="line">        srcva != ROUNDDOWN(srcva, PGSIZE) || dstva != ROUNDDOWN(dstva, PGSIZE))</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pte_t</span> *pte;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp</span> = <span class="title">page_lookup</span>(<span class="title">srcenv</span>-&gt;<span class="title">env_pgdir</span>, <span class="title">srcva</span>, &amp;<span class="title">pte</span>);</span></span><br><span class="line">    <span class="keyword">if</span>(pp == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((!(perm &amp; (PTE_U | PTE_P))) || (perm &amp; (~(PTE_U | PTE_P | PTE_AVAIL | PTE_W))))</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((perm &amp; PTE_W) &amp;&amp; !(*pte &amp; PTE_W))</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line"></span><br><span class="line">    r = page_insert(dstenv-&gt;env_pgdir, pp, dstva, perm);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sys_page_unmap</code>不多说</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_page_unmap(<span class="keyword">envid_t</span> envid, <span class="keyword">void</span> *va) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line">    <span class="keyword">int</span> r = envid2env(envid, &amp;env, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(r!=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    <span class="keyword">if</span> (va &gt; (<span class="keyword">void</span> *)UTOP || va != ROUNDDOWN(va, PGSIZE))</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line"></span><br><span class="line">    page_remove(env-&gt;env_pgdir, va);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Part-B"><a href="#Part-B" class="headerlink" title="Part B"></a>Part B</h2><p><code>Part B</code>的任务主要是实现<code>Copy-on-Write Fork</code>，也就是所谓的写时拷贝技术。传统的<code>fork</code>函数，调用时会直接将父进程的内存内容拷贝到子进程当中了，但是大多数是程序，当<code>fork</code>之后就直接调用<code>exec()</code>填充新的内存内容了。所以拷贝这一步很浪费时间。所以现在采用的做法是<code>COW fork</code>，也就是把拷贝的时间推迟到子进程需要写入的时候。这种做法用的很多，比如<code>cache</code>更新的情况。</p><p>具体做法是，当<code>fork</code>调用时，把子进程的用户空间的地址都映射到父进程时，并且设置权限位，直到子进程需要写内存的时候，权限判断失败，并触发<code>page fault</code>，然后进行系统分配页，把需要写入的那一页内存<code>copy</code>出来，并分配到子进程的地址空间中。</p><p>所以在写<code>COW Fork</code>之前，首先需要处理在用户空间<code>page fault</code>的情况。</p><h4 id="Exercise-8"><a href="#Exercise-8" class="headerlink" title="Exercise 8"></a>Exercise 8</h4><blockquote><p>Implement the <code>sys_env_set_pgfault_upcall</code> system call. Be sure to enable permission checking when looking up the environment ID of the target environment, since this is a “dangerous” system call</p></blockquote><p>这个很简单了，就是设置<code>pgfault</code>时需要调用的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_env_set_pgfault_upcall(<span class="keyword">envid_t</span> envid, <span class="keyword">void</span> *func) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line">    <span class="keyword">int</span> r = envid2env(envid, &amp;env, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(r!=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    env-&gt;env_pgfault_upcall = func;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Exercise-9"><a href="#Exercise-9" class="headerlink" title="Exercise 9"></a>Exercise 9</h4><blockquote><p>Implement the code in <code>page_fault_handler</code> in kern/trap.c required to dispatch page faults to the user-mode handler. Be sure to take appropriate precautions when writing into the exception stack. (What happens if the user environment runs out of space on the exception stack?)</p></blockquote><p>这个函数比较复杂。因为这里涉及到栈的切换。当<code>kernel</code>处理<code>page_fault</code>时，并不是在<code>kernel栈</code>或者<code>用户栈</code>处理，而是启用了一个新的栈，<code>用户异常栈</code>。并且使用一个新的数据结构<code>UTrapframe</code>来保存触发<code>page_fault</code>的进程信息。所以现在用户空间的缺页流程是这样的的，用户空间发生缺页，产生中断，陷入到内核中，分发到<code>page_fault_handler</code>中，在<code>用户异常栈</code>保存错误进程的信息，以及错误地址(保存到<code>UTrapframe</code>中)，切换到<code>用户异常栈</code>，然后调用用户自定义的<code>pgfault_upcall</code>，最后再切换到原来错误的地方继续运行。</p><p>栈的切换分成两种情况。</p><ul><li>用户进程发生<code>page_fault</code>。<code>用户栈</code> -&gt; <code>kernel栈</code> -&gt; <code>用户异常栈</code></li><li>在<code>page_fault</code>处理时又发生<code>page_fault</code>。虽然已经在用户异常栈了，但还是会继续陷入到内核中，重走一遍上面的流程，这里需要注意，压入<code>UTrapframe</code>时，需要空<code>4</code>个字节。所以栈切换顺序为，<code>用户异常栈</code> -&gt; <code>kernel栈</code> -&gt; <code>用户异常栈</code></li></ul><p>好，现在情况应该比较清楚了。所以目前这个函数需要做的就是在<code>用户异常栈</code>中压入<code>UTrapframe</code>数据结构，并保存错误进程的信息，以便之后恢复重新运行。这里有一点要注意，就是有可能发生上面说的第二种情况，所以需要判断进程的栈地址是不是已经在<code>用户异常栈</code>了，然后需要多压<code>4字节</code>，另外别忘了检查地址用完的情况。代码如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(curenv-&gt;env_pgfault_upcall!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">UTrapframe</span> *<span class="title">utf</span>;</span></span><br><span class="line">       <span class="keyword">uintptr_t</span> utf_addr;</span><br><span class="line">       <span class="keyword">if</span>(tf-&gt;tf_esp &gt;= UXSTACKTOP - PGSIZE &amp;&amp; tf-&gt;tf_esp &lt; UXSTACKTOP)&#123;</span><br><span class="line">           utf_addr = tf-&gt;tf_esp - <span class="keyword">sizeof</span>(struct UTrapframe) - <span class="number">4</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span>&#123;</span><br><span class="line">           utf_addr = UXSTACKTOP - <span class="keyword">sizeof</span>(struct UTrapframe);</span><br><span class="line">       &#125;</span><br><span class="line">       user_mem_assert(curenv, (<span class="keyword">void</span> *) utf_addr, <span class="keyword">sizeof</span>(struct UTrapframe), PTE_W);</span><br><span class="line"></span><br><span class="line">       utf = (struct UTrapframe *) utf_addr;</span><br><span class="line">       utf-&gt;utf_fault_va = fault_va;</span><br><span class="line">       utf-&gt;utf_err = tf-&gt;tf_err;</span><br><span class="line">       utf-&gt;utf_regs = tf-&gt;tf_regs;</span><br><span class="line">       utf-&gt;utf_eip = tf-&gt;tf_eip;</span><br><span class="line">       utf-&gt;utf_eflags = tf-&gt;tf_eflags;</span><br><span class="line">       utf-&gt;utf_esp = tf-&gt;tf_esp;</span><br><span class="line"></span><br><span class="line">       tf-&gt;tf_eip = (<span class="keyword">uintptr_t</span>) curenv-&gt;env_pgfault_upcall;</span><br><span class="line">       tf-&gt;tf_esp = utf_addr;</span><br><span class="line">       env_run(curenv);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="Exercise-10"><a href="#Exercise-10" class="headerlink" title="Exercise 10"></a>Exercise 10</h4><blockquote><p>Implement the <code>_pgfault_upcall</code> routine in lib/pfentry.S. The interesting part is returning to the original point in the user code that caused the page fault. You’ll return directly there, without going back through the kernel. The hard part is simultaneously switching stacks and re-loading the EIP.</p></blockquote><p>这是我最头疼的部分。这段汇编先调用了用户自定义的<code>page_handler</code>函数，然后需要根据之前压入的<code>UTrapframe</code>来切换为发生的错误的进程继续运行。这里我用了<code>PKU张弛</code>的代码。。他貌似也是用了别人的代码。。。我没有过多去纠结这段代码。大致是把返回的错误地址填到之前空的<code>4</code>个字节处，再加点<code>trick</code>，就可以同时切换<code>esp</code>和<code>eip</code>。下面是代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">movl 0x28(%esp), %eax</span><br><span class="line">subl $0x4, 0x30(%esp)</span><br><span class="line">movl 0x30(%esp), %edx</span><br><span class="line">movl %eax, (%edx)</span><br><span class="line">addl $0x8, %esp</span><br><span class="line"></span><br><span class="line">// Restore the trap-time registers.  After you do this, you</span><br><span class="line">// can no longer modify any general-purpose registers.</span><br><span class="line">popal</span><br><span class="line"></span><br><span class="line">// Restore eflags from the stack.  After you do this, you can</span><br><span class="line">// no longer use arithmetic operations or anything else that</span><br><span class="line">// modifies eflags.</span><br><span class="line">addl $0x4, %esp</span><br><span class="line">popfl</span><br><span class="line">// Switch back to the adjusted trap-time stack.</span><br><span class="line">// LAB 4: Your code here.</span><br><span class="line">popl %esp</span><br><span class="line">// Return to re-execute the instruction that faulted.</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><h4 id="Exercise-11"><a href="#Exercise-11" class="headerlink" title="Exercise 11"></a>Exercise 11</h4><blockquote><p>Finish <code>set_pgfault_handler()</code> in lib/pgfault.c.</p></blockquote><p>最后就简单了，为<code>用户异常栈</code>分配页，已经设置<code>upcall</code>调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">set_pgfault_handler(<span class="keyword">void</span> (*handler)(struct UTrapframe *utf)) &#123;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">if</span> (_pgfault_handler == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(sys_page_alloc(thisenv-&gt;env_id,</span><br><span class="line">                          (<span class="keyword">void</span> *) (UXSTACKTOP - PGSIZE), PTE_U|PTE_P|PTE_W) != <span class="number">0</span>)&#123;</span><br><span class="line">            panic(<span class="string">"set_pgfault_handler: sys_page_alloc failed"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sys_env_set_pgfault_upcall(thisenv-&gt;env_id, _pgfault_upcall) != <span class="number">0</span>)&#123;</span><br><span class="line">            panic(<span class="string">"set_pgfault_handler: sys_env_set_pgfault_upcall failed"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Save handler pointer for assembly to call.</span></span><br><span class="line">    _pgfault_handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个个过程非常<code>trick</code>，十分有趣。其实绕这么一大圈，最终的目的还是为了保护<code>kernel</code>！</p><h4 id="Exercise-12"><a href="#Exercise-12" class="headerlink" title="Exercise 12"></a>Exercise 12</h4><blockquote><p>Implement <code>fork</code>, <code>duppage</code> and <code>pgfault</code> in lib/fork.c.</p></blockquote><p>还没完。。。高潮才刚刚到来。前面搞了这么多，都只是为了实现<code>COW Fork</code>！。因为我门需要把<code>COW Fork</code>作为自定义函数库来实现。所以前面弄了这么多，只有一个目的，那就是在用户进程中<code>handle page fault</code>。</p><p>关与具体实现，其实<code>mit</code>的讲义上已经很清楚了。大致就是说把<code>UTOP</code>以下的地址都通过<code>duppage</code>进行映射到同一块物理地址上，当子进程发生缺页时，才通过<code>pgfault</code>来分配页。具体细节不赘述。</p><p>下面是代码。</p><p><code>fork</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">envid_t</span> fork(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="keyword">envid_t</span> envid;</span><br><span class="line">    <span class="keyword">uintptr_t</span> addr;</span><br><span class="line"></span><br><span class="line">    set_pgfault_handler(&amp;pgfault);</span><br><span class="line">    envid = sys_exofork();</span><br><span class="line">    <span class="keyword">if</span>(envid &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">"fork: sys_exofork failed"</span>);</span><br><span class="line">    <span class="keyword">if</span>(envid == <span class="number">0</span>)&#123;</span><br><span class="line">        thisenv = &amp;envs[ENVX(sys_getenvid())];</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (addr = <span class="number">0</span>; addr &lt; USTACKTOP; addr += PGSIZE) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((uvpd[PDX(addr)] &amp; PTE_P) &amp;&amp; (uvpt[PGNUM(addr)] &amp; PTE_P))</span><br><span class="line">            duppage(envid, PGNUM(addr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sys_page_alloc(envid, (<span class="keyword">void</span> *) (UXSTACKTOP - PGSIZE),</span><br><span class="line">                    PTE_P | PTE_U | PTE_W) &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">"fork: sys_page_alloc failed"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">void</span> _pgfault_upcall();</span><br><span class="line">    sys_env_set_pgfault_upcall(envid, _pgfault_upcall);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sys_env_set_status(envid, ENV_RUNNABLE) != <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">"fork: sys_env_set_status"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> envid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>duppage</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">duppage</span><span class="params">(<span class="keyword">envid_t</span> envid, <span class="keyword">unsigned</span> pn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">void</span> *addr = (<span class="keyword">void</span> *)(pn * PGSIZE);</span><br><span class="line">    <span class="keyword">if</span> ((uvpt[pn] &amp; PTE_W) || (uvpt[pn] &amp; PTE_COW)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, addr, envid, addr, PTE_P | PTE_U | PTE_COW)) &lt; <span class="number">0</span>)</span><br><span class="line">            panic(<span class="string">"duppage: %e"</span>, r);</span><br><span class="line">        <span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, addr, <span class="number">0</span>, addr, PTE_P | PTE_U | PTE_COW)) &lt; <span class="number">0</span>)</span><br><span class="line">            panic(<span class="string">"duppage: %e"</span>, r);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, addr, envid, addr, PTE_P | PTE_U)) &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">"duppage: %e"</span>, r);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>pafault</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">pgfault(struct UTrapframe *utf) &#123;</span><br><span class="line">    <span class="keyword">void</span> *addr = (<span class="keyword">void</span> *) utf-&gt;utf_fault_va;</span><br><span class="line">    <span class="keyword">uint32_t</span> err = utf-&gt;utf_err;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pte_t</span> pte = ((<span class="keyword">pte_t</span> *) uvpt)[PGNUM(addr)];</span><br><span class="line">    <span class="keyword">if</span>(!( (err &amp; FEC_WR) != <span class="number">0</span> &amp;&amp; (pte &amp; PTE_COW)!=<span class="number">0</span> ))&#123;</span><br><span class="line">        panic(<span class="string">"pgfault: not write and not a COW page"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addr = ROUNDDOWN(addr, PGSIZE);</span><br><span class="line">    <span class="keyword">envid_t</span> envid = sys_getenvid();</span><br><span class="line">    <span class="keyword">if</span> ((r = sys_page_alloc(envid, PFTEMP, PTE_P | PTE_U | PTE_W)) &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">"pgfault: %e"</span>, r);</span><br><span class="line">    <span class="built_in">memcpy</span>(PFTEMP, addr, PGSIZE);</span><br><span class="line">    <span class="keyword">if</span> ((r = sys_page_map(envid, PFTEMP, envid, addr, PTE_P | PTE_U | PTE_W)) &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">"pgfault: %e"</span>, r);</span><br><span class="line">    <span class="keyword">if</span> ((r = sys_page_unmap(envid, PFTEMP)) &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">"pgfault: %e"</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>精彩的<code>Part B</code>！</p><h2 id="Part-C"><a href="#Part-C" class="headerlink" title="Part C"></a>Part C</h2><p>实现基本的IPC通信，这部分代码还比较简单。</p><h4 id="Exercise-13"><a href="#Exercise-13" class="headerlink" title="Exercise 13"></a>Exercise 13</h4><blockquote><p>Modify kern/trapentry.S and kern/trap.c to initialize the appropriate entries in the IDT and provide handlers for IRQs 0 through 15. Then modify the code in<code>env_alloc()</code> in kern/env.c to ensure that user environments are always run with interrupts enabled.</p></blockquote><p>很简单，像之前注册中断门，这里需要参考<code>intel</code>手册注册相应的IPC门。代码略去。</p><p>完成之后，<code>Jos</code>就能进行时钟中断了。</p><h4 id="Exercise-14"><a href="#Exercise-14" class="headerlink" title="Exercise 14"></a>Exercise 14</h4><blockquote><p>Modify the kernel’s <code>trap_dispatch()</code> function so that it calls <code>sched_yield()</code> to find and run a different environment whenever a clock interrupt takes place.</p><p>You should now be able to get the user/spin test to work: the parent environment should fork off the child, <code>sys_yield()</code> to it a couple times but in each case regain control of the CPU after one time slice, and finally kill the child environment and terminate gracefully.</p></blockquote><p>处理时钟中断。防止进程死循环一直霸占<code>cpu</code>，所以需要在时钟中断处，重新调度进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (tf-&gt;tf_trapno == IRQ_OFFSET + IRQ_TIMER) &#123;</span><br><span class="line">       lapic_eoi();</span><br><span class="line">       sched_yield();</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="Exercise-15"><a href="#Exercise-15" class="headerlink" title="Exercise 15"></a>Exercise 15</h4><blockquote><p>Implement <code>sys_ipc_recv</code> and <code>sys_ipc_try_send</code> in kern/syscall.c. Read the comments on both before implementing them, since they have to work together. When you call <code>envid2env</code> in these routines, you should set the <code>checkperm</code> flag to 0, meaning that any environment is allowed to send IPC messages to any other environment, and the kernel does no special permission checking other than verifying that the target envid is valid.</p><p>Then implement the <code>ipc_recv</code> and <code>ipc_send</code> functions in lib/ipc.c.</p></blockquote><p>这几个函数都很好写，因为注释很详细！</p><p><code>sys_ipc_recv</code>，这里等待接受信息，只需要改变进程状态，直接调度就会阻塞了。我一开始没反应过来还弄了死循环。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_ipc_recv(<span class="keyword">void</span> *dstva) &#123;</span><br><span class="line">    <span class="keyword">if</span>(dstva &lt; (<span class="keyword">void</span> *)UTOP &amp;&amp; dstva != ROUNDDOWN(dstva, PGSIZE))&#123;</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    curenv-&gt;env_ipc_recving =<span class="literal">true</span>;</span><br><span class="line">    curenv-&gt;env_ipc_dstva = dstva;</span><br><span class="line">    curenv-&gt;env_status = ENV_NOT_RUNNABLE;</span><br><span class="line">    sys_yield();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sys_ipc_try_send</code>需要注意一点就是共享内存时，不能直接使用<code>sys_page_map</code>，因为<code>sys_page_map</code>查找<code>env</code>时会检查权限。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_ipc_try_send(<span class="keyword">envid_t</span> envid, <span class="keyword">uint32_t</span> value, <span class="keyword">void</span> *srcva, <span class="keyword">unsigned</span> perm) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line">    <span class="keyword">int</span> r = envid2env(envid, &amp;env, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> flag = PTE_U | PTE_P;</span><br><span class="line">    <span class="keyword">if</span>(r!=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    <span class="keyword">if</span>(!env-&gt;env_ipc_recving)</span><br><span class="line">        <span class="keyword">return</span> -E_IPC_NOT_RECV;</span><br><span class="line">    <span class="keyword">if</span>(srcva &lt; (<span class="keyword">void</span> *) UTOP)&#123;</span><br><span class="line">        <span class="keyword">if</span>(srcva != ROUNDUP(srcva, PGSIZE))</span><br><span class="line">            <span class="keyword">return</span> -E_INVAL;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">pte_t</span> *pte;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp</span> = <span class="title">page_lookup</span>(<span class="title">curenv</span>-&gt;<span class="title">env_pgdir</span>, <span class="title">srcva</span>, &amp;<span class="title">pte</span>);</span></span><br><span class="line">        <span class="keyword">if</span>(pp == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> -E_INVAL;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((!(perm &amp; (PTE_U | PTE_P))) ||</span><br><span class="line">            (perm &amp; (~(PTE_U | PTE_P | PTE_AVAIL | PTE_W))))</span><br><span class="line">            <span class="keyword">return</span> -E_INVAL;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((perm &amp; PTE_W) &amp;&amp; !(*pte &amp; PTE_W))</span><br><span class="line">            <span class="keyword">return</span> -E_INVAL;</span><br><span class="line"></span><br><span class="line">        r = page_insert(env-&gt;env_pgdir, pp, env-&gt;env_ipc_dstva, perm);</span><br><span class="line">        <span class="keyword">if</span>(r!=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    env-&gt;env_ipc_value = value;</span><br><span class="line">    env-&gt;env_ipc_recving = <span class="literal">false</span>;</span><br><span class="line">    env-&gt;env_ipc_from = curenv-&gt;env_id;</span><br><span class="line">    env-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line">    env-&gt;env_tf.tf_regs.reg_eax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是函数库的两个函数，是对上面两个系统调用的包装，让用户使用更为方便。没啥可说的，看代码把。</p><p><code>ipc_recv</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int32_t</span></span><br><span class="line">ipc_recv(<span class="keyword">envid_t</span> *from_env_store, <span class="keyword">void</span> *pg, <span class="keyword">int</span> *perm_store) &#123;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">if</span>(!pg)&#123;</span><br><span class="line">        pg = (<span class="keyword">void</span> *) <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    r = sys_ipc_recv(pg);</span><br><span class="line">    <span class="keyword">if</span>(r==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(from_env_store)</span><br><span class="line">            *from_env_store = thisenv-&gt;env_ipc_from;</span><br><span class="line">        <span class="keyword">if</span>(perm_store)</span><br><span class="line">            *perm_store = thisenv-&gt;env_ipc_perm;</span><br><span class="line">        <span class="keyword">return</span> thisenv-&gt;env_ipc_value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        *from_env_store = <span class="number">0</span>;</span><br><span class="line">        *perm_store = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ipc_send</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">ipc_send(<span class="keyword">envid_t</span> to_env, <span class="keyword">uint32_t</span> val, <span class="keyword">void</span> *pg, <span class="keyword">int</span> perm) &#123;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">if</span>(!pg)</span><br><span class="line">        pg = (<span class="keyword">void</span> *) <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        r = sys_ipc_try_send(to_env, val, pg, perm);</span><br><span class="line">        <span class="keyword">if</span>(r == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(r != -E_IPC_NOT_RECV)</span><br><span class="line">            panic(<span class="string">"ipc_send:%e"</span>, r);</span><br><span class="line">        sys_yield();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>lab4</code>完。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;lab4&lt;/code&gt;终于完成了。&lt;code&gt;lab4&lt;/code&gt;是到目前为止，比较复杂而且代码最多的&lt;code&gt;lab&lt;/code&gt;。总共需要完成三个部分。&lt;code&gt;part A&lt;/code&gt;添加多核支持，实现&lt;code&gt;RR&lt;/code&gt;调度。&lt;code&gt;part B&lt;/code&gt;实现&lt;code&gt;Copy-On-Write fork&lt;/code&gt;。&lt;code&gt;part C&lt;/code&gt; 实现时钟中断以及支持基本的&lt;code&gt;IPC&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;Part-A&quot;&gt;&lt;a href=&quot;#Part-A&quot; class=&quot;headerlink&quot; title=&quot;Part A&quot;&gt;&lt;/a&gt;Part A&lt;/h2&gt;&lt;h4 id=&quot;Exercise-1&quot;&gt;&lt;a href=&quot;#Exercise-1&quot; class=&quot;headerlink&quot; title=&quot;Exercise 1&quot;&gt;&lt;/a&gt;Exercise 1&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;Implement &lt;code&gt;mmio_map_region&lt;/code&gt; in kern/pmap.c. To see how this is used, look at the beginning of &lt;code&gt;lapic_init&lt;/code&gt; in kern/lapic.c. You’ll have to do the next exercise, too, before the tests for &lt;code&gt;mmio_map_region&lt;/code&gt; will run.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;实现需要让&lt;code&gt;Jos&lt;/code&gt;支持&lt;code&gt;symmetric multiprocessing&lt;/code&gt;，也就是所有的&lt;code&gt;cpu&lt;/code&gt;都拥有相同的权限去访问资源。&lt;code&gt;Jos&lt;/code&gt;使用&lt;code&gt;LAPIC&lt;/code&gt;来分发中断，以及通过它来知道当前使用的&lt;code&gt;cpu&lt;/code&gt;。而处理器访问&lt;code&gt;LAPIC&lt;/code&gt;，需要使用&lt;code&gt;MMIO&lt;/code&gt;。所以我们需要对&lt;code&gt;MMIO&lt;/code&gt;进行内存映射，这个函数比较简单。&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mmio_map_region(&lt;span class=&quot;keyword&quot;&gt;physaddr_t&lt;/span&gt; pa, &lt;span class=&quot;keyword&quot;&gt;size_t&lt;/span&gt; size) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;uintptr_t&lt;/span&gt; base = MMIOBASE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    size = ROUNDUP(size, PGSIZE);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(base + size &amp;gt; MMIOLIM)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        panic(&lt;span class=&quot;string&quot;&gt;&quot;mmio_map_region: reservation mem overflow&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    boot_map_region(kern_pgdir, base, size, pa, PTE_W | PTE_PCD | PTE_P);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;uintptr_t&lt;/span&gt; b = base;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    base += size;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *) b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Operating system" scheme="http://threezj.com/tags/Operating-system/"/>
    
      <category term="MIT 6.828" scheme="http://threezj.com/tags/MIT-6-828/"/>
    
  </entry>
  
  <entry>
    <title>MIT 6.828 lab3</title>
    <link href="http://threezj.com/2016/11/22/MIT%206.828%20lab3/"/>
    <id>http://threezj.com/2016/11/22/MIT 6.828 lab3/</id>
    <published>2016-11-22T15:03:06.000Z</published>
    <updated>2018-04-17T15:42:23.133Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这次<code>lab</code>的<code>Part A</code>让操作系统支持进程(单进程)，<code>Part B</code>处理了异常中断，使其能在<code>kernel态</code>和<code>用户态</code>进行切换。我觉得这次lab不算很难，可能是因为经过了前面两个lab洗礼的缘故。但还是在中断跳转那里卡了好一会，不会写汇编啊。</p><h2 id="Part-A"><a href="#Part-A" class="headerlink" title="Part A"></a>Part A</h2><p>在<code>Jos</code>中 我们用<code>Env</code>结构体来描述进程，关于Env，讲义中已经很清楚了，这里不赘述。关键点是通过<code>envs</code>数组和<code>env_free_list</code>来维护数组，这里需要注意的是<code>env_free_list</code>，不是像之前<code>free_page_list</code>那样是反向。这里需要和<code>envs</code>的顺序相同。</p><h4 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise 1"></a>Exercise 1</h4><blockquote><p>Modify <code>mem_init()</code> in kern/pmap.c to allocate and map the <code>envs</code> array. This array consists of exactly <code>NENV</code> instances of the <code>Env</code> structure allocated much like how you allocated the <code>pages</code> array. Also like the <code>pages</code> array, the memory backing <code>envs</code> should also be mapped user read-only at <code>UENVS</code> (defined in inc/memlayout.h) so user processes can read from this array.</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">envs = (struct Env *) boot_alloc(NENV * <span class="keyword">sizeof</span>(struct Env));</span><br><span class="line">boot_map_region(kern_pgdir, UENVS, PTSIZE, PADDR(envs), PTE_U);</span><br></pre></td></tr></table></figure><p>这个应该轻车熟路了，就是为<code>envs</code>分配内存，并开启虚拟映射。<br><a id="more"></a></p><h4 id="Exercise-2"><a href="#Exercise-2" class="headerlink" title="Exercise 2"></a>Exercise 2</h4><blockquote><p> In the file env.c, finish coding the following functions:</p><ul><li><code>env_init()</code><br>Initialize all of the <code>Env</code> structures in the <code>envs</code> array and add them to the <code>env_free_list</code>. Also calls <code>env_init_percpu</code>, which configures the segmentation hardware with separate segments for privilege level 0 (kernel) and privilege level 3 (user).</li><li><code>env_setup_vm()</code><br>Allocate a page directory for a new environment and initialize the kernel portion of the new environment’s address space.</li><li><code>region_alloc()</code><br>Allocates and maps physical memory for an environment</li><li><code>load_icode()</code><br>You will need to parse an ELF binary image, much like the boot loader already does, and load its contents into the user address space of a new environment.</li><li><code>env_create()</code><br>Allocate an environment with <code>env_alloc</code> and call <code>load_icode</code> to load an ELF binary into it.</li><li><code>env_run()</code><br>Start a given environment running in user mode.</li></ul></blockquote><p><code>env_init()</code> 初始化<code>envs</code>，并且连接<code>env_free_list</code>。和之前的<code>page_init</code>做法基本一样，除了顺序相反。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">env_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Set up envs array</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = NENV - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        envs[i].env_id = <span class="number">0</span>;</span><br><span class="line">        envs[i].env_status = ENV_FREE;</span><br><span class="line">        envs[i].env_link = env_free_list;</span><br><span class="line">        env_free_list = &amp;envs[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Per-CPU part of the initialization</span></span><br><span class="line">    env_init_percpu();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>env_setup_vm</code>为进程分配页目录，这里做法是<code>copy</code>了<code>kernel</code>的页目录。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">env_setup_vm</span><span class="params">(struct Env *e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">p</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate a page for the page directory</span></span><br><span class="line">    <span class="keyword">if</span> (!(p = page_alloc(ALLOC_ZERO)))</span><br><span class="line">        <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    e-&gt;env_pgdir = page2kva(p);</span><br><span class="line">    p-&gt;pp_ref++;</span><br><span class="line">    <span class="built_in">memcpy</span>(e-&gt;env_pgdir, kern_pgdir, PGSIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// UVPT maps the env's own page table read-only.</span></span><br><span class="line">    <span class="comment">// Permissions: kernel R, user R</span></span><br><span class="line">    e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) | PTE_P | PTE_U;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>region_alloc()</code>为用户空间分配页。类似于<code>lab2</code> 中的<code>boot_map_region</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">region_alloc(struct Env *e, <span class="keyword">void</span> *va, <span class="keyword">size_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> *<span class="keyword">va_t</span> = ROUNDDOWN(va, PGSIZE);</span><br><span class="line">    <span class="keyword">void</span> *end = ROUNDUP(va + len, PGSIZE);</span><br><span class="line">    <span class="keyword">for</span>(; <span class="keyword">va_t</span> &lt; end;<span class="keyword">va_t</span> += PGSIZE)&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp</span> = <span class="title">page_alloc</span>(1);</span></span><br><span class="line">        <span class="keyword">if</span>(pp == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            panic(<span class="string">"region_alloc:page alloc failed!\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        page_insert(e-&gt;env_pgdir, pp, <span class="keyword">va_t</span>, PTE_U | PTE_W);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>load_icode()</code>这个函数注释好多，一开始看了半天。其实说白了就是把<code>elf</code>程序加载到用户内存空间。正常来讲用户程序应该从磁盘上读取，但是目前<code>jos</code>还没有文件系统。<code>mit</code>直接链接了一些用户程序到kernel中。所以这里不需要读取，更加方便一点。具体我们可以参考<code>bootloader</code>的做法。因为需要对用户空间进行内存操作，这里需要用<code>lcr3()</code>切换页目录。最后需要注意的是设置进程的入口点为这个程序的入口点。最后的最后是为用户程序栈初始化分配一页。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">load_icode</span><span class="params">(struct Env *e, <span class="keyword">uint8_t</span> *binary)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Elf</span> *<span class="title">elf</span> = (<span class="title">struct</span> <span class="title">Elf</span> *) <span class="title">binary</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (elf-&gt;e_magic != ELF_MAGIC)</span><br><span class="line">        panic(<span class="string">"load_icode: not ELF executable."</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Proghdr</span> *<span class="title">ph</span> = (<span class="title">struct</span> <span class="title">Proghdr</span> *) (<span class="title">elf</span>-&gt;<span class="title">e_phoff</span> + <span class="title">binary</span>);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Proghdr</span> *<span class="title">eph</span> = <span class="title">ph</span> + <span class="title">elf</span>-&gt;<span class="title">e_phnum</span>;</span></span><br><span class="line">    lcr3(PADDR(e-&gt;env_pgdir));</span><br><span class="line">    <span class="keyword">for</span>(; ph &lt; eph; ph++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ph-&gt;p_type == ELF_PROG_LOAD)&#123;</span><br><span class="line">            region_alloc(e, (<span class="keyword">void</span> *) ph-&gt;p_va, ph-&gt;p_memsz);</span><br><span class="line">            <span class="built_in">memset</span>((<span class="keyword">void</span> *) ph-&gt;p_va, <span class="number">0</span>, ph-&gt;p_memsz);</span><br><span class="line">            <span class="built_in">memcpy</span>((<span class="keyword">void</span> *) ph-&gt;p_va, binary + ph-&gt;p_offset, ph-&gt;p_filesz);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    lcr3(PADDR(kern_pgdir));</span><br><span class="line">    e-&gt;env_tf.tf_eip = elf-&gt;e_entry;</span><br><span class="line">    region_alloc(e, (<span class="keyword">void</span> *) (USTACKTOP - PGSIZE), PGSIZE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>env_create</code>这个简单，综合前面的函数，先创建进程，然后加载用户程序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">env_create</span><span class="params">(<span class="keyword">uint8_t</span> *binary, <span class="keyword">enum</span> EnvType type)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">    env_alloc(&amp;e, <span class="number">0</span>);</span><br><span class="line">    load_icode(e, binary);</span><br><span class="line">    e-&gt;env_type = type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>env_run</code>运行进程。这个也比较简单，照着注释来就行。切换当前进程为新的进程。切换地址空间。最后调用<code>env_pop_tf</code>来保存现场，并且跳转到用户程序的入口点，不返回。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">env_run</span><span class="params">(struct Env *e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(curenv != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(curenv-&gt;env_status == ENV_RUNNING)</span><br><span class="line">            curenv-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line">    &#125;</span><br><span class="line">    curenv = e;</span><br><span class="line">    curenv-&gt;env_status = ENV_RUNNING;</span><br><span class="line">    curenv-&gt;env_runs ++;</span><br><span class="line">    lcr3(PADDR(e-&gt;env_pgdir));</span><br><span class="line">    env_pop_tf(&amp;e-&gt;env_tf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里进程建立完成，操作系统完成了从<code>kernel</code>切换到<code>用户态</code>，但是<code>hello world</code>，依旧运行不起来，因为目前操作系统无法处理中断。也就是说无法从<code>用户态</code>切换回<code>kernel</code>，当调用<code>printf</code>，会引起系统调用中断。</p><h4 id="中断、异常和系统调用"><a href="#中断、异常和系统调用" class="headerlink" title="中断、异常和系统调用"></a>中断、异常和系统调用</h4><p><code>中断、异常和系统调用</code>是用户程序或者外部设备和<code>kernel</code>进行交互的方式。比如说当敲击键盘时会产生中断，让操作系统知道这时候有字符可读。在比如用户程序运行时，发生错误，比如除0，无法运行下去，这会产生异常，让kernel来处理，系统调用就更不用说了，每时每刻都在发生，比如<code>printf</code>就是一个系统调用。这里说的<code>中断、异常和系统调用</code>，每一种都有些细微的不同，其实根据上述的例子就能看出来，中断是异步的，异常是同步的，系统调用同步异步都有可能。之后文章中说的中断，是广义上的中断，也就是一个统称，不细分为<code>中断、异常和系统调用</code>。操作系统用<code>int n</code>指令来说明中断产生，当中断产生时，操作系统会根据<code>中断向量表</code>，来索引<code>n</code>，然后跳到相应的处理函数。</p><p>此外这里还有一个叫做<code>TSS</code>的东西需要注意。就是用来保护现场的，从用户态切换到<code>kernel</code>的时候。</p><h4 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise 4"></a>Exercise 4</h4><p>这个<code>exercise</code>主要工作是建立<code>idt表</code>，以及注册相应的映射。在做这个之前，一定要仔细阅读 <code>Exercise 3</code>提的手册，务必弄清楚详细的中断机制。其实我觉得这里太偏硬件了，我更推荐看<code>CSAPP</code>关于异常那一章。</p><blockquote><p>Edit trapentry.S and trap.c and implement the features described above. The macros <code>TRAPHANDLER</code> and <code>TRAPHANDLER_NOEC</code> in trapentry.S should help you, as well as the T_* defines in inc/trap.h. You will need to add an entry point in trapentry.S (using those macros) for each trap defined in inc/trap.h, and you’ll have to provide<code>_alltraps</code> which the <code>TRAPHANDLER</code> macros refer to. You will also need to modify <code>trap_init()</code> to initialize the <code>idt</code> to point to each of these entry points defined in trapentry.S; the <code>SETGATE</code> macro will be helpful here.</p><p>Your <code>_alltraps</code> should:</p><ol><li>push values to make the stack look like a struct Trapframe</li><li>load <code>GD_KD</code> into %ds and %es</li><li><code>pushl %esp</code> to pass a pointer to the Trapframe as an argument to trap()</li><li><code>call trap</code> (can <code>trap</code> ever return?)</li></ol><p>Consider using the <code>pushal</code> instruction; it fits nicely with the layout of the <code>struct Trapframe</code>.</p></blockquote><p>首先在<code>trapentry.S</code>用预先定义的两个宏来定义中断。这个需要查看intel手册，因为有些中断需要压入错误码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">TRAPHANDLER_NOEC(t_divide, T_DIVIDE)</span><br><span class="line">TRAPHANDLER_NOEC(t_debug, T_DEBUG)</span><br><span class="line">TRAPHANDLER_NOEC(t_nmi, T_NMI)</span><br><span class="line">TRAPHANDLER_NOEC(t_brkpt, T_BRKPT)</span><br><span class="line">TRAPHANDLER_NOEC(t_oflow, T_OFLOW)</span><br><span class="line">TRAPHANDLER_NOEC(t_bound, T_BOUND)</span><br><span class="line">TRAPHANDLER_NOEC(t_illop, T_ILLOP)</span><br><span class="line">TRAPHANDLER_NOEC(t_device, T_DEVICE)</span><br><span class="line">TRAPHANDLER(t_dblflt, T_DBLFLT)</span><br><span class="line">TRAPHANDLER(t_tss, T_TSS)</span><br><span class="line">TRAPHANDLER(t_segnp, T_SEGNP)</span><br><span class="line">TRAPHANDLER(t_stack, T_STACK)</span><br><span class="line">TRAPHANDLER(t_gpflt, T_GPFLT)</span><br><span class="line">TRAPHANDLER(t_pgflt, T_PGFLT)</span><br><span class="line">TRAPHANDLER_NOEC(t_fperr, T_FPERR)</span><br><span class="line">TRAPHANDLER(t_align, T_ALIGN)</span><br><span class="line">TRAPHANDLER_NOEC(t_mchk, T_MCHK)</span><br><span class="line">TRAPHANDLER_NOEC(t_simderr, T_SIMDERR)</span><br><span class="line">TRAPHANDLER_NOEC(t_syscall, T_SYSCALL)</span><br><span class="line">TRAPHANDLER_NOEC(irq_timer, IRQ_OFFSET + IRQ_TIMER)</span><br><span class="line">TRAPHANDLER_NOEC(irq_kbd, IRQ_OFFSET + IRQ_KBD)</span><br><span class="line">TRAPHANDLER_NOEC(irq_serial, IRQ_OFFSET + IRQ_SERIAL)</span><br><span class="line">TRAPHANDLER_NOEC(irq_spurious, IRQ_OFFSET + IRQ_SPURIOUS)</span><br><span class="line">TRAPHANDLER_NOEC(irq_ide, IRQ_OFFSET + IRQ_IDE)</span><br><span class="line">TRAPHANDLER_NOEC(irq_error, IRQ_OFFSET + IRQ_ERROR)</span><br></pre></td></tr></table></figure><p>然后需要在<code>_alltraps</code> 设置好<code>trapframe</code>，最后调用<code>trap</code>来分发中断。这个按照注释和说明来做即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">_alltraps:</span><br><span class="line">    # Build trap frame.</span><br><span class="line">    pushl %ds</span><br><span class="line">    pushl %es</span><br><span class="line">    pushal</span><br><span class="line"></span><br><span class="line">    movw $(GD_KD), %ax</span><br><span class="line">    movw %ax, %ds</span><br><span class="line">    movw %ax, %es</span><br><span class="line"></span><br><span class="line">    pushl %esp</span><br><span class="line">    call trap</span><br></pre></td></tr></table></figure><p>最后在<code>idt_init()</code>设立<code>IDT表</code>，并设立相应的权限。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trap_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">Segdesc</span> <span class="title">gdt</span>[];</span></span><br><span class="line">    SETGATE(idt[T_DIVIDE], <span class="number">0</span>, GD_KT, t_divide, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_DEBUG], <span class="number">0</span>, GD_KT, t_debug, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_NMI], <span class="number">0</span>, GD_KT, t_nmi, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_BRKPT], <span class="number">0</span>, GD_KT, t_brkpt, <span class="number">3</span>);</span><br><span class="line">    SETGATE(idt[T_OFLOW], <span class="number">0</span>, GD_KT, t_oflow, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_BOUND], <span class="number">0</span>, GD_KT, t_bound, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_ILLOP], <span class="number">0</span>, GD_KT, t_illop, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_DEVICE], <span class="number">0</span>, GD_KT, t_device, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_DBLFLT], <span class="number">0</span>, GD_KT, t_dblflt, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_TSS], <span class="number">0</span>, GD_KT, t_tss, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_SEGNP], <span class="number">0</span>, GD_KT, t_segnp, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_STACK], <span class="number">0</span>, GD_KT, t_stack, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_GPFLT], <span class="number">0</span>, GD_KT, t_gpflt, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_PGFLT], <span class="number">0</span>, GD_KT, t_pgflt, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_FPERR], <span class="number">0</span>, GD_KT, t_fperr, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_ALIGN], <span class="number">0</span>, GD_KT, t_align, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_MCHK], <span class="number">0</span>, GD_KT, t_mchk, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_SIMDERR], <span class="number">0</span>, GD_KT, t_simderr, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_SYSCALL], <span class="number">0</span>, GD_KT, t_syscall, <span class="number">3</span>);</span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_TIMER], <span class="number">0</span>, GD_KT, irq_timer, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_KBD], <span class="number">0</span>, GD_KT, irq_kbd, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_SERIAL], <span class="number">0</span>, GD_KT, irq_serial, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_SPURIOUS], <span class="number">0</span>, GD_KT, irq_spurious, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_IDE], <span class="number">0</span>, GD_KT, irq_ide, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_ERROR], <span class="number">0</span>, GD_KT, irq_error, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// Per-CPU setup</span></span><br><span class="line">    trap_init_percpu();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Part-B"><a href="#Part-B" class="headerlink" title="Part B"></a>Part B</h2><h4 id="Exercise-5-amp-amp-Exercise-6"><a href="#Exercise-5-amp-amp-Exercise-6" class="headerlink" title="Exercise 5 &amp;&amp;  Exercise 6"></a>Exercise 5 &amp;&amp;  Exercise 6</h4><blockquote><p>Modify <code>trap_dispatch()</code> to dispatch page fault exceptions to <code>page_fault_handler()</code>. You should now be able to get make grade to succeed on the faultread,faultreadkernel, faultwrite, and faultwritekernel tests. If any of them don’t work, figure out why and fix them.</p></blockquote><blockquote><p> Modify <code>trap_dispatch()</code> to make breakpoint exceptions invoke the kernel monitor.</p></blockquote><p>这两个比较简单，我就放在一起了。就是单纯的分发中断处理。没什么好讲的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(tf-&gt;tf_trapno)&#123;</span><br><span class="line">       <span class="keyword">case</span> T_PGFLT:</span><br><span class="line">           page_fault_handler(tf);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       <span class="keyword">case</span> T_BRKPT:</span><br><span class="line">           monitor(tf);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="Exercise-7"><a href="#Exercise-7" class="headerlink" title="Exercise 7"></a>Exercise 7</h4><blockquote><p>Add a handler in the kernel for interrupt vector <code>T_SYSCALL</code>. You will have to edit kern/trapentry.S and kern/trap.c’s <code>trap_init()</code>. You also need to change<code>trap_dispatch()</code> to handle the system call interrupt by calling <code>syscall()</code> (defined in kern/syscall.c) with the appropriate arguments, and then arranging for the return value to be passed back to the user process in <code>%eax</code>. Finally, you need to implement <code>syscall()</code> in kern/syscall.c. Make sure <code>syscall()</code> returns <code>-E_INVAL</code> if the system call number is invalid. You should read and understand lib/syscall.c (especially the inline assembly routine) in order to confirm your understanding of the system call interface. Handle all the system calls listed in inc/syscall.h by invoking the corresponding kernel function for each call.</p></blockquote><p>添加系统调用处理。完成这个<code>exercise</code>。就能够完整的运行<code>hello world</code>了。之前建立<code>idt</code>表的时候，我已经设定好系统调用的映射了。所以这里直接处理<code>trap_dispatch()</code>就行。真正的<code>系统调用</code>触发在<code>/lib/syscall.c</code> 中，就是如下这条汇编语句</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">"int %1\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">             : <span class="string">"=a"</span> (ret)</span></span></span><br><span class="line">             : "i" (T_SYSCALL),</span><br><span class="line">               <span class="string">"a"</span> (num),</span><br><span class="line">               <span class="string">"d"</span> (a1),</span><br><span class="line">               <span class="string">"c"</span> (a2),</span><br><span class="line">               <span class="string">"b"</span> (a3),</span><br><span class="line">               <span class="string">"D"</span> (a4),</span><br><span class="line">               <span class="string">"S"</span> (a5)</span><br><span class="line">             : <span class="string">"cc"</span>, <span class="string">"memory"</span>);</span><br></pre></td></tr></table></figure><p><code>系统调用</code> 传入需要调用函数号，以及参数。所以当分发系统调用是，只要按照说明传入相应的参数，并且在<code>/kern/syscall.c</code>中按照函数号，分发下去即可。最后把返回值保存在<code>eax</code>中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> T_SYSCALL:</span><br><span class="line">           r = syscall(</span><br><span class="line">                   tf-&gt;tf_regs.reg_eax,</span><br><span class="line">                   tf-&gt;tf_regs.reg_edx,</span><br><span class="line">                   tf-&gt;tf_regs.reg_ecx,</span><br><span class="line">                   tf-&gt;tf_regs.reg_ebx,</span><br><span class="line">                   tf-&gt;tf_regs.reg_edi,</span><br><span class="line">                   tf-&gt;tf_regs.reg_esi);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123;</span><br><span class="line">               panic(<span class="string">"trap_dispatch: %e"</span>, r);</span><br><span class="line">           &#125;</span><br><span class="line">           tf-&gt;tf_regs.reg_eax = r;</span><br><span class="line">           <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><p><code>/kern/syscall.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int32_t</span></span><br><span class="line">syscall(<span class="keyword">uint32_t</span> syscallno, <span class="keyword">uint32_t</span> a1, <span class="keyword">uint32_t</span> a2, <span class="keyword">uint32_t</span> a3, <span class="keyword">uint32_t</span> a4, <span class="keyword">uint32_t</span> a5) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (syscallno) &#123;</span><br><span class="line">        <span class="keyword">case</span> SYS_cputs:</span><br><span class="line">            sys_cputs((<span class="keyword">const</span> <span class="keyword">char</span> *) a1,(<span class="keyword">size_t</span>) a2);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">case</span> SYS_cgetc:</span><br><span class="line">            <span class="keyword">return</span> sys_cgetc();</span><br><span class="line">        <span class="keyword">case</span> SYS_getenvid:</span><br><span class="line">            <span class="keyword">return</span> sys_getenvid();</span><br><span class="line">        <span class="keyword">case</span> SYS_env_destroy:</span><br><span class="line">            <span class="keyword">return</span> sys_env_destroy((<span class="keyword">envid_t</span>)a1);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Exercise-8"><a href="#Exercise-8" class="headerlink" title="Exercise 8"></a>Exercise 8</h4><blockquote><p>Add the required code to the user library, then boot your kernel. You should see user/hello print “hello, world” and then print “i am environment 00001000”.user/hello then attempts to “exit” by calling <code>sys_env_destroy()</code> (see lib/libmain.c and lib/exit.c). Since the kernel currently only supports one user environment, it should report that it has destroyed the only environment and then drop into the kernel monitor.</p></blockquote><p>这个也简单，即设置当前活动的进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thisenv = envs + ENVX(sys_getenvid ());</span><br></pre></td></tr></table></figure><h4 id="Exercise-9"><a href="#Exercise-9" class="headerlink" title="Exercise 9"></a>Exercise 9</h4><blockquote><p> Change <code>kern/trap.c</code> to panic if a page fault happens in kernel mode.</p><p>Hint: to determine whether a fault happened in user mode or in kernel mode, check the low bits of the <code>tf_cs</code>.</p><p>Read <code>user_mem_assert</code> in kern/pmap.c and implement <code>user_mem_check</code> in that same file.</p></blockquote><p>内存保护。这个也很清楚，照着说明来即可。主要就是检查标志位。用户程序不能访问<code>kernel</code>的内存。以及在kernel中<code>page fault</code>，需要特别报错。</p><p><code>/kern/trap.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//page_fault_handler</span></span><br><span class="line"><span class="keyword">if</span> (tf-&gt;tf_cs == GD_KT) &#123;</span><br><span class="line">       panic(<span class="string">"page_fault_handler: page fault in kernel mode"</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>‘/kern/pmap.c’  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">user_mem_check</span><span class="params">(struct Env *env, <span class="keyword">const</span> <span class="keyword">void</span> *va, <span class="keyword">size_t</span> len, <span class="keyword">int</span> perm)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *vat =(<span class="keyword">void</span> *) va;</span><br><span class="line">    <span class="keyword">void</span> *end =(<span class="keyword">void</span> *)va + len;</span><br><span class="line">    <span class="keyword">int</span> p = perm | PTE_P;</span><br><span class="line">    <span class="keyword">pte_t</span> *pte;</span><br><span class="line">    <span class="keyword">for</span> (; vat &lt; end; vat = ROUNDDOWN(vat+PGSIZE, PGSIZE)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">uint32_t</span>)vat &gt; ULIM) &#123;</span><br><span class="line">            user_mem_check_addr =(<span class="keyword">uintptr_t</span>) vat;</span><br><span class="line">            <span class="keyword">return</span> -E_FAULT;</span><br><span class="line">        &#125;</span><br><span class="line">        page_lookup(env-&gt;env_pgdir, vat, &amp;pte);</span><br><span class="line">        <span class="keyword">if</span> (!(pte &amp;&amp; ((*pte &amp; p) == p))) &#123;</span><br><span class="line">            user_mem_check_addr = (<span class="keyword">uintptr_t</span>) vat;</span><br><span class="line">            <span class="keyword">return</span> -E_FAULT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>/kern/syscall.c</code> 最后需要在<code>sys_cputs</code> 添加检查，因为只有这个调用访问到地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sys_cputs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Check that the user has permission to read memory [s, s+len).</span></span><br><span class="line">    <span class="comment">// Destroy the environment if not.</span></span><br><span class="line">    user_mem_assert(curenv, s, len, PTE_U | PTE_W);</span><br><span class="line">    <span class="comment">// Print the string supplied by the user.</span></span><br><span class="line">    cprintf(<span class="string">"%.*s"</span>, len, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此<code>lab3</code>结束</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这次&lt;code&gt;lab&lt;/code&gt;的&lt;code&gt;Part A&lt;/code&gt;让操作系统支持进程(单进程)，&lt;code&gt;Part B&lt;/code&gt;处理了异常中断，使其能在&lt;code&gt;kernel态&lt;/code&gt;和&lt;code&gt;用户态&lt;/code&gt;进行切换。我觉得这次lab不算很难，可能是因为经过了前面两个lab洗礼的缘故。但还是在中断跳转那里卡了好一会，不会写汇编啊。&lt;/p&gt;
&lt;h2 id=&quot;Part-A&quot;&gt;&lt;a href=&quot;#Part-A&quot; class=&quot;headerlink&quot; title=&quot;Part A&quot;&gt;&lt;/a&gt;Part A&lt;/h2&gt;&lt;p&gt;在&lt;code&gt;Jos&lt;/code&gt;中 我们用&lt;code&gt;Env&lt;/code&gt;结构体来描述进程，关于Env，讲义中已经很清楚了，这里不赘述。关键点是通过&lt;code&gt;envs&lt;/code&gt;数组和&lt;code&gt;env_free_list&lt;/code&gt;来维护数组，这里需要注意的是&lt;code&gt;env_free_list&lt;/code&gt;，不是像之前&lt;code&gt;free_page_list&lt;/code&gt;那样是反向。这里需要和&lt;code&gt;envs&lt;/code&gt;的顺序相同。&lt;/p&gt;
&lt;h4 id=&quot;Exercise-1&quot;&gt;&lt;a href=&quot;#Exercise-1&quot; class=&quot;headerlink&quot; title=&quot;Exercise 1&quot;&gt;&lt;/a&gt;Exercise 1&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;Modify &lt;code&gt;mem_init()&lt;/code&gt; in kern/pmap.c to allocate and map the &lt;code&gt;envs&lt;/code&gt; array. This array consists of exactly &lt;code&gt;NENV&lt;/code&gt; instances of the &lt;code&gt;Env&lt;/code&gt; structure allocated much like how you allocated the &lt;code&gt;pages&lt;/code&gt; array. Also like the &lt;code&gt;pages&lt;/code&gt; array, the memory backing &lt;code&gt;envs&lt;/code&gt; should also be mapped user read-only at &lt;code&gt;UENVS&lt;/code&gt; (defined in inc/memlayout.h) so user processes can read from this array.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;envs = (struct Env *) boot_alloc(NENV * &lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(struct Env));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;boot_map_region(kern_pgdir, UENVS, PTSIZE, PADDR(envs), PTE_U);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个应该轻车熟路了，就是为&lt;code&gt;envs&lt;/code&gt;分配内存，并开启虚拟映射。&lt;br&gt;
    
    </summary>
    
    
      <category term="Operating system" scheme="http://threezj.com/tags/Operating-system/"/>
    
      <category term="MIT 6.828" scheme="http://threezj.com/tags/MIT-6-828/"/>
    
  </entry>
  
  <entry>
    <title>MIT 6.828 lab2</title>
    <link href="http://threezj.com/2016/11/14/MIT%206.828%20lab2/"/>
    <id>http://threezj.com/2016/11/14/MIT 6.828 lab2/</id>
    <published>2016-11-14T15:55:06.000Z</published>
    <updated>2018-10-20T16:32:03.547Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这个<code>lab</code>主要是写内存管理相关的代码。实现操作系统必须满足三个要求<code>multiplexing, isolation, and interaction</code> 。翻译成中文就是<code>复用，隔离和相互作用</code>。这三个条件其实主要靠抽象完成。<code>复用</code> 比如<code>IO</code>读写，都对文件描述符进行处理，而不管底下是网络读写还是磁盘读写等。<code>隔离</code>抽象地址空间，每个进程拥有一个自己的地址空间，相互并不影响。<code>相互作用</code>也需要抽象的控制，防止一些恶意的软件。</p><p><code>lab2</code>关注点在于如何实现地址空间。<code>jos</code>通过实现分页管理来实现。操作系统中所有程序接触的地址都是虚拟地址，然后硬件上真正需要的则是物理地址，所以中间则是使用<code>MMU(memory management unit)</code>来把虚拟地址翻译为物理地址。</p><h2 id="连续的内存分配"><a href="#连续的内存分配" class="headerlink" title="连续的内存分配"></a>连续的内存分配</h2><p>早期操作系统都是直接操作物理地址，很明显，这样做有着致命的缺点。比如用户程序可以直接访问<code>kernel</code>地址，导致系统崩溃，多个用户程序程序直接相互影响。即使设立了保护机制，也就是通过一些<code>flag</code>来辨别是否可以访问，但还是会有问题。就是当两个进程同时载入内存时，会进行地址偏移，跳转到指令并不会是程序中原先的指令，此时需要进行<code>重定位</code>，就是扫描一遍程序，给程序中涉及到的地址加上偏移量。但是这种方法效率是很低的。需要为每个需要执行的程序进行扫描判定计算。</p><h4 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h4><p>所以这里我们提出了<code>地址空间</code>的概念。重点还是抽象。我门让每个进程处于独立的进程空间中。比如虽然两个进程都指向同一个虚拟地址，但是实际所指的物理地址是不同的。</p><h4 id="基地寄存器和界限寄存器"><a href="#基地寄存器和界限寄存器" class="headerlink" title="基地寄存器和界限寄存器"></a>基地寄存器和界限寄存器</h4><p>其实就是动态重定位。把重定位的时间推迟了，之前的重定位一般发生在加载时，而现在推迟到访问内存时，并且减少了扫描查找的时间。通过两个寄存器来保存进程的起始地址和进程使用空间的长度。当程序访问内存时，自动加上偏移量，如果超出界限，则产生错误。但这种方法还是不够快，需要进行计算，比较可以进行的很快，但计算不行。进行动态重定位之后地址称为<code>线性地址</code><br><a id="more"></a></p><h2 id="非连续的内存分配"><a href="#非连续的内存分配" class="headerlink" title="非连续的内存分配"></a>非连续的内存分配</h2><p>之前的内存分配，都是连续的，但是其实这种分法的内存利用效率很低。会产生很多的<code>内碎片</code>，<code>外碎片</code>，当你找不到足够大内存块时，还需要对内存进行整理。然后就有人提出了不连续的内存分配。把内存切开，分块保存。那么这时候，切多大的块又是一个问题。进而产生了两种方法<code>分段</code>和<code>分页</code>。</p><h4 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h4><p>分段的概念就是说，我们把进程的地址空间分成堆、栈、符号表、代码段等等。分成几个比较大的块，这几个块在物理内存中是可以不连续的。每个进程都有<code>段表</code>，<code>段表是</code>由操作系统建立的。虚拟地址分成两块，<code>段号</code>和<code>偏移量</code>，通过<code>段号</code>索引<code>段表</code>得到<code>基址</code>再加上<code>偏移量</code>，则为物理地址。段是可以动态生长的。</p><h4 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h4><p>虽然上述的<code>基地寄存器</code>和<code>界限寄存器</code>可以建立独立地址空间的抽象。但是依然有问题。现在软件越做越大，早就无法装下所有的进程了。当整个进程无法全部装入进程的时候，提出了一种更加灵活的方式，<code>虚拟内存</code>。主要思想是把进程的地址空间切成块，这些块无需全部都装到内存里，而是把一部分必要的装到内存中，而另外一些不是那么重要的装到硬盘中，直到进程需要的时候才调出来使用，大大节省内存空间。其实也是一种抽象，把磁盘的容量抽象成内存。我们用分页来实现<code>虚拟内存</code>。</p><h4 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h4><p><code>分页</code>意味当把进程切块的时候切的比<code>分段</code>要小，每一块则称为<code>页</code>。好现在我们有两个空间。<code>虚拟地址空间</code>以及<code>物理地址空间</code>。我们需要在这中间搭建一个桥梁，把虚拟地址翻译成物理地址，即<code>MMU</code>。<code>MMU</code>则是通过页表来索引得到地址的。</p><p>虚拟地址空间会比物理地址大的多，因为很多页并未分配到物理内存中，而是存在磁盘中，当需要那一页时才会调出来，替换最近使用次数最少的那一页。就好像<code>Cache</code>一样。可以把内存抽象成磁盘的一层<code>Cache</code>，以为读内存的速度比读硬盘的速度快的多。</p><p><img src="http://zhang.nos-eastchina1.126.net/blog/virtual-memory%5B1%5D.png" alt=""></p><h4 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h4><p>那么具体是如何翻译的？用<code>页表(page table)</code>的方式来索引。有点像<code>Hash table</code>。可以把<code>页表</code>看成一个大的数组。每个进程都有一个<code>页表</code>。<code>页表</code>的每一项叫做<code>页表项( page table entries)</code> 。<code>页表项</code>包含20位<code>physical page number (PPN)</code> 和剩下<code>12个标志位</code>来用作权限控制。下面是具体翻译的过程</p><ol><li>得到虚拟地址</li><li>截取虚拟地址的前<code>20位</code>作为索引</li><li>通过索引从页表中获取<code>页表项</code></li><li>把<code>页表项的前20位(PPN)</code>加上<code>虚拟地址的后12位(offset)</code>，则得到完整的物理地址。</li></ol><p>实际情况中，我们不可能只用一个表来存储所有的地址。因为页表中的大部分页表项都用不到，因为还未分配。所以采用多级页表的方式来存储。具体看下图，主要方式和上面相同，只不过多加了一层罢了。这样的话，如果<code>页目录</code>中某一项未分配的话，则不需要后面的<code>页表</code>了，大大节省空间。</p><p><img src="http://zhang.nos-eastchina1.126.net/blog/2016-11-14%2016-58-22%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p><p>以上就是分页实现方式。分页十分简洁明了的实现了操作系统的需求。比如说两个虚拟地址可以指向同一个物理地址，这就是<code>复用和交互</code>。还可以通过标志位来阻止进程访问别的进程，这就是<code>隔离</code>。</p><h2 id="lab2"><a href="#lab2" class="headerlink" title="lab2"></a>lab2</h2><p>前面是<code>lab2</code>所需的所有知识，当然我梳理的不是很细。非常具体的东西，大家还是看书为好。</p><h4 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise 1"></a>Exercise 1</h4><blockquote><p>In the file kern/pmap.c, you must implement code for the following functions (probably in the order given).</p><p><code>boot_alloc()</code><br><code>mem_init()</code> (only up to the call to <code>check_page_free_list(1)</code>)<br><code>page_init()</code><br><code>page_alloc()</code><br><code>page_free()</code></p></blockquote><p><code>boot_alloc()</code>在物理内存上为页目录以及页表的数据结构分配数据，只在<code>mem_init()</code>调用。真正的页面分配是用<code>page_alloc()</code>的。<code>boot_alloc()</code>是从<code>kernel</code>装载的结束位置开始分配的。代码如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">result = nextfree;</span><br><span class="line"><span class="keyword">if</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (PADDR(nextfree) + n &gt; (npages + <span class="number">1</span>) * PGSIZE) &#123;</span><br><span class="line">        panic(<span class="string">"out of memory\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    nextfree = ROUNDUP((<span class="keyword">char</span> *)nextfree + n, PGSIZE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure><p>写这个<code>lab</code>这个之前一定要弄清楚原理，不要什么都不懂就开始写了，这样只会无从下手。其实要写的代码都不难。</p><p><code>mem_init()</code> 望名知意，初始化内存。第一部分主要是分配<code>页目录</code>，以及追踪<code>页表</code>的数据结构。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pages = (struct PageInfo *) boot_alloc(npages * <span class="keyword">sizeof</span>(struct PageInfo));</span><br><span class="line"><span class="built_in">memset</span>(pages, <span class="number">0</span>, npages * <span class="keyword">sizeof</span>(struct PageInfo));</span><br></pre></td></tr></table></figure><p><code>page_init()</code> 按照注释的要求初始化<code>pages</code> 和<code>page_free_list</code>，这里比较要注意的是，这个链表是反向的。<code>pp_link</code>指向的是前一个<code>page</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">page_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> i, io_page_i, ext_page_i, free_top;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; npages; i++) &#123;</span><br><span class="line">        pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">        pages[i].pp_link = page_free_list;</span><br><span class="line">        page_free_list = &amp;pages[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pages[<span class="number">0</span>].pp_link = <span class="literal">NULL</span>;</span><br><span class="line">    pages[<span class="number">1</span>].pp_link = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    io_page_i = PGNUM(IOPHYSMEM);</span><br><span class="line">    ext_page_i = PGNUM(EXTPHYSMEM);</span><br><span class="line">    free_top = PGNUM(PADDR(boot_alloc(<span class="number">0</span>)));</span><br><span class="line"></span><br><span class="line">    pages[ext_page_i].pp_link = pages[io_page_i].pp_link;</span><br><span class="line">    <span class="keyword">for</span>(i = io_page_i;i &lt; ext_page_i;i++)</span><br><span class="line">        pages[i].pp_link = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    pages[free_top].pp_link = pages[ext_page_i].pp_link;</span><br><span class="line">    <span class="keyword">for</span> (i = ext_page_i; i &lt; free_top; i++)</span><br><span class="line">        pages[i].pp_link = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>page_alloc()</code> 分配页，这个也很简单。都是链表的基础操作。照着注释做就行了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct PageInfo * <span class="title">page_alloc</span><span class="params">(<span class="keyword">int</span> alloc_flags)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">p</span> = <span class="title">page_free_list</span>;</span></span><br><span class="line">    <span class="keyword">if</span>(p)&#123;</span><br><span class="line">        page_free_list = p-&gt;pp_link;</span><br><span class="line">        p-&gt;pp_link = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(alloc_flags &amp; ALLOC_ZERO)&#123;</span><br><span class="line">            <span class="built_in">memset</span>(page2kva(p), <span class="number">0</span>, PGSIZE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>page_free()</code> 释放页，把它添加回<code>free_list</code>中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">page_free</span><span class="params">(struct PageInfo *pp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pp-&gt;pp_ref != <span class="number">0</span> || pp-&gt;pp_link!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        panic(<span class="string">"pp-&gt;pp_ref is nonzero or pp-&gt;pp_link is not NULL\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pp-&gt;pp_link = page_free_list;</span><br><span class="line">    page_free_list = pp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise 4"></a>Exercise 4</h4><blockquote><p>Exercise 4. In the file kern/pmap.c, you must implement code for the following functions.</p><p><code>pgdir_walk()</code><br><code>boot_map_region()</code><br><code>page_lookup()</code><br><code>page_remove()</code><br><code>page_insert()</code></p></blockquote><p><code>pgdir_walk</code> 是个关键函数。这里需要你实现虚拟地址翻译到物理地址的过程，先从<code>页目录</code>中拿到<code>页表</code>的地址，然后再根据<code>页表</code>的索引获得<code>页表项</code>。这里是返回指向<code>页表项</code>的地址。注意这里返回的要是虚拟地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pte_t</span> * pgdir_walk(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">const</span> <span class="keyword">void</span> *va, <span class="keyword">int</span> create) &#123;</span><br><span class="line">    <span class="keyword">int</span> pdr_i = PDX(va);</span><br><span class="line">    <span class="keyword">pde_t</span> *pde = &amp;pgdir[pdr_i];</span><br><span class="line">    <span class="keyword">pte_t</span> *pgt;</span><br><span class="line">    <span class="keyword">if</span>(!(*pde &amp; PTE_P))&#123;</span><br><span class="line">        <span class="keyword">if</span>(!create)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">page</span> = <span class="title">page_alloc</span>(<span class="title">ALLOC_ZERO</span>);</span></span><br><span class="line">        <span class="keyword">if</span>(page == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        *pde = page2pa(page) | PTE_P | PTE_U | PTE_W;</span><br><span class="line">        page-&gt;pp_ref ++;</span><br><span class="line">    &#125;</span><br><span class="line">    pgt = KADDR(PTE_ADDR(*pde));</span><br><span class="line">    <span class="keyword">return</span> &amp;pgt[PTX(va)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>boot_map_region</code>这个函数无非就是映射的过程了，并设置权限。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">boot_map_region</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">uintptr_t</span> va, <span class="keyword">size_t</span> size, <span class="keyword">physaddr_t</span> pa, <span class="keyword">int</span> perm)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; (size / PGSIZE); i++, va += PGSIZE, pa+=PGSIZE)&#123;</span><br><span class="line">        <span class="keyword">pte_t</span>* pte = pgdir_walk(pgdir,(<span class="keyword">const</span> <span class="keyword">void</span> *) va, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(pte!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            *pte = pa|perm|PTE_P;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>page_lookup</code> 查找虚拟地址所对应的页</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct PageInfo * <span class="title">page_lookup</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">void</span> *va, <span class="keyword">pte_t</span> **pte_store)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pte_t</span> *pte = pgdir_walk(pgdir, va, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(pte == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pte_store!=<span class="literal">NULL</span>)  </span><br><span class="line">            *pte_store = pte;</span><br><span class="line">        <span class="keyword">return</span> pa2page(PTE_ADDR(*pte));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>page_remove</code> 删除对页的分配。<code>TLB</code>是<code>页表</code>之上又加了一层<code>cache</code>，所以这里也要删除记录</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">page_remove</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">void</span> *va)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pte_t</span> *pte;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp</span> = <span class="title">page_lookup</span>(<span class="title">pgdir</span>, <span class="title">va</span>, &amp;<span class="title">pte</span>);</span></span><br><span class="line">    <span class="keyword">if</span>(pp!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        page_decref(pp);</span><br><span class="line">        *pte = <span class="number">0</span>;</span><br><span class="line">        tlb_invalidate(pgdir, va);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>page_insert</code>分配页，若<code>页表</code>中已有数据，则需要删除。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">page_insert</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, struct PageInfo *pp, <span class="keyword">void</span> *va, <span class="keyword">int</span> perm)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pte_t</span> *pte = pgdir_walk(pgdir, va, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(pte)&#123;</span><br><span class="line">        pp-&gt;pp_ref ++;</span><br><span class="line">        <span class="keyword">if</span>(PTE_ADDR(*pte))</span><br><span class="line">            page_remove(pgdir, va);</span><br><span class="line">        *pte = page2pa(pp) | perm |PTE_P;</span><br><span class="line">        tlb_invalidate(pgdir, va);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Exercise-5"><a href="#Exercise-5" class="headerlink" title="Exercise 5"></a>Exercise 5</h4><p><strong>不保证答案的正确性，纯粹是自己的理解</strong></p><blockquote><p>Fill in the missing code in <code>mem_init()</code> after the call to <code>check_page()</code>.</p></blockquote><p>这个比较简单，按照注释说的来就行。用之前的<code>boot_map_region</code>来建立虚拟地址到物理地址的映射。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">boot_map_region(kern_pgdir, UPAGES, PTSIZE, PADDR(pages), PTE_U);</span><br><span class="line">boot_map_region(kern_pgdir, KSTACKTOP-KSTKSIZE, KSTKSIZE, PADDR(bootstack), PTE_W);</span><br><span class="line">boot_map_region(kern_pgdir, KERNBASE, <span class="number">0xffffffff</span> - KERNBASE, <span class="number">0</span>, PTE_W);</span><br></pre></td></tr></table></figure><blockquote><p>What entries (rows) in the page directory have been filled in at this point? What addresses do they map and where do they point? In other words, fill out this table as much as possible:</p></blockquote><table><thead><tr><th style="text-align:center">Entry</th><th style="text-align:center">Base Virtual Address</th><th style="text-align:left">Points to (logically):</th></tr></thead><tbody><tr><td style="text-align:center">1023</td><td style="text-align:center">0xFFC00000</td><td style="text-align:left">phys memory</td></tr><tr><td style="text-align:center">.</td><td style="text-align:center">?</td><td style="text-align:left">?</td></tr><tr><td style="text-align:center">960</td><td style="text-align:center">0xF0000000</td><td style="text-align:left">phys memory</td></tr><tr><td style="text-align:center">959</td><td style="text-align:center">0xEFC00000</td><td style="text-align:left">Kernel Stack</td></tr><tr><td style="text-align:center">958</td><td style="text-align:center">0xEF800000</td><td style="text-align:left">Memory-mapped I/O</td></tr><tr><td style="text-align:center">957</td><td style="text-align:center">0xEF400000</td><td style="text-align:left">page table</td></tr><tr><td style="text-align:center">956</td><td style="text-align:center">0xEF000000</td><td style="text-align:left">page structures</td></tr><tr><td style="text-align:center">.</td><td style="text-align:center">?</td><td style="text-align:left">?</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">0x00000000</td><td style="text-align:left">[see next question]</td></tr></tbody></table><blockquote><p>We have placed the kernel and user environment in the same address space. Why will user programs not be able to read or write the kernel’s memory? What specific mechanisms protect the kernel memory?</p></blockquote><p><code>页目录项</code>以及<code>页表项</code>，都有保留相应的<code>标志位</code>来确定此地址的权限。</p><blockquote><p>What is the maximum amount of physical memory that this operating system can support? Why?</p></blockquote><p>每个<code>PageInfo</code> 对应一个物理页也就是<code>2^12(4096)</code>字节。根据上面的映射，我们把所有<code>pages</code>放到到<code>UPAGES</code>之上，大小为<code>PTSIZE</code>。那么最大的可以支持的物理内存为<code>(PTSIZE/sizeof(PageInfo))*4096</code></p><blockquote><p>How much space overhead is there for managing memory, if we actually had the maximum amount of physical memory? How is this overhead broken down?</p></blockquote><p><code>页目录</code>4M，<code>页表</code>4M，<code>PageInfo</code> 4M ，总共12M。注意这里虽然<code>页目录</code>和<code>PageInfo</code>都不到4M，但操作系统还是预留了这么多。</p><blockquote><p>Revisit the page table setup in kern/entry.S and kern/entrypgdir.c. Immediately after we turn on paging, EIP is still a low number (a little over 1MB). At what point do we transition to running at an EIP above KERNBASE? What makes it possible for us to continue executing at a low EIP between when we enable paging and when we begin running at an EIP above KERNBASE? Why is this transition necessary?</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov $relocated, %eax</span><br><span class="line">jmp *%eax</span><br></pre></td></tr></table></figure><p>我汇编不熟。不太明白为什么要这么做。至于为什么能继续在低地址执行，是因为有映射到低地址。</p><p>为何是必须的？我也没弄清楚。照网上的答案是说，<code>kernel</code>需要获得更多的空间。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>《现代操作系统》<br>清华大学操作系统课</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这个&lt;code&gt;lab&lt;/code&gt;主要是写内存管理相关的代码。实现操作系统必须满足三个要求&lt;code&gt;multiplexing, isolation, and interaction&lt;/code&gt; 。翻译成中文就是&lt;code&gt;复用，隔离和相互作用&lt;/code&gt;。这三个条件其实主要靠抽象完成。&lt;code&gt;复用&lt;/code&gt; 比如&lt;code&gt;IO&lt;/code&gt;读写，都对文件描述符进行处理，而不管底下是网络读写还是磁盘读写等。&lt;code&gt;隔离&lt;/code&gt;抽象地址空间，每个进程拥有一个自己的地址空间，相互并不影响。&lt;code&gt;相互作用&lt;/code&gt;也需要抽象的控制，防止一些恶意的软件。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;lab2&lt;/code&gt;关注点在于如何实现地址空间。&lt;code&gt;jos&lt;/code&gt;通过实现分页管理来实现。操作系统中所有程序接触的地址都是虚拟地址，然后硬件上真正需要的则是物理地址，所以中间则是使用&lt;code&gt;MMU(memory management unit)&lt;/code&gt;来把虚拟地址翻译为物理地址。&lt;/p&gt;
&lt;h2 id=&quot;连续的内存分配&quot;&gt;&lt;a href=&quot;#连续的内存分配&quot; class=&quot;headerlink&quot; title=&quot;连续的内存分配&quot;&gt;&lt;/a&gt;连续的内存分配&lt;/h2&gt;&lt;p&gt;早期操作系统都是直接操作物理地址，很明显，这样做有着致命的缺点。比如用户程序可以直接访问&lt;code&gt;kernel&lt;/code&gt;地址，导致系统崩溃，多个用户程序程序直接相互影响。即使设立了保护机制，也就是通过一些&lt;code&gt;flag&lt;/code&gt;来辨别是否可以访问，但还是会有问题。就是当两个进程同时载入内存时，会进行地址偏移，跳转到指令并不会是程序中原先的指令，此时需要进行&lt;code&gt;重定位&lt;/code&gt;，就是扫描一遍程序，给程序中涉及到的地址加上偏移量。但是这种方法效率是很低的。需要为每个需要执行的程序进行扫描判定计算。&lt;/p&gt;
&lt;h4 id=&quot;地址空间&quot;&gt;&lt;a href=&quot;#地址空间&quot; class=&quot;headerlink&quot; title=&quot;地址空间&quot;&gt;&lt;/a&gt;地址空间&lt;/h4&gt;&lt;p&gt;所以这里我们提出了&lt;code&gt;地址空间&lt;/code&gt;的概念。重点还是抽象。我门让每个进程处于独立的进程空间中。比如虽然两个进程都指向同一个虚拟地址，但是实际所指的物理地址是不同的。&lt;/p&gt;
&lt;h4 id=&quot;基地寄存器和界限寄存器&quot;&gt;&lt;a href=&quot;#基地寄存器和界限寄存器&quot; class=&quot;headerlink&quot; title=&quot;基地寄存器和界限寄存器&quot;&gt;&lt;/a&gt;基地寄存器和界限寄存器&lt;/h4&gt;&lt;p&gt;其实就是动态重定位。把重定位的时间推迟了，之前的重定位一般发生在加载时，而现在推迟到访问内存时，并且减少了扫描查找的时间。通过两个寄存器来保存进程的起始地址和进程使用空间的长度。当程序访问内存时，自动加上偏移量，如果超出界限，则产生错误。但这种方法还是不够快，需要进行计算，比较可以进行的很快，但计算不行。进行动态重定位之后地址称为&lt;code&gt;线性地址&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Operating system" scheme="http://threezj.com/tags/Operating-system/"/>
    
      <category term="MIT 6.828" scheme="http://threezj.com/tags/MIT-6-828/"/>
    
  </entry>
  
  <entry>
    <title>MIT 6.828 lab1</title>
    <link href="http://threezj.com/2016/11/06/MIT%206.828%20lab1/"/>
    <id>http://threezj.com/2016/11/06/MIT 6.828 lab1/</id>
    <published>2016-11-06T07:50:06.000Z</published>
    <updated>2018-10-20T16:31:55.375Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>开启一场漫长且有趣的旅程，即日起开始学习<code>MIT 6.828</code>。总共有七个<code>lab</code>。<code>lab6</code>和<code>lab7</code>其中选一个做。</p><h2 id="PC启动流程简述"><a href="#PC启动流程简述" class="headerlink" title="PC启动流程简述"></a>PC启动流程简述</h2><p>先了解一下当<code>PC</code>加电后，整个物理地址空间分布。</p><p><img src="http://zhang.nos-eastchina1.126.net/blog/2016-11-03%2020-55-37%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p><p>早期的<code>16位</code>计算机是只有<code>1MB</code>的寻址能力。也就是说只能使用<code>0x0000 - 0xffff</code>这么多，如上图所示，<code>640kb</code>以下的部分为早期计算机使用的部分。而上面<code>640kb - 1mb</code>的这些地方则保留下来作为特殊使用，比如视频显示之类的。其中最重要的部分为<code>BIOS( Basic Input/Output System)</code>，<code>BIOS</code>的主要责任为进行一些自检，然后从启动设备中，并载入它的第一扇区到内存的特定位置，即<code>0x7c00</code>，然后跳转到这个位置继续执行。此时，<code>BIOS</code>的工作完成。<code>0x7c00</code> 即是<code>bootloader</code>的入口点。</p><p>当现代计算机突破了<code>1MB</code>内存，达到<code>4GB</code>甚至更多的时候，依然保留了最开始的<code>1M</code>内存空间。所以开始一开始加电以后，是处于实模式的，也就是只有<code>1MB</code>内存可以访问。<code>bootloader</code>会把实模式切换到保护模式。也就是<code>4GB</code>寻址模式。然后再读取<code>kernel</code>到内存中，并且把控制权转给<code>kernel</code>。至此操作系统才算真正的启动起来。</p><p>下面简单总结下启动流程。</p><ol><li><code>PC</code>启动，并且执行第一条指令，位于<code>0xffff0</code>。是一条跳转指令，跳到<code>BIOS</code>刚开始的地方</li><li><code>BIOS</code> 进行初始化。</li><li><code>BIOS</code>搜寻启动设备，并加载<code>bootloader</code>到内存中，转移控制给<code>bootloader</code></li><li><code>bootloader</code>从实模式切换到保护模式</li><li><code>bootloader</code>从硬盘中读取<code>kernel</code>到内存中，并转移控制给<code>kernel</code></li><li>操作系统启动<a id="more"></a></li></ol><h2 id="关于实模式和保护模式"><a href="#关于实模式和保护模式" class="headerlink" title="关于实模式和保护模式"></a>关于实模式和保护模式</h2><p>实模式即是当<code>PC</code>加电时，处于的模式，仅仅只有<code>16位</code>寻址能力。实模式将内存看成分段的区域。程序段和数据位于不同的区域。但是不区分<code>kernel</code>的操作还是用户的操作，也就是说每一个指针都指向实际的物理地址。很明显，这是致命的。可以通过修改<code>A20</code>地址线可以完成从实模式到保护模式的转换，具体如何转换我也不是很清楚，有兴趣的朋友自己研究。</p><p>在实模式下，地址如下翻译 <code>physical address = 16 * segment + offset</code>。目前你只需要知道在保护模式下，地址翻译与实模式下不同即可。</p><h2 id="Exercise"><a href="#Exercise" class="headerlink" title="Exercise"></a>Exercise</h2><h4 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise 3"></a>Exercise 3</h4><blockquote><p>At what point does the processor start executing 32-bit code? What exactly causes the switch from 16- to 32-bit mode?</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># Switch from real to protected mode, using a bootstrap GDT</span><br><span class="line"># and segment translation that makes virtual addresses</span><br><span class="line"># identical to their physical addresses, so that the</span><br><span class="line"># effective memory map does not change during the switch.</span><br><span class="line">lgdt    gdtdesc</span><br><span class="line">movl    %cr0, %eax</span><br><span class="line">orl     $CR0_PE_ON, %eax</span><br><span class="line">movl    %eax, %cr0</span><br><span class="line"></span><br><span class="line"># Jump to next instruction, but in 32-bit code segment.</span><br><span class="line"># Switches processor into 32-bit mode.</span><br><span class="line">ljmp    $PROT_MODE_CSEG, $protcseg</span><br></pre></td></tr></table></figure><p>不多解释，注释很清楚。</p><blockquote><p>What is the <em>last</em> instruction of the boot loader executed, and what is the <em>first</em> instruction of the kernel it just loaded?</p></blockquote><p><code>((void (*)(void)) (ELFHDR-&gt;e_entry))();</code> 根据<code>main.c</code> 的代码，这是最后一条代码。然后我们去看反汇编文件<code>boot.asm</code>。搜索上面那条代码，很清楚的可以看到最后一条指令如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// call the entry point from the ELF header</span><br><span class="line">// note: does not return!</span><br><span class="line">((void (*)(void)) (ELFHDR-&gt;e_entry))();</span><br><span class="line">7d6b:   ff 15 18 00 01 00       call   *0x10018</span><br></pre></td></tr></table></figure><p>第一条<code>kernel</code>执行的语句如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movw    $0x1234,0x472           # warm boot</span><br></pre></td></tr></table></figure><blockquote><p>Where is the first instruction of the kernel?</p></blockquote><p>让我困惑的是，当我实际<code>debug</code>的时候发现，并没有跳到<code>0x10018</code>去执行<code>kernel</code>，反而跳到了<code>0x10000c</code>。估计大概是由于内存映射之类的原因。故猜想<code>0x10018</code>可是是<code>c语言</code>的虚拟地址。</p><blockquote><p>How does the boot loader decide how many sectors it must read in order to fetch the entire kernel from disk? Where does it find this information?</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ph = (struct Proghdr *) ((<span class="keyword">uint8_t</span> *) ELFHDR + ELFHDR-&gt;e_phoff); <span class="comment">//e_phoff是header表的位置偏移</span></span><br><span class="line">eph = ph + ELFHDR-&gt;e_phnum;   <span class="comment">//e_phnum是header的数目</span></span><br><span class="line"><span class="keyword">for</span> (; ph &lt; eph; ph++)</span><br><span class="line">    <span class="comment">// p_pa is the load address of this segment (as well</span></span><br><span class="line">    <span class="comment">// as the physical address)</span></span><br><span class="line">    readseg(ph-&gt;p_pa, ph-&gt;p_memsz, ph-&gt;p_offset);</span><br></pre></td></tr></table></figure><p>注释很清楚了，也就是分别获取起始地址和结束地址，再来个循环，分块读取。</p><h4 id="Exercise-5"><a href="#Exercise-5" class="headerlink" title="Exercise 5"></a>Exercise 5</h4><p><code>ELF</code>二进制文件，文件开头是一唱串固定长度的<code>program header</code>，保存了程序所需要的各种<code>section</code>，比如<code>.text</code>保存了程序指令，<code>.data</code>则保存了已经初始化的静态变量，如<code>int x =0</code>。使用<code>objdump -h obj/kern/kernel</code>可查看段信息。其实特别需要注意<code>.text</code>段中的 <code>VMA</code> 和<code>LMA</code>列。分别代表链接地址<code>(link address)</code>和加载地址<code>(load address)</code>。 <code>VMA</code>指的是程序运行时的虚拟地址，而<code>LMA</code>则是程序真正载入到内存的时的物理地址。大部分时候这两个地址是一样的，但也有不同的时候。</p><p>这个练习就是修改一下<code>boot/Makefrag</code>中<code>-Ttext 0x7C00</code>的地址，让<code>bootloader</code>的<code>VMA</code>和<code>LMA</code>不一样。重新编译运行，程序会崩溃。</p><h4 id="Exercise-6"><a href="#Exercise-6" class="headerlink" title="Exercise 6"></a>Exercise 6</h4><blockquote><p>Examine the 8 words of memory at 0x00100000 at the point the BIOS enters the boot loader, and then again at the point the boot loader enters the kernel. Why are they different? What is there at the second breakpoint? (You do not really need to use QEMU to answer this question. Just think.)</p></blockquote><p>实验结果如下</p><p><img src="http://zhang.nos-eastchina1.126.net/blog/2016-11-04%2013-38-22%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p><p>当<code>bootloader</code> 运行之前<code>0x00100000</code>是空，运行完之后，被填充满了。猜想是<code>bootloader</code>把<code>kernel</code>填充到这里来了。查看代码，确实如此。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* AT(...) gives the load address of this section, which tells</span><br><span class="line">   the boot loader where to load the kernel in physical memory */</span><br><span class="line">.text : AT(0x100000) &#123;</span><br><span class="line">    *(.text .stub .text.* .gnu.linkonce.t.*)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Exercise-7"><a href="#Exercise-7" class="headerlink" title="Exercise 7"></a>Exercise 7</h4><blockquote><p>Use QEMU and GDB to trace into the JOS kernel and stop at the <code>movl %eax, %cr0</code>. Examine memory at 0x00100000 and at 0xf0100000. Now, single step over that instruction using the stepi GDB command. Again, examine memory at 0x00100000 and at 0xf0100000. Make sure you understand what just happened.</p><p>What is the first instruction <em>after</em> the new mapping is established that would fail to work properly if the mapping weren’t in place? Comment out the <code>movl %eax, %cr0</code> inkern/entry.S, trace into it, and see if you were right.</p></blockquote><p>实验结果如下</p><p><img src="http://zhang.nos-eastchina1.126.net/blog/2016-11-04%2014-10-16%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p><p>当运行<code>movl %eax, %cr0</code> 之后， 两个地址都指向了同一个地方也就是<code>0x00100000</code>，说明完成了地址映射。当我们把<code>movl %eax, %cr0</code> 注释掉之后，<code>os</code>启动崩溃，生成错误如下。</p><p><code>qemu: fatal: Trying to execute code outside RAM or ROM at 0xf010002c</code></p><h4 id="Exercise-8"><a href="#Exercise-8" class="headerlink" title="Exercise 8"></a>Exercise 8</h4><blockquote><p>We have omitted a small fragment of code - the code necessary to print octal numbers using patterns of the form “%o”. Find and fill in this code fragment.</p></blockquote><p>修改代码如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">'o'</span>:</span><br><span class="line">            <span class="comment">// Replace this with your code.</span></span><br><span class="line">            <span class="comment">//putch('X', putdat);</span></span><br><span class="line">            <span class="comment">//putch('X', putdat);</span></span><br><span class="line">            <span class="comment">//putch('X', putdat);</span></span><br><span class="line">            num = getuint(&amp;ap, lflag);</span><br><span class="line">            base = <span class="number">8</span>;</span><br><span class="line">            <span class="keyword">goto</span> number;</span><br></pre></td></tr></table></figure><p>回答下列问题</p><blockquote><p>Explain the interface between printf.c and console.c. Specifically, what function does console.c export? How is this function used by printf.c?</p></blockquote><p><code>printf.c</code>在其<code>putch()</code>函数中调用了<code>cputchar()</code> 。<code>console.c</code> 封装了一些与硬件接触的函数，如<code>getchar()</code>与<code>cputchar()</code>。</p><blockquote><p>Explain the following from console.c:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">1</span>      <span class="keyword">if</span> (crt_pos &gt;= CRT_SIZE) &#123;</span><br><span class="line">&gt; <span class="number">2</span>              <span class="keyword">int</span> i;</span><br><span class="line">&gt; <span class="number">3</span>              memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * <span class="keyword">sizeof</span>(<span class="keyword">uint16_t</span>));</span><br><span class="line">&gt; <span class="number">4</span>              <span class="keyword">for</span> (i = CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i++)</span><br><span class="line">&gt; <span class="number">5</span>                      crt_buf[i] = <span class="number">0x0700</span> | <span class="string">' '</span>;</span><br><span class="line">&gt; <span class="number">6</span>              crt_pos -= CRT_COLS;</span><br><span class="line">&gt; <span class="number">7</span>      &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>处理屏幕满了的情况。丢弃第一行。然后把后面的往上移。</p><blockquote><p>For the following questions you might wish to consult the notes for Lecture 2. These notes cover GCC’s calling convention on the x86.</p><p>Trace the execution of the following code step-by-step:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">int</span> x = <span class="number">1</span>, y = <span class="number">3</span>, z = <span class="number">4</span>;</span><br><span class="line">&gt; cprintf(<span class="string">"x %d, y %x, z %d\n"</span>, x, y, z);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><ul><li>In the call to <code>cprintf()</code>, to what does <code>fmt</code> point? To what does <code>ap</code> point?</li><li>List (in order of execution) each call to <code>cons_putc</code>, <code>va_arg</code>, and <code>vcprintf</code>. For <code>cons_putc</code>, list its argument as well. For <code>va_arg</code>, list what <code>ap</code> points to before and after the call. For <code>vcprintf</code> list the values of its two arguments.</li></ul></blockquote><p><code>fmt</code> 指向字符串 <code>$4 = 0xf0101b4e &quot;x %d, y %x, z %d\n&quot;</code> ，<code>ap</code> 则指向第二个参数的地址，即是<code>x</code>的地址。</p><p>接下来我们跟踪调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cprintf (fmt=<span class="number">0xf0101b4e</span> <span class="string">"x %d, y %x, z %d\n"</span>)</span><br><span class="line">vcprintf (fmt=<span class="number">0xf0101b4e</span> <span class="string">"x %d, y %x, z %d\n"</span>, ap=<span class="number">0xf010ff64</span> <span class="string">"\001"</span>)</span><br><span class="line">vprintfmt (putch=<span class="number">0xf01008cf</span> &lt;putch&gt;, putdat=<span class="number">0xf010ff2c</span>, fmt=<span class="number">0xf0101b4e</span> <span class="string">"x %d, y %x, z %d\n"</span>, ap=<span class="number">0xf010ff64</span> <span class="string">"\001"</span>)</span><br><span class="line">cons_putc (c=<span class="number">120</span>)</span><br></pre></td></tr></table></figure><p>当<code>va_arg</code>调用之后，<code>(va_list) 0xf010ff68 &quot;\003&quot;</code> 指向了第二个参数，也就是 <code>y</code>。</p><blockquote><p>Run the following code.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0x00646c72</span>;</span><br><span class="line">&gt; cprintf(<span class="string">"H%x Wo%s"</span>, <span class="number">57616</span>, &amp;i);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>What is the output? </p></blockquote><p>输出为<code>He110 World</code> 。比较简单，不多做解释。</p><blockquote><p>In the following code, what is going to be printed after <code>&#39;y=&#39;</code>? (note: the answer is not a specific value.) Why does this happen?</p><p>   <code>cprintf(&quot;x=%d y=%d&quot;, 3);</code></p></blockquote><p>输出为<code>x=3 y=-267380676</code>。因为只传入了一个参数，也就是<code>va_list</code>长度为一，当要输出第二个参数，<code>ap</code>处存放的是随机的数。</p><blockquote><p>Let’s say that GCC changed its calling convention so that it pushed arguments on the stack in declaration order, so that the last argument is pushed last. How would you have to change cprintf or its interface so that it would still be possible to pass it a variable number of arguments?</p></blockquote><p>既然要改变了入栈了，那么则要改变<code>va_arg</code>读取顺序。在网上找到一种方法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> va_arg(ap,t) \</span></span><br><span class="line">   (*(t *)((ap -= __va_size(t)) + __va_size(t)))</span><br></pre></td></tr></table></figure><h4 id="Exercise-9"><a href="#Exercise-9" class="headerlink" title="Exercise 9"></a>Exercise 9</h4><blockquote><p>Determine where the kernel initializes its stack, and exactly where in memory its stack is located. How does the kernel reserve space for its stack? And at which “end” of this reserved area is the stack pointer initialized to point to?</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">movl    $0x0,%ebp           # nuke frame pointer</span><br><span class="line">movl    $(bootstacktop),%esp # Set the stack pointer</span><br></pre></td></tr></table></figure><p><code>kern/entry.S</code> 中的上述代码设置了栈。根据反汇编文件可知，这个<code>bootstacktop</code>的地址为<code>0xf0110000</code> 。栈的预留靠<code>.space KSTKSIZE</code>实现。</p><h4 id="Exercise-10"><a href="#Exercise-10" class="headerlink" title="Exercise 10"></a>Exercise 10</h4><blockquote><p>To become familiar with the C calling conventions on the x86, find the address of the <code>test_backtrace</code> function in obj/kern/kernel.asm, set a breakpoint there, and examine what happens each time it gets called after the kernel starts. How many 32-bit words does each recursive nesting level of <code>test_backtrace</code> push on the stack, and what are those words?</p></blockquote><p>在 <code>obj/kern/kernel.asm</code> 中找到 函数的入口地址为<code>0xf0100040</code> 。接下来跟踪调试，查看每次<code>esp</code> 的变化。这里涉及到的是栈的知识，不多解释，最好的学习资料是<code>csapp</code>的<code>lab2</code>。</p><p>每调用一次<code>test_backtrace</code>。会发生如下事情。</p><ol><li>压入参数</li><li>压入返回地址，为下一行地址。</li><li>压入<code>ebp</code></li><li>更新<code>ebp</code>为<code>esp</code>的值，此时设立了函数的栈帧</li><li>压入<code>ebx</code> 用来保存临时变量之类的</li><li>扩大栈，也就是<code>esp</code>减去某个值<code>(栈是向下生长的)</code>，为函数分配空间</li></ol><p>通过<code>gdb</code>分析，每次调用会压入<code>8个字</code>。压入的内容就是我上面说的那些。</p><h4 id="Exercise-11"><a href="#Exercise-11" class="headerlink" title="Exercise 11"></a>Exercise 11</h4><blockquote><p> Implement the backtrace function as specified above</p></blockquote><p>通过上面的分析，此题不难。无非是用<code>read_ebp</code>获得<code>ebp</code>，然后就可获得所有需要的内容。</p><h4 id="Exercise-12"><a href="#Exercise-12" class="headerlink" title="Exercise 12"></a>Exercise 12</h4><blockquote><p>Modify your stack backtrace function to display, for each eip, the function name, source file name, and line number corresponding to that eip.</p></blockquote><p>此题关键是补全<code>debuginfo_eip</code>，实现查找行号。下面是我的实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stab_binsearch(stabs, &amp;lline, &amp;rline, N_SLINE, addr);</span><br><span class="line"><span class="keyword">if</span> (lline &gt; rline)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">info-&gt;eip_line = stabs[lline].n_desc;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上则是全部内容。具体代码在 <a href="https://github.com/threezj/mit6.828" target="_blank" rel="noopener">github:mit 6.828</a> 。看似短短的一个<code>lab1</code>，花费了大量的时间，确实不容易。虽然写的代码不多，但对操作系统启动的理解是很深入的。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://pdos.csail.mit.edu/6.828/2016/schedule.html" target="_blank" rel="noopener">mit 6.828 2016</a></p><p><a href="http://www.cnblogs.com/fatsheep9146/" target="_blank" rel="noopener">fatsheep9146的csdn博客</a></p><p><a href="https://github.com/valkjsaaa/PKU-OS-Labs" target="_blank" rel="noopener">valkjsaaa的github</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;开启一场漫长且有趣的旅程，即日起开始学习&lt;code&gt;MIT 6.828&lt;/code&gt;。总共有七个&lt;code&gt;lab&lt;/code&gt;。&lt;code&gt;lab6&lt;/code&gt;和&lt;code&gt;lab7&lt;/code&gt;其中选一个做。&lt;/p&gt;
&lt;h2 id=&quot;PC启动流程简述&quot;&gt;&lt;a href=&quot;#PC启动流程简述&quot; class=&quot;headerlink&quot; title=&quot;PC启动流程简述&quot;&gt;&lt;/a&gt;PC启动流程简述&lt;/h2&gt;&lt;p&gt;先了解一下当&lt;code&gt;PC&lt;/code&gt;加电后，整个物理地址空间分布。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhang.nos-eastchina1.126.net/blog/2016-11-03%2020-55-37%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;早期的&lt;code&gt;16位&lt;/code&gt;计算机是只有&lt;code&gt;1MB&lt;/code&gt;的寻址能力。也就是说只能使用&lt;code&gt;0x0000 - 0xffff&lt;/code&gt;这么多，如上图所示，&lt;code&gt;640kb&lt;/code&gt;以下的部分为早期计算机使用的部分。而上面&lt;code&gt;640kb - 1mb&lt;/code&gt;的这些地方则保留下来作为特殊使用，比如视频显示之类的。其中最重要的部分为&lt;code&gt;BIOS( Basic Input/Output System)&lt;/code&gt;，&lt;code&gt;BIOS&lt;/code&gt;的主要责任为进行一些自检，然后从启动设备中，并载入它的第一扇区到内存的特定位置，即&lt;code&gt;0x7c00&lt;/code&gt;，然后跳转到这个位置继续执行。此时，&lt;code&gt;BIOS&lt;/code&gt;的工作完成。&lt;code&gt;0x7c00&lt;/code&gt; 即是&lt;code&gt;bootloader&lt;/code&gt;的入口点。&lt;/p&gt;
&lt;p&gt;当现代计算机突破了&lt;code&gt;1MB&lt;/code&gt;内存，达到&lt;code&gt;4GB&lt;/code&gt;甚至更多的时候，依然保留了最开始的&lt;code&gt;1M&lt;/code&gt;内存空间。所以开始一开始加电以后，是处于实模式的，也就是只有&lt;code&gt;1MB&lt;/code&gt;内存可以访问。&lt;code&gt;bootloader&lt;/code&gt;会把实模式切换到保护模式。也就是&lt;code&gt;4GB&lt;/code&gt;寻址模式。然后再读取&lt;code&gt;kernel&lt;/code&gt;到内存中，并且把控制权转给&lt;code&gt;kernel&lt;/code&gt;。至此操作系统才算真正的启动起来。&lt;/p&gt;
&lt;p&gt;下面简单总结下启动流程。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;PC&lt;/code&gt;启动，并且执行第一条指令，位于&lt;code&gt;0xffff0&lt;/code&gt;。是一条跳转指令，跳到&lt;code&gt;BIOS&lt;/code&gt;刚开始的地方&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BIOS&lt;/code&gt; 进行初始化。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BIOS&lt;/code&gt;搜寻启动设备，并加载&lt;code&gt;bootloader&lt;/code&gt;到内存中，转移控制给&lt;code&gt;bootloader&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bootloader&lt;/code&gt;从实模式切换到保护模式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bootloader&lt;/code&gt;从硬盘中读取&lt;code&gt;kernel&lt;/code&gt;到内存中，并转移控制给&lt;code&gt;kernel&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;操作系统启动
    
    </summary>
    
    
      <category term="Operating system" scheme="http://threezj.com/tags/Operating-system/"/>
    
      <category term="MIT 6.828" scheme="http://threezj.com/tags/MIT-6-828/"/>
    
  </entry>
  
  <entry>
    <title>生成学习算法</title>
    <link href="http://threezj.com/2016/10/30/%E7%94%9F%E6%88%90%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/"/>
    <id>http://threezj.com/2016/10/30/生成学习算法/</id>
    <published>2016-10-30T13:21:06.000Z</published>
    <updated>2018-10-20T16:27:11.047Z</updated>
    
    <content type="html"><![CDATA[<h2 id="生成学习算法"><a href="#生成学习算法" class="headerlink" title="生成学习算法"></a>生成学习算法</h2><p>可能大部分人之前学过的分类算法，都是基于<code>train data</code>来最佳化参数，从而得到<code>data</code>的类别。也就是基于<code>p(y|x; θ)</code>来进行学习，比如<code>Logistic Regression</code>。现在我们换一种思路，反过来求解，分别对<code>p(x|y)</code> 求解，也就是说，对每一个<code>y</code>，<code>model</code>一个概率模型。当需要对新的<code>data</code>分类时，分别计算属于每个类的概率，从而得到最优的类别。公式基于贝叶斯定理,如下所示。</p><p><img src="http://zhang.nos-eastchina1.126.net/blog/2016-10-29%2023-45-27%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""><br><a id="more"></a></p><h2 id="高斯线性判别"><a href="#高斯线性判别" class="headerlink" title="高斯线性判别"></a>高斯线性判别</h2><p>这个算法前提是<code>p(x|y)</code> 是基于多变量正态分布。多变量正态分布模型如下。</p><p><img src="http://zhang.nos-eastchina1.126.net/blog/2016-10-29%2023-45-08%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p><p>现在因为只有两种情况，<code>y</code>属于伯努利分布，然后分别对两种情况来model 多变量正态分布</p><p><img src="http://zhang.nos-eastchina1.126.net/blog/2016-10-29%2023-44-52%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p><p>对所有样本的几率和取对数，进行最大似然估计。</p><p><img src="http://zhang.nos-eastchina1.126.net/blog/2016-10-29%2023-42-53%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p><p>好，现在我们共有四个参数<code>φ</code>,<code>Σ</code>, <code>μ0</code> ,<code>μ1</code> 。根据上面公式可分别求出四个参数。</p><p><img src="http://zhang.nos-eastchina1.126.net/blog/2016-10-29%2023-43-20%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p><p>到这里，高斯线性判别已经结束。我们分别对两个类型，进行拟合高斯模型。接下来需要分类的话，只需要对新的<code>data</code>分别用各自的高斯函数求解比较即可。具体的做法如下图。</p><p><img src="http://zhang.nos-eastchina1.126.net/blog/2016-10-29%2023-43-27%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p><h4 id="GDA与Logistics回归"><a href="#GDA与Logistics回归" class="headerlink" title="GDA与Logistics回归"></a>GDA与Logistics回归</h4><p>其实正好是一个相反的关系，当我们求解<code>p(y = 1|x;φ,μ0,μ1,Σ)</code>时，便是在求解Logistics回归，我们用上面的公式，并运用贝叶斯公式，即可得到Logistics回归的公式。</p><p>那么我们到底应该选用哪种算法？</p><p>大部分的情况下，Logistics回归的表现都会比GDA要好。因为GDA对数据分布模型依赖性很强。因为GDA的前提是<code>p(x|y)</code>是多变量正态分布的。当<code>p(x|y)</code>是多变量正态分布时，<code>p(y|x)</code>一定是Logistics回归的表现形式。然而反过来却不一定。也就是说GDA做了一个更强的假设。</p><h2 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h2><p>朴素贝叶斯也是属于生成学习算法的一种。既然是属于生成学习算法，那我们的目标只有一个。那就是计算<code>p(y|x)</code>的概率，选取最大的那一类。理论还是和之前一样，使用贝叶斯公式，反过来计算。此处有个问题，若x是多维的应该如何计算。这里有一个强假设，就是说每一个特征的概率与其他概率是不相关的。这就是<code>Naive Bayes (NB) assumption</code>，这在实际生活中，当然是不可能的，但是即使如此，贝叶斯分类的效果依然是很好的。</p><p><img src="http://zhang.nos-eastchina1.126.net/blog/2016-10-31%2020-40-54%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p><p>在上面的公式中，我们其实只有三个参数，我们分别用 <code>φi|y=1 = p(xi=1|y=1)</code>,<code>φi|y=0 = p(xi=1|y=0)</code>和 <code>φy = p(y=1)</code> 来表示。计算公式如下。</p><p><img src="http://zhang.nos-eastchina1.126.net/blog/2016-10-31%2020-40-44%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>下面给出一维的实现，多维其实一样的，只不过是把每一维都乘起来。粗粗一写，原谅不良的变量名，以及大量复制黏贴。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一维特征情况</span></span><br><span class="line">train_data = [ &#123;<span class="string">'Name'</span>:<span class="string">'Drew'</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'Name'</span>:<span class="string">'Claudia'</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'Name'</span>:<span class="string">'Drew'</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'Name'</span>:<span class="string">'Drew'</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'Name'</span>:<span class="string">'Alberto'</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'Name'</span>:<span class="string">'Karin'</span>&#125;, </span><br><span class="line">        &#123;<span class="string">'Name'</span>:<span class="string">'Nina'</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'Name'</span>:<span class="string">'Sergio'</span>&#125; ]</span><br><span class="line">train_label = [<span class="string">'Male'</span>,<span class="string">'Female'</span>,<span class="string">'Female'</span>,<span class="string">'Female'</span>,<span class="string">'Male'</span>,<span class="string">'Female'</span>,<span class="string">'Female'</span>,<span class="string">'Male'</span>]</span><br><span class="line">predict_data = [&#123;<span class="string">'Name'</span>:<span class="string">'Drew'</span>&#125;]</span><br><span class="line">predict_label = <span class="keyword">None</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多维特征的情况</span></span><br><span class="line"><span class="comment"># train_data = [ &#123;'Name':'Drew','Over170':'No','Eye':'Blue','Hair':'Short'&#125;,</span></span><br><span class="line"><span class="comment">#         &#123;'Name':'Claudia','Over170':'Yes','Eye':'Brown','Hair':'Long'&#125;,</span></span><br><span class="line"><span class="comment">#         &#123;'Name':'Drew','Over170':'No','Eye':'Blue','Hair':'Long'&#125;,</span></span><br><span class="line"><span class="comment">#         &#123;'Name':'Drew','Over170':'No','Eye':'Blue','Hair':'Long'&#125;,</span></span><br><span class="line"><span class="comment">#         &#123;'Name':'Alberto','Over170':'Yes','Eye':'Brown','Hair':'Short'&#125;,</span></span><br><span class="line"><span class="comment">#         &#123;'Name':'Karin','Over170':'No','Eye':'Blue','Hair':'Long'&#125;, </span></span><br><span class="line"><span class="comment">#         &#123;'Name':'Nina','Over170':'Yes','Eye':'Brown','Hair':'Short'&#125;,</span></span><br><span class="line"><span class="comment">#         &#123;'Name':'Sergio','Over170':'Yes','Eye':'Blue','Hair':'Long'&#125; ]</span></span><br><span class="line"><span class="comment"># train_label = ['Male','Female','Female','Female','Male','Female','Female','Male']</span></span><br><span class="line"><span class="comment"># predict_data = [&#123;'Name':'Drew','Over170':'Yes','Eye':'Blue','Hair':'Long'&#125;]</span></span><br><span class="line"><span class="comment"># predict_label = None;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(X, Y, predicted)</span>:</span></span><br><span class="line">    theta_y1 = <span class="number">0</span> <span class="comment"># φi|y=1</span></span><br><span class="line">    theta_y0 = <span class="number">0</span> <span class="comment"># φi|y=0</span></span><br><span class="line">    theta_y = <span class="number">0</span> <span class="comment"># φy</span></span><br><span class="line"></span><br><span class="line">    t1 = <span class="number">0</span></span><br><span class="line">    t2 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(X)):</span><br><span class="line">        <span class="keyword">if</span> X[i][<span class="string">'Name'</span>] == predict_data[<span class="number">0</span>][<span class="string">'Name'</span>] <span class="keyword">and</span> Y[i] == predicted:</span><br><span class="line">            t1 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> Y[i] == predicted:</span><br><span class="line">            t2 += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    theta_y1 = t1 / t2</span><br><span class="line"></span><br><span class="line">    t1 = <span class="number">0</span></span><br><span class="line">    t2 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(X)):</span><br><span class="line">        <span class="keyword">if</span> X[i][<span class="string">'Name'</span>] == predict_data[<span class="number">0</span>][<span class="string">'Name'</span>] <span class="keyword">and</span> Y[i] != predicted:</span><br><span class="line">            t1 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> Y[i] != predicted:</span><br><span class="line">            t2 += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    theta_y0 = t1 / t2</span><br><span class="line"></span><br><span class="line">    t1 = <span class="number">0</span></span><br><span class="line">    t2 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(X)):</span><br><span class="line">        <span class="keyword">if</span> Y[i] == predicted:</span><br><span class="line">            t1 += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    theta_y = t1 / len(X)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (theta_y1, theta_y0, theta_y)</span><br><span class="line"></span><br><span class="line">theta_y1, theta_y0, theta_y = predict(train_data, train_label, <span class="string">'Male'</span>)</span><br><span class="line"></span><br><span class="line">print(theta_y1 * theta_y / (theta_y1 * theta_y + theta_y0 * (<span class="number">1</span> - theta_y)))</span><br></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>CS229</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;生成学习算法&quot;&gt;&lt;a href=&quot;#生成学习算法&quot; class=&quot;headerlink&quot; title=&quot;生成学习算法&quot;&gt;&lt;/a&gt;生成学习算法&lt;/h2&gt;&lt;p&gt;可能大部分人之前学过的分类算法，都是基于&lt;code&gt;train data&lt;/code&gt;来最佳化参数，从而得到&lt;code&gt;data&lt;/code&gt;的类别。也就是基于&lt;code&gt;p(y|x; θ)&lt;/code&gt;来进行学习，比如&lt;code&gt;Logistic Regression&lt;/code&gt;。现在我们换一种思路，反过来求解，分别对&lt;code&gt;p(x|y)&lt;/code&gt; 求解，也就是说，对每一个&lt;code&gt;y&lt;/code&gt;，&lt;code&gt;model&lt;/code&gt;一个概率模型。当需要对新的&lt;code&gt;data&lt;/code&gt;分类时，分别计算属于每个类的概率，从而得到最优的类别。公式基于贝叶斯定理,如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhang.nos-eastchina1.126.net/blog/2016-10-29%2023-45-27%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Machine Learning" scheme="http://threezj.com/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>MIT 6.824 lab1</title>
    <link href="http://threezj.com/2016/09/27/MIT%206.824%20lab1/"/>
    <id>http://threezj.com/2016/09/27/MIT 6.824 lab1/</id>
    <published>2016-09-27T14:00:00.000Z</published>
    <updated>2018-04-17T15:43:53.383Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>花了几天功夫，断断续续做了下<code>lab1</code>。其实大部分时间都在看<code>Go</code>。非常非常简洁的一门语言。对并发的支持非常好。值得花时间学习。然而<code>MapReduce</code>并没想象的这么复杂。</p><h2 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h2><p>主要思想很简单。主要由<code>map</code>和<code>reduce</code>两个函数组成。(玩过函数式编程的朋友，对这两个函数应该很熟悉)，数据从<code>map</code>输入，输出一系列键值对，再由<code>reduce</code>把输出的键值对根据键组合在一起。当然最有趣的地方是，这些操作都是异步的，在多个机器上运行，所以非常快。</p><h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><ol><li>把数据分成<code>M</code>份，分别是<code>Mi</code></li><li>启动一个<code>master</code>对象，由它来控制如何分配调控</li><li><code>master</code>不断的挑出一个好的机器(<code>worker</code>)来对<code>Mi</code>进行执行<code>map</code>函数</li><li><code>map</code>函数返回一个 <code>key/value</code> 数组</li><li>然后把 <code>key/value</code> 数组分成<code>R</code>份存在本地，等待<code>Reduce</code>。当<code>map</code>全部完成后，每个<code>Mi</code>生<code>R</code>份结果。</li><li>从每个<code>Mi</code>中选择一份<code>Ri</code>。然后根据<code>Key</code>排序，把相同<code>Key</code>的<code>Value</code>合在一起，生成<code>key/list(value)</code></li><li>开始<code>reduce</code>，输入<code>list(value)</code>。</li><li>最后会生成<code>R</code>份文件</li></ol><p>最后的<code>R</code>份文件没必要直接合在一起。通常会把它们丢给下个<code>MapReduce</code></p><h2 id="lab"><a href="#lab" class="headerlink" title="lab"></a>lab</h2><p>总体来说不难。实现步骤全在<code>paper</code>中讲的很清楚了</p><ul><li><code>lab1</code> 完成两个函数<code>doMap</code>和<code>doReduce</code>。<code>doMap</code>就是完成上面<code>4,5</code>两个步骤.<code>doReduce</code>是上<br>面<code>7,8</code>两个步骤。注意这里不是异步，而是顺序执行</li><li><code>lab2</code> 实现<code>wordcount</code>，只要完成了<code>lab1</code>，<code>lab2</code>就是手到擒来的事情。</li><li><code>lab3</code> 略复杂一点。把上面<code>map</code>和<code>reduce</code>的操作变成异步。<code>Go</code>中有一个很有趣的东西，叫做<code>channel</code>可以起到很大帮助。类似于生产者消费者。这里不细讲。另外还需要一点<code>RPC</code>的知识。</li><li><code>lab4</code> 处理<code>worker</code>失败的情况。如果失败就让别的<code>worker</code>重新执行这个任务。</li></ul><p>具体代码放在<a href="https://github.com/threezj/mit-6.824" target="_blank" rel="noopener">mit-6.824</a></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://pdos.csail.mit.edu/6.824/papers/mapreduce.pdf" target="_blank" rel="noopener">MapReduce (2004)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;花了几天功夫，断断续续做了下&lt;code&gt;lab1&lt;/code&gt;。其实大部分时间都在看&lt;code&gt;Go&lt;/code&gt;。非常非常简洁的一门语言。
      
    
    </summary>
    
    
      <category term="Distributed Computing" scheme="http://threezj.com/tags/Distributed-Computing/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat 架构探索</title>
    <link href="http://threezj.com/2016/06/25/Tomcat%20%E6%9E%B6%E6%9E%84%E6%8E%A2%E7%B4%A2/"/>
    <id>http://threezj.com/2016/06/25/Tomcat 架构探索/</id>
    <published>2016-06-24T17:13:06.000Z</published>
    <updated>2018-04-17T15:38:50.504Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>花了一个礼拜的时间阅读了 <code>how tomcat works</code>，本文基于此书，整理了一下<code>Tomcat 5</code>的基本架构，其实也没什么多复杂的东西，无非是解析<code>Http</code>请求，然后调用相应的<code>Servlet</code>。另推荐看<code>CSAPP</code>的网络编程那一章</p><h2 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h2><p><code>Tomcat</code>由两个模块协同合作</p><ul><li><code>connector</code></li><li><code>container</code></li></ul><p><code>connector</code> 负责解析处理<code>HTTP</code>请求，比如说<code>请求头</code>,<code>查询字符串</code>,<code>请求参数</code>之类的。生成<code>HttpRequest</code>和<code>HttpResponse</code><br>之后交给<code>container</code>，由它负责调用相应的<code>Servlet</code>。<br><a id="more"></a></p><h2 id="Connector"><a href="#Connector" class="headerlink" title="Connector"></a>Connector</h2><p><code>Tomcat</code>默认的<code>Connector</code>为<code>HttpConnector</code>。作为<code>Connector</code>必须要实现<code>Connector</code>这个接口。</p><p><code>Tomcat</code>启动以后会开启一个线程，做一个死循环，通过<code>ServerSocket</code>来等待请求。一旦得到请求，生成<code>Socket</code>，注意这里<code>HttpConnector</code>并不会自己处理<code>Socket</code>，而是把它交给<code>HttpProcessor</code>。详细看下面代码，这里我只保留了关键代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Loop until we receive a shutdown command</span></span><br><span class="line">        <span class="keyword">while</span> (!stopped) &#123;</span><br><span class="line">            Socket socket = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket = serverSocket.accept(); <span class="comment">//等待链接</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (AccessControlException ace) &#123;</span><br><span class="line">                log(<span class="string">"socket accept security exception"</span>, ace);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Hand this socket off to an appropriate processor</span></span><br><span class="line">            HttpProcessor processor = createProcessor();</span><br><span class="line">            processor.assign(socket);  <span class="comment">//这里是立刻返回的</span></span><br><span class="line">            <span class="comment">// The processor will recycle itself when it finishes</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>注意一点，上面的<code>processor.assign(socket);</code>是立刻返回的，并不会阻塞在那里等待。因为Tomcat不可能一次只能处理一个请求，所以是异步的，每个<code>processor</code>处理都是一个单独的线程。</p><h4 id="HttpProcessor"><a href="#HttpProcessor" class="headerlink" title="HttpProcessor"></a>HttpProcessor</h4><p>上面的代码并没有显示调用<code>HttpProcessor</code>的<code>process</code>方法，那这个方法是怎么调用的呢？我们来看一下<code>HttpProcessor</code>的<code>run</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Process requests until we receive a shutdown signal</span></span><br><span class="line">        <span class="keyword">while</span> (!stopped) &#123;</span><br><span class="line">            <span class="comment">// Wait for the next socket to be assigned</span></span><br><span class="line">            Socket socket = await(); </span><br><span class="line">            <span class="keyword">if</span> (socket == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// Process the request from this socket</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                process(socket);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                log(<span class="string">"process.invoke"</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Finish up this request</span></span><br><span class="line">            connector.recycle(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们发现他是调用<code>await</code>方法来阻塞等待获得<code>socket</code>方法。而之前<code>Connector</code>是调用<code>assign</code>分配的，这是什么原因？<br>下面仔细看<code>await</code>和<code>assign</code>方法。这两个方法协同合作，当<code>assign</code>获取<code>socket</code>时会通知<code>await</code>然后返回<code>socket</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">assign</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Wait for the Processor to get the previous Socket</span></span><br><span class="line">    <span class="keyword">while</span> (available) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Store the newly available Socket and notify our thread</span></span><br><span class="line">    <span class="keyword">this</span>.socket = socket;</span><br><span class="line">    available = <span class="keyword">true</span>;</span><br><span class="line">    notifyAll();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> Socket <span class="title">await</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Wait for the Connector to provide a new Socket</span></span><br><span class="line">    <span class="keyword">while</span> (!available) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Notify the Connector that we have received this Socket</span></span><br><span class="line">    Socket socket = <span class="keyword">this</span>.socket;</span><br><span class="line">    available = <span class="keyword">false</span>;</span><br><span class="line">    notifyAll();</span><br><span class="line">    <span class="keyword">return</span> (socket);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>默认<code>available</code>为<code>false</code>。</p><p>接下来就是剩下的事情就是解析请求，填充<code>HttpRequest</code>和<code>HttpResponse</code>对象，然后交给<code>container</code>负责。<br>这里我不过多赘述如何解析<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//parse</span></span><br><span class="line">    ....</span><br><span class="line">    connector.getContainer().invoke(request, response);</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h2><blockquote><p>A Container is an object that can execute requests received from a client, and return responses based on those requests </p></blockquote><p><code>Container</code>是一个接口，实现了这个接口的类的实例，可以处理接收的请求，调用对应的<code>Servlet</code>。</p><p>总共有四类<code>Container</code>，这四个<code>Container</code>之间并不是平行关系，而是父子关系</p><ul><li><code>Engine</code> - 最顶层的容器，可以包含多个<code>Host</code></li><li><code>Host</code> - 代表一个虚拟主机，可以包含多个<code>Context</code></li><li><code>Context</code> - 代表一个<code>web应用</code>，也就是<code>ServletContext</code>，可以包含多个<code>Wrappers</code></li><li><code>Wrapper</code> - 代表一个<code>Servlet</code>,不能包含别的容器了，这是最底层</li></ul><h4 id="Container的调用"><a href="#Container的调用" class="headerlink" title="Container的调用"></a>Container的调用</h4><p>容器好比是一个加工厂，加工接受的<code>request</code>，加工方式和流水线也很像，但又有点区别。这里会用到一个叫做<code>Pipeline</code>的 东西，中文翻译为<code>管道</code>，<code>request</code>就放在管道里顺序加工，进行加工的工具叫做<code>Valve</code>，好比手术刀，<code>Pipeline</code>可添加多个<code>Valve</code>,最后加工的工具称为<code>BaseValve</code></p><p>上面可能讲的比较抽象，接下来我们来看代码。<code>Engine</code>是顶层容器，所以上面<code>invoke</code>，执行的就是<code>Engine</code>的方法。<code>StandardEngine</code>是<code>Engine</code>的默认实现，注意它也同时实现了<code>Pipeline</code>接口，且包含了<code>Pipeline</code>。</p><p>它的构造方法同时指定了<code>baseValve</code>,也就是管道最后一个调用的<code>Valve</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StandardEngine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    pipeline.setBasic(<span class="keyword">new</span> StandardEngineValve());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>好，接着我们看<code>invoke</code>,这个方法是继承自<code>ContainerBase</code>。只有一行，之间交给<code>pipeline</code>，进行加工。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Request request, Response response)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        pipeline.invoke(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面是<code>StandardPipeline</code>的<code>invoke</code>实现，也就是默认的<code>pipeline</code>实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Request request, Response response)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        <span class="comment">// Invoke the first Valve in this pipeline for this request</span></span><br><span class="line">        (<span class="keyword">new</span> StandardPipelineValveContext()).invokeNext(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>也只有一行！调用<code>StandardPipelineValveContext</code>的<code>invokeNext</code>方法，这是一个<code>pipeline</code>的内部类。让我们来看<br>具体代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invokeNext</span><span class="params">(Request request, Response response)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> subscript = stage;</span><br><span class="line">            stage = stage + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// Invoke the requested Valve for the current request thread</span></span><br><span class="line">            <span class="keyword">if</span> (subscript &lt; valves.length) &#123;</span><br><span class="line">                valves[subscript].invoke(request, response, <span class="keyword">this</span>);  <span class="comment">//加工</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((subscript == valves.length) &amp;&amp; (basic != <span class="keyword">null</span>)) &#123;</span><br><span class="line">                basic.invoke(request, response, <span class="keyword">this</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ServletException</span><br><span class="line">                    (sm.getString(<span class="string">"standardPipeline.noValve"</span>));</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>它调用了<code>pipeline</code>所用的<code>Valve</code>来对<code>request</code>做加工，当Valve执行完，会调用<code>BaseValve</code>,也就是上面的<code>StandardEngineValve</code>，<br>我们再来看看它的<code>invoke</code>方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Select the Host to be used for this Request</span></span><br><span class="line">StandardEngine engine = (StandardEngine) getContainer();</span><br><span class="line">Host host = (Host) engine.map(request, <span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">if</span> (host == <span class="keyword">null</span>) &#123;</span><br><span class="line">    ((HttpServletResponse) response.getResponse()).sendError</span><br><span class="line">        (HttpServletResponse.SC_BAD_REQUEST,</span><br><span class="line">            sm.getString(<span class="string">"standardEngine.noHost"</span>,</span><br><span class="line">                        request.getRequest().getServerName()));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Ask this Host to process this request</span></span><br><span class="line">host.invoke(request, response);</span><br></pre></td></tr></table></figure></p><p>它通过<code>(Host) engine.map(request, true);</code>获取所对应的<code>Host</code>,然后进入到下一层容器中继续执行。后面的执行顺序<br>和<code>Engine</code>相同，我不过多赘述</p><h4 id="执行顺序小结"><a href="#执行顺序小结" class="headerlink" title="执行顺序小结"></a>执行顺序小结</h4><p>经过一长串的<code>invoke</code>终于讲完了第一层容器的执行顺序。估计你们看的有点晕，我这里小结一下。</p><blockquote><p>Connector -&gt; HttpProcessor.process() -&gt; StandardEngine.invoke() -&gt; StandardPipeline.invoke() -&gt;<br>StandardPipelineValveContext.invokeNext() -&gt; valves.invoke() -&gt; StandardEngineValve.invoke() -&gt;<br>StandardHost.invoke()</p></blockquote><p>到这里位置<code>Engine</code>这一层结束。接下来进行<code>Host</code>，步骤完全一致</p><blockquote><p>StandardHost.invoke() -&gt; StandardPipeline.invoke() -&gt;<br>StandardPipelineValveContext.invokeNext() -&gt; valves.invoke() -&gt; StandardHostValve.invoke() -&gt;<br>StandardContext.invoke()</p></blockquote><p>然后再进行<code>Context</code>这一层的处理，到最后选择对应的<code>Wrapping</code>执行。</p><h2 id="Wrapper"><a href="#Wrapper" class="headerlink" title="Wrapper"></a>Wrapper</h2><p><code>Wrapper</code>相当于一个<code>Servlet</code>实例，<code>StandardContext</code>会更根据的<code>request</code>来选择对应的<code>Wrapper</code>调用。我们直接来看看<br><code>Wrapper</code>的<code>basevalve</code>是如果调用<code>Servlet</code>的<code>service</code>方法的。下面是<code>StandardWrapperValve</code>的<code>invoke</code>方法，我省略了很多，<br>只看关键。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Request request, Response response,</span></span></span><br><span class="line"><span class="function"><span class="params">                       ValveContext valveContext)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        <span class="comment">// Allocate a servlet instance to process this request</span></span><br><span class="line">        <span class="keyword">if</span> (!unavailable) &#123;</span><br><span class="line">            servlet = wrapper.allocate();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Create the filter chain for this request</span></span><br><span class="line">        ApplicationFilterChain filterChain =</span><br><span class="line">            createFilterChain(request, servlet);</span><br><span class="line">        <span class="comment">// Call the filter chain for this request</span></span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> This also calls the servlet's service() method</span></span><br><span class="line">        String jspFile = wrapper.getJspFile();  <span class="comment">//是否是jsp</span></span><br><span class="line">        <span class="keyword">if</span> (jspFile != <span class="keyword">null</span>)</span><br><span class="line">            sreq.setAttribute(Globals.JSP_FILE_ATTR, jspFile);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            sreq.removeAttribute(Globals.JSP_FILE_ATTR);</span><br><span class="line">        <span class="keyword">if</span> ((servlet != <span class="keyword">null</span>) &amp;&amp; (filterChain != <span class="keyword">null</span>)) &#123;</span><br><span class="line">            filterChain.doFilter(sreq, sres);</span><br><span class="line">        &#125;</span><br><span class="line">        sreq.removeAttribute(Globals.JSP_FILE_ATTR);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>首先调用<code>wrapper.allocate()</code>,这个方法很关键，它会通过<code>反射</code>找到对应<code>servlet</code>的<code>class</code>文件，构造出实例返回给我们。然后创建一个<code>FilterChain</code>，熟悉<code>j2ee</code>的各位应该对这个不陌生把？这就是我们在开发<code>web app</code>时使用的<code>filter</code>。然后就执行<code>doFilter</code>方法了，它又会调用<code>internalDoFilter</code>，我们来看这个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">internalDoFilter</span><span class="params">(ServletRequest request, ServletResponse response)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        <span class="comment">// Call the next filter if there is one</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.iterator.hasNext()) &#123;</span><br><span class="line">            ApplicationFilterConfig filterConfig =</span><br><span class="line">              (ApplicationFilterConfig) iterator.next();</span><br><span class="line">            Filter filter = <span class="keyword">null</span>;</span><br><span class="line">            </span><br><span class="line">            filter = filterConfig.getFilter();</span><br><span class="line">            filter.doFilter(request, response, <span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// We fell off the end of the chain -- call the servlet instance</span></span><br><span class="line">        <span class="keyword">if</span> ((request <span class="keyword">instanceof</span> HttpServletRequest) &amp;&amp;</span><br><span class="line">            (response <span class="keyword">instanceof</span> HttpServletResponse)) &#123;</span><br><span class="line">            servlet.service((HttpServletRequest) request,</span><br><span class="line">                            (HttpServletResponse) response);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            servlet.service(request, response);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>终于，在这个方法里看到了<code>service</code>方法，现在你知道在使用<code>filter</code>的时候如果不执行<code>doFilter</code>，<code>service</code>就不会执行的原因了把。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>Tomcat</code>的重要过程应该都在这里了，还值得一提的是<code>LifeCycle</code>接口，这里所有类几乎都实现了<code>LifeCycle</code>，<code>Tomcat</code>通过它来统一管理容器的生命流程，大量运用观察者模式。有兴趣的同学可以自己看书</p><h2 id="Referance"><a href="#Referance" class="headerlink" title="Referance"></a>Referance</h2><p><code>How Tomcat works</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;花了一个礼拜的时间阅读了 &lt;code&gt;how tomcat works&lt;/code&gt;，本文基于此书，整理了一下&lt;code&gt;Tomcat 5&lt;/code&gt;的基本架构，其实也没什么多复杂的东西，无非是解析&lt;code&gt;Http&lt;/code&gt;请求，然后调用相应的&lt;code&gt;Servlet&lt;/code&gt;。另推荐看&lt;code&gt;CSAPP&lt;/code&gt;的网络编程那一章&lt;/p&gt;
&lt;h2 id=&quot;基本架构&quot;&gt;&lt;a href=&quot;#基本架构&quot; class=&quot;headerlink&quot; title=&quot;基本架构&quot;&gt;&lt;/a&gt;基本架构&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Tomcat&lt;/code&gt;由两个模块协同合作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;connector&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;container&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;connector&lt;/code&gt; 负责解析处理&lt;code&gt;HTTP&lt;/code&gt;请求，比如说&lt;code&gt;请求头&lt;/code&gt;,&lt;code&gt;查询字符串&lt;/code&gt;,&lt;code&gt;请求参数&lt;/code&gt;之类的。生成&lt;code&gt;HttpRequest&lt;/code&gt;和&lt;code&gt;HttpResponse&lt;/code&gt;&lt;br&gt;之后交给&lt;code&gt;container&lt;/code&gt;，由它负责调用相应的&lt;code&gt;Servlet&lt;/code&gt;。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://threezj.com/tags/Java/"/>
    
      <category term="Tomcat" scheme="http://threezj.com/tags/Tomcat/"/>
    
  </entry>
  
</feed>
