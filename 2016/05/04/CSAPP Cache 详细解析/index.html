<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> CSAPP Cache 详细解析 · 一派胡言</title><meta name="description" content="CSAPP Cache 详细解析 - Jian Zhang"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://threezj.com/atom.xml" title="一派胡言"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="https://github.com/zyycj" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">CSAPP Cache 详细解析</h1><div class="post-info">2016年5月4日</div><div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>又要来推荐<code>CSAPP</code>这本书啦。很多同学可能写了这么久代码，计算机的基本工作方式都不太懂，看这本书会给你一种融会贯通的感觉，小到二进制位级操作，大到手撸web服务器。</p>
<p>今天主要整理下<code>Cache</code>的运行机制。</p>
<h2 id="什么是Cache"><a href="#什么是Cache" class="headerlink" title="什么是Cache"></a>什么是<code>Cache</code></h2><p>编程说到底其实就是对数据的操作。<code>CPU</code>通过各种总线从读取数据，放入<code>ALU(运算器)</code>进行运算，然后再把数据放回主存中。下面是一个简单的示意图。</p>
<p><img src="http://zhang.nos-eastchina1.126.net/blog/QQ%E6%88%AA%E5%9C%9620160503224541.jpg" alt=""></p>
<p>很明显。数据运输过程的时间，就是性能的提现。没有数据<code>CPU</code>只能在那里等待.所以为了加快主存到<code>CPU</code>的速度，系统设计者采取了存储设备分层的结构.</p>
<p><code>Cache</code>又称为<code>高速缓存存储器</code>，是一种非常小非常快的存储器，同时也非常贵，放在<code>CPU</code>和<code>主存</code>之间，相当于中介的存在，每当<code>CPU</code>取数据的时候总是先从<code>Cache</code>中找，如果<code>Cache</code>没有，再到<code>主存</code>找。</p>
<p><code>CPU</code>和<code>主存</code>直接会放置多个<code>Cache</code>，越靠近<code>CPU</code>则越小越快越贵。</p>
<p><img src="http://zhang.nos-eastchina1.126.net/blog/QQ%E6%88%AA%E5%9C%9620160503230817.jpg" alt=""><br><a id="more"></a></p>
<h2 id="局部性"><a href="#局部性" class="headerlink" title="局部性"></a>局部性</h2><p>程序一般使用数据，都倾向于使用地址靠近的数据，或者是最近刚刚使用过的数据。回想下你之前写的程序是不是这样。比如说数组，一整块连续的地址循环访问。不断访问同一个数据去做求和之类的操作。所以分为如下</p>
<ul>
<li>时间局部性</li>
<li>空间局部性</li>
</ul>
<h2 id="Cache工作原理"><a href="#Cache工作原理" class="headerlink" title="Cache工作原理"></a>Cache工作原理</h2><p>查找<code>Cache</code>中数据时，找到了称为<code>Hit</code>,没找到则称为<code>Miss</code></p>
<h4 id="Cache-Miss-Type"><a href="#Cache-Miss-Type" class="headerlink" title="Cache Miss Type"></a>Cache Miss Type</h4><p><code>Miss</code>的情况分为三种</p>
<ul>
<li><code>Cold Miss</code>.也就是第一次找的时候，<code>Cache</code>不含数据，当然是<code>Miss</code></li>
<li><code>Conflict Miss</code>.比较有意思的一种的情况。比如说第一次查找数据<code>0</code>，第一次时不含数据属于<code>Cold Miss</code>，然后就去主存中找，放到<code>Cache</code>中，第二次查找需要数据<code>8</code>，又没有，继续去主存那里找，注意！，<code>8</code>把放到<code>Cache</code>中时覆盖了<code>0</code>，第三次你又需要<code>0</code>了，然后就悲剧了，不断<code>0,8,0,8,0,8,0,8 Miss</code>,当然这里涉及到一个写策略。</li>
<li><code>Capacity Miss</code>.这种也比较容易理解，就是你需要的数据超过<code>Cache</code>的大小了，当然<code>Miss</code>了</li>
</ul>
<h4 id="Cache-Replacement-Policies-Cache替换策略"><a href="#Cache-Replacement-Policies-Cache替换策略" class="headerlink" title="Cache Replacement Policies(Cache替换策略)"></a>Cache Replacement Policies(Cache替换策略)</h4><ul>
<li><code>Random</code>  随机替换</li>
<li><code>LRU</code>     <code>Least Recently Used</code>，替换最近最少使用的数据</li>
<li><code>FIFO</code>    这个应该很熟悉先进先出法。先保存的数据先出去</li>
</ul>
<h4 id="Cache-查找原理"><a href="#Cache-查找原理" class="headerlink" title="Cache 查找原理"></a>Cache 查找原理</h4><p>了解查找之前先要知道<code>Cache</code>的组成结构，总共分为两块。</p>
<ul>
<li><code>set</code></li>
<li><code>line</code></li>
</ul>
<p>一块Cache，有多个<code>set</code>，一个<code>set</code>有多行<code>line</code>.</p>
<p><code>set</code>个数取决于你是几位的机器，因为查找数据的时候是根据地址来区分是哪个<code>set</code>的。</p>
<p><code>line</code>中又分成三块。</p>
<ul>
<li><code>valid bit</code>  标志位，标志这块数据是否有效</li>
<li><code>tag</code>        相当于身份证，只有部分地址和这个<code>tag</code>对上以后，才能继续访问<code>block</code></li>
<li><code>block</code>      数据真正存放的地方</li>
</ul>
<p>那么地址又是如何划分的呢？也是分成三块</p>
<ul>
<li><code>tag</code>            对应前面’line’的’tag’</li>
<li><code>set index</code>      用来查找属于哪个’set’</li>
<li><code>block offset</code>   块偏移量确定数据的位置</li>
</ul>
<p>我这么讲可能比较抽象，直接看下图，再对照着看上面的文字，应该比较容易理解。</p>
<p><img src="http://zhang.nos-eastchina1.126.net/blog/QQ%E6%88%AA%E5%9C%9620160503235056.jpg" alt=""></p>
<p>所以<code>Cache</code>的查找过程是怎么样的呢？</p>
<ol>
<li>根据<code>set index</code>找到属于哪个<code>set</code></li>
<li>查找<code>set</code>中的每一行<code>line</code></li>
<li>先看<code>valid bit</code>是否有效</li>
<li>接着比对<code>tag</code></li>
<li>根据<code>block offset</code>获取数据</li>
</ol>
<h2 id="回写策略"><a href="#回写策略" class="headerlink" title="回写策略"></a>回写策略</h2><p>回写指的是，保持数据一致性，需要写回到主存中，这也很好理解，不回写的话数据就不同步了。</p>
<ul>
<li><code>Write-through</code> 直接把数据写回到主存中</li>
<li><code>Write-back</code>    直到数据在<code>Cache</code>中要被覆盖了再写回到主存中</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>CSAPP<br>CMU 15213<br>维基百科</p>
</div></article></div></main><footer><div class="paginator"><a href="/2016/06/25/Tomcat 架构探索/" class="prev">上一篇</a><a href="/2016/05/02/最短路径算法总结/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'seansun';
var disqus_identifier = '2016/05/04/CSAPP Cache 详细解析/';
var disqus_title = 'CSAPP Cache 详细解析';
var disqus_url = 'http://threezj.com/2016/05/04/CSAPP Cache 详细解析/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//seansun.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2018 <a href="http://threezj.com">Jian Zhang</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>