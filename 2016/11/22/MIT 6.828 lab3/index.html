<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>MIT 6.828 lab3 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="前言这次lab的Part A让操作系统支持进程(单进程)，Part B处理了异常中断，使其能在kernel态和用户态进行切换。我觉得这次lab不算很难，可能是因为经过了前面两个lab洗礼的缘故。但还是在中断跳转那里卡了好一会，不会写汇编啊。 Part A在Jos中 我们用Env结构体来描述进程，关于Env，讲义中已经很清楚了，这里不赘述。关键点是通过envs数组和env_free_list来维护数">
<meta name="keywords" content="Operating system,MIT 6.828">
<meta property="og:type" content="article">
<meta property="og:title" content="MIT 6.828 lab3">
<meta property="og:url" content="http://yoursite.com/2016/11/22/MIT 6.828 lab3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="前言这次lab的Part A让操作系统支持进程(单进程)，Part B处理了异常中断，使其能在kernel态和用户态进行切换。我觉得这次lab不算很难，可能是因为经过了前面两个lab洗礼的缘故。但还是在中断跳转那里卡了好一会，不会写汇编啊。 Part A在Jos中 我们用Env结构体来描述进程，关于Env，讲义中已经很清楚了，这里不赘述。关键点是通过envs数组和env_free_list来维护数">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2018-04-15T14:49:01.367Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MIT 6.828 lab3">
<meta name="twitter:description" content="前言这次lab的Part A让操作系统支持进程(单进程)，Part B处理了异常中断，使其能在kernel态和用户态进行切换。我觉得这次lab不算很难，可能是因为经过了前面两个lab洗礼的缘故。但还是在中断跳转那里卡了好一会，不会写汇编啊。 Part A在Jos中 我们用Env结构体来描述进程，关于Env，讲义中已经很清楚了，这里不赘述。关键点是通过envs数组和env_free_list来维护数">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-MIT 6.828 lab3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/22/MIT 6.828 lab3/" class="article-date">
  <time datetime="2016-11-22T15:03:06.000Z" itemprop="datePublished">2016-11-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      MIT 6.828 lab3
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这次<code>lab</code>的<code>Part A</code>让操作系统支持进程(单进程)，<code>Part B</code>处理了异常中断，使其能在<code>kernel态</code>和<code>用户态</code>进行切换。我觉得这次lab不算很难，可能是因为经过了前面两个lab洗礼的缘故。但还是在中断跳转那里卡了好一会，不会写汇编啊。</p>
<h2 id="Part-A"><a href="#Part-A" class="headerlink" title="Part A"></a>Part A</h2><p>在<code>Jos</code>中 我们用<code>Env</code>结构体来描述进程，关于Env，讲义中已经很清楚了，这里不赘述。关键点是通过<code>envs</code>数组和<code>env_free_list</code>来维护数组，这里需要注意的是<code>env_free_list</code>，不是像之前<code>free_page_list</code>那样是反向。这里需要和<code>envs</code>的顺序相同。</p>
<h3 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise 1"></a>Exercise 1</h3><blockquote>
<p>Modify <code>mem_init()</code> in kern/pmap.c to allocate and map the <code>envs</code> array. This array consists of exactly <code>NENV</code> instances of the <code>Env</code> structure allocated much like how you allocated the <code>pages</code> array. Also like the <code>pages</code> array, the memory backing <code>envs</code> should also be mapped user read-only at <code>UENVS</code> (defined in inc/memlayout.h) so user processes can read from this array.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">envs = (struct Env *) boot_alloc(NENV * <span class="keyword">sizeof</span>(struct Env));</span><br><span class="line">boot_map_region(kern_pgdir, UENVS, PTSIZE, PADDR(envs), PTE_U);</span><br></pre></td></tr></table></figure>
<p>这个应该轻车熟路了，就是为<code>envs</code>分配内存，并开启虚拟映射。<br><a id="more"></a></p>
<h3 id="Exercise-2"><a href="#Exercise-2" class="headerlink" title="Exercise 2"></a>Exercise 2</h3><blockquote>
<p> In the file env.c, finish coding the following functions:</p>
<ul>
<li><code>env_init()</code><br>Initialize all of the <code>Env</code> structures in the <code>envs</code> array and add them to the <code>env_free_list</code>. Also calls <code>env_init_percpu</code>, which configures the segmentation hardware with separate segments for privilege level 0 (kernel) and privilege level 3 (user).</li>
<li><code>env_setup_vm()</code><br>Allocate a page directory for a new environment and initialize the kernel portion of the new environment’s address space.</li>
<li><code>region_alloc()</code><br>Allocates and maps physical memory for an environment</li>
<li><code>load_icode()</code><br>You will need to parse an ELF binary image, much like the boot loader already does, and load its contents into the user address space of a new environment.</li>
<li><code>env_create()</code><br>Allocate an environment with <code>env_alloc</code> and call <code>load_icode</code> to load an ELF binary into it.</li>
<li><code>env_run()</code><br>Start a given environment running in user mode.</li>
</ul>
</blockquote>
<p><code>env_init()</code> 初始化<code>envs</code>，并且连接<code>env_free_list</code>。和之前的<code>page_init</code>做法基本一样，除了顺序相反。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">env_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Set up envs array</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = NENV - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        envs[i].env_id = <span class="number">0</span>;</span><br><span class="line">        envs[i].env_status = ENV_FREE;</span><br><span class="line">        envs[i].env_link = env_free_list;</span><br><span class="line">        env_free_list = &amp;envs[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Per-CPU part of the initialization</span></span><br><span class="line">    env_init_percpu();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>env_setup_vm</code>为进程分配页目录，这里做法是<code>copy</code>了<code>kernel</code>的页目录。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">env_setup_vm</span><span class="params">(struct Env *e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">p</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate a page for the page directory</span></span><br><span class="line">    <span class="keyword">if</span> (!(p = page_alloc(ALLOC_ZERO)))</span><br><span class="line">        <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    e-&gt;env_pgdir = page2kva(p);</span><br><span class="line">    p-&gt;pp_ref++;</span><br><span class="line">    <span class="built_in">memcpy</span>(e-&gt;env_pgdir, kern_pgdir, PGSIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// UVPT maps the env's own page table read-only.</span></span><br><span class="line">    <span class="comment">// Permissions: kernel R, user R</span></span><br><span class="line">    e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) | PTE_P | PTE_U;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>region_alloc()</code>为用户空间分配页。类似于<code>lab2</code> 中的<code>boot_map_region</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">region_alloc(struct Env *e, <span class="keyword">void</span> *va, <span class="keyword">size_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> *<span class="keyword">va_t</span> = ROUNDDOWN(va, PGSIZE);</span><br><span class="line">    <span class="keyword">void</span> *end = ROUNDUP(va + len, PGSIZE);</span><br><span class="line">    <span class="keyword">for</span>(; <span class="keyword">va_t</span> &lt; end;<span class="keyword">va_t</span> += PGSIZE)&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp</span> = <span class="title">page_alloc</span>(1);</span></span><br><span class="line">        <span class="keyword">if</span>(pp == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            panic(<span class="string">"region_alloc:page alloc failed!\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        page_insert(e-&gt;env_pgdir, pp, <span class="keyword">va_t</span>, PTE_U | PTE_W);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>load_icode()</code>这个函数注释好多，一开始看了半天。其实说白了就是把<code>elf</code>程序加载到用户内存空间。正常来讲用户程序应该从磁盘上读取，但是目前<code>jos</code>还没有文件系统。<code>mit</code>直接链接了一些用户程序到kernel中。所以这里不需要读取，更加方便一点。具体我们可以参考<code>bootloader</code>的做法。因为需要对用户空间进行内存操作，这里需要用<code>lcr3()</code>切换页目录。最后需要注意的是设置进程的入口点为这个程序的入口点。最后的最后是为用户程序栈初始化分配一页。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">load_icode</span><span class="params">(struct Env *e, <span class="keyword">uint8_t</span> *binary)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Elf</span> *<span class="title">elf</span> = (<span class="title">struct</span> <span class="title">Elf</span> *) <span class="title">binary</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (elf-&gt;e_magic != ELF_MAGIC)</span><br><span class="line">        panic(<span class="string">"load_icode: not ELF executable."</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Proghdr</span> *<span class="title">ph</span> = (<span class="title">struct</span> <span class="title">Proghdr</span> *) (<span class="title">elf</span>-&gt;<span class="title">e_phoff</span> + <span class="title">binary</span>);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Proghdr</span> *<span class="title">eph</span> = <span class="title">ph</span> + <span class="title">elf</span>-&gt;<span class="title">e_phnum</span>;</span></span><br><span class="line">    lcr3(PADDR(e-&gt;env_pgdir));</span><br><span class="line">    <span class="keyword">for</span>(; ph &lt; eph; ph++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ph-&gt;p_type == ELF_PROG_LOAD)&#123;</span><br><span class="line">            region_alloc(e, (<span class="keyword">void</span> *) ph-&gt;p_va, ph-&gt;p_memsz);</span><br><span class="line">            <span class="built_in">memset</span>((<span class="keyword">void</span> *) ph-&gt;p_va, <span class="number">0</span>, ph-&gt;p_memsz);</span><br><span class="line">            <span class="built_in">memcpy</span>((<span class="keyword">void</span> *) ph-&gt;p_va, binary + ph-&gt;p_offset, ph-&gt;p_filesz);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    lcr3(PADDR(kern_pgdir));</span><br><span class="line">    e-&gt;env_tf.tf_eip = elf-&gt;e_entry;</span><br><span class="line">    region_alloc(e, (<span class="keyword">void</span> *) (USTACKTOP - PGSIZE), PGSIZE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>env_create</code>这个简单，综合前面的函数，先创建进程，然后加载用户程序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">env_create</span><span class="params">(<span class="keyword">uint8_t</span> *binary, <span class="keyword">enum</span> EnvType type)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">    env_alloc(&amp;e, <span class="number">0</span>);</span><br><span class="line">    load_icode(e, binary);</span><br><span class="line">    e-&gt;env_type = type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>env_run</code>运行进程。这个也比较简单，照着注释来就行。切换当前进程为新的进程。切换地址空间。最后调用<code>env_pop_tf</code>来保存现场，并且跳转到用户程序的入口点，不返回。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">env_run</span><span class="params">(struct Env *e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(curenv != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(curenv-&gt;env_status == ENV_RUNNING)</span><br><span class="line">            curenv-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line">    &#125;</span><br><span class="line">    curenv = e;</span><br><span class="line">    curenv-&gt;env_status = ENV_RUNNING;</span><br><span class="line">    curenv-&gt;env_runs ++;</span><br><span class="line">    lcr3(PADDR(e-&gt;env_pgdir));</span><br><span class="line">    env_pop_tf(&amp;e-&gt;env_tf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里进程建立完成，操作系统完成了从<code>kernel</code>切换到<code>用户态</code>，但是<code>hello world</code>，依旧运行不起来，因为目前操作系统无法处理中断。也就是说无法从<code>用户态</code>切换回<code>kernel</code>，当调用<code>printf</code>，会引起系统调用中断。</p>
<h3 id="中断、异常和系统调用"><a href="#中断、异常和系统调用" class="headerlink" title="中断、异常和系统调用"></a>中断、异常和系统调用</h3><p><code>中断、异常和系统调用</code>是用户程序或者外部设备和<code>kernel</code>进行交互的方式。比如说当敲击键盘时会产生中断，让操作系统知道这时候有字符可读。在比如用户程序运行时，发生错误，比如除0，无法运行下去，这会产生异常，让kernel来处理，系统调用就更不用说了，每时每刻都在发生，比如<code>printf</code>就是一个系统调用。这里说的<code>中断、异常和系统调用</code>，每一种都有些细微的不同，其实根据上述的例子就能看出来，中断是异步的，异常是同步的，系统调用同步异步都有可能。之后文章中说的中断，是广义上的中断，也就是一个统称，不细分为<code>中断、异常和系统调用</code>。操作系统用<code>int n</code>指令来说明中断产生，当中断产生时，操作系统会根据<code>中断向量表</code>，来索引<code>n</code>，然后跳到相应的处理函数。</p>
<p>此外这里还有一个叫做<code>TSS</code>的东西需要注意。就是用来保护现场的，从用户态切换到<code>kernel</code>的时候。</p>
<h3 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise 4"></a>Exercise 4</h3><p>这个<code>exercise</code>主要工作是建立<code>idt表</code>，以及注册相应的映射。在做这个之前，一定要仔细阅读 <code>Exercise 3</code>提的手册，务必弄清楚详细的中断机制。其实我觉得这里太偏硬件了，我更推荐看<code>CSAPP</code>关于异常那一章。</p>
<blockquote>
<p>Edit trapentry.S and trap.c and implement the features described above. The macros <code>TRAPHANDLER</code> and <code>TRAPHANDLER_NOEC</code> in trapentry.S should help you, as well as the T_* defines in inc/trap.h. You will need to add an entry point in trapentry.S (using those macros) for each trap defined in inc/trap.h, and you’ll have to provide<code>_alltraps</code> which the <code>TRAPHANDLER</code> macros refer to. You will also need to modify <code>trap_init()</code> to initialize the <code>idt</code> to point to each of these entry points defined in trapentry.S; the <code>SETGATE</code> macro will be helpful here.</p>
<p>Your <code>_alltraps</code> should:</p>
<ol>
<li>push values to make the stack look like a struct Trapframe</li>
<li>load <code>GD_KD</code> into %ds and %es</li>
<li><code>pushl %esp</code> to pass a pointer to the Trapframe as an argument to trap()</li>
<li><code>call trap</code> (can <code>trap</code> ever return?)</li>
</ol>
<p>Consider using the <code>pushal</code> instruction; it fits nicely with the layout of the <code>struct Trapframe</code>.</p>
</blockquote>
<p>首先在<code>trapentry.S</code>用预先定义的两个宏来定义中断。这个需要查看intel手册，因为有些中断需要压入错误码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">TRAPHANDLER_NOEC(t_divide, T_DIVIDE)</span><br><span class="line">TRAPHANDLER_NOEC(t_debug, T_DEBUG)</span><br><span class="line">TRAPHANDLER_NOEC(t_nmi, T_NMI)</span><br><span class="line">TRAPHANDLER_NOEC(t_brkpt, T_BRKPT)</span><br><span class="line">TRAPHANDLER_NOEC(t_oflow, T_OFLOW)</span><br><span class="line">TRAPHANDLER_NOEC(t_bound, T_BOUND)</span><br><span class="line">TRAPHANDLER_NOEC(t_illop, T_ILLOP)</span><br><span class="line">TRAPHANDLER_NOEC(t_device, T_DEVICE)</span><br><span class="line">TRAPHANDLER(t_dblflt, T_DBLFLT)</span><br><span class="line">TRAPHANDLER(t_tss, T_TSS)</span><br><span class="line">TRAPHANDLER(t_segnp, T_SEGNP)</span><br><span class="line">TRAPHANDLER(t_stack, T_STACK)</span><br><span class="line">TRAPHANDLER(t_gpflt, T_GPFLT)</span><br><span class="line">TRAPHANDLER(t_pgflt, T_PGFLT)</span><br><span class="line">TRAPHANDLER_NOEC(t_fperr, T_FPERR)</span><br><span class="line">TRAPHANDLER(t_align, T_ALIGN)</span><br><span class="line">TRAPHANDLER_NOEC(t_mchk, T_MCHK)</span><br><span class="line">TRAPHANDLER_NOEC(t_simderr, T_SIMDERR)</span><br><span class="line">TRAPHANDLER_NOEC(t_syscall, T_SYSCALL)</span><br><span class="line">TRAPHANDLER_NOEC(irq_timer, IRQ_OFFSET + IRQ_TIMER)</span><br><span class="line">TRAPHANDLER_NOEC(irq_kbd, IRQ_OFFSET + IRQ_KBD)</span><br><span class="line">TRAPHANDLER_NOEC(irq_serial, IRQ_OFFSET + IRQ_SERIAL)</span><br><span class="line">TRAPHANDLER_NOEC(irq_spurious, IRQ_OFFSET + IRQ_SPURIOUS)</span><br><span class="line">TRAPHANDLER_NOEC(irq_ide, IRQ_OFFSET + IRQ_IDE)</span><br><span class="line">TRAPHANDLER_NOEC(irq_error, IRQ_OFFSET + IRQ_ERROR)</span><br></pre></td></tr></table></figure>
<p>然后需要在<code>_alltraps</code> 设置好<code>trapframe</code>，最后调用<code>trap</code>来分发中断。这个按照注释和说明来做即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">_alltraps:</span><br><span class="line">    # Build trap frame.</span><br><span class="line">    pushl %ds</span><br><span class="line">    pushl %es</span><br><span class="line">    pushal</span><br><span class="line"></span><br><span class="line">    movw $(GD_KD), %ax</span><br><span class="line">    movw %ax, %ds</span><br><span class="line">    movw %ax, %es</span><br><span class="line"></span><br><span class="line">    pushl %esp</span><br><span class="line">    call trap</span><br></pre></td></tr></table></figure>
<p>最后在<code>idt_init()</code>设立<code>IDT表</code>，并设立相应的权限。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trap_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">Segdesc</span> <span class="title">gdt</span>[];</span></span><br><span class="line">    SETGATE(idt[T_DIVIDE], <span class="number">0</span>, GD_KT, t_divide, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_DEBUG], <span class="number">0</span>, GD_KT, t_debug, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_NMI], <span class="number">0</span>, GD_KT, t_nmi, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_BRKPT], <span class="number">0</span>, GD_KT, t_brkpt, <span class="number">3</span>);</span><br><span class="line">    SETGATE(idt[T_OFLOW], <span class="number">0</span>, GD_KT, t_oflow, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_BOUND], <span class="number">0</span>, GD_KT, t_bound, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_ILLOP], <span class="number">0</span>, GD_KT, t_illop, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_DEVICE], <span class="number">0</span>, GD_KT, t_device, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_DBLFLT], <span class="number">0</span>, GD_KT, t_dblflt, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_TSS], <span class="number">0</span>, GD_KT, t_tss, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_SEGNP], <span class="number">0</span>, GD_KT, t_segnp, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_STACK], <span class="number">0</span>, GD_KT, t_stack, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_GPFLT], <span class="number">0</span>, GD_KT, t_gpflt, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_PGFLT], <span class="number">0</span>, GD_KT, t_pgflt, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_FPERR], <span class="number">0</span>, GD_KT, t_fperr, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_ALIGN], <span class="number">0</span>, GD_KT, t_align, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_MCHK], <span class="number">0</span>, GD_KT, t_mchk, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_SIMDERR], <span class="number">0</span>, GD_KT, t_simderr, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_SYSCALL], <span class="number">0</span>, GD_KT, t_syscall, <span class="number">3</span>);</span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_TIMER], <span class="number">0</span>, GD_KT, irq_timer, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_KBD], <span class="number">0</span>, GD_KT, irq_kbd, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_SERIAL], <span class="number">0</span>, GD_KT, irq_serial, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_SPURIOUS], <span class="number">0</span>, GD_KT, irq_spurious, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_IDE], <span class="number">0</span>, GD_KT, irq_ide, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_ERROR], <span class="number">0</span>, GD_KT, irq_error, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// Per-CPU setup</span></span><br><span class="line">    trap_init_percpu();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Part-B"><a href="#Part-B" class="headerlink" title="Part B"></a>Part B</h2><h3 id="Exercise-5-amp-amp-Exercise-6"><a href="#Exercise-5-amp-amp-Exercise-6" class="headerlink" title="Exercise 5 &amp;&amp;  Exercise 6"></a>Exercise 5 &amp;&amp;  Exercise 6</h3><blockquote>
<p>Modify <code>trap_dispatch()</code> to dispatch page fault exceptions to <code>page_fault_handler()</code>. You should now be able to get make grade to succeed on the faultread,faultreadkernel, faultwrite, and faultwritekernel tests. If any of them don’t work, figure out why and fix them.</p>
</blockquote>
<blockquote>
<p> Modify <code>trap_dispatch()</code> to make breakpoint exceptions invoke the kernel monitor.</p>
</blockquote>
<p>这两个比较简单，我就放在一起了。就是单纯的分发中断处理。没什么好讲的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(tf-&gt;tf_trapno)&#123;</span><br><span class="line">       <span class="keyword">case</span> T_PGFLT:</span><br><span class="line">           page_fault_handler(tf);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       <span class="keyword">case</span> T_BRKPT:</span><br><span class="line">           monitor(tf);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Exercise-7"><a href="#Exercise-7" class="headerlink" title="Exercise 7"></a>Exercise 7</h3><blockquote>
<p>Add a handler in the kernel for interrupt vector <code>T_SYSCALL</code>. You will have to edit kern/trapentry.S and kern/trap.c’s <code>trap_init()</code>. You also need to change<code>trap_dispatch()</code> to handle the system call interrupt by calling <code>syscall()</code> (defined in kern/syscall.c) with the appropriate arguments, and then arranging for the return value to be passed back to the user process in <code>%eax</code>. Finally, you need to implement <code>syscall()</code> in kern/syscall.c. Make sure <code>syscall()</code> returns <code>-E_INVAL</code> if the system call number is invalid. You should read and understand lib/syscall.c (especially the inline assembly routine) in order to confirm your understanding of the system call interface. Handle all the system calls listed in inc/syscall.h by invoking the corresponding kernel function for each call.</p>
</blockquote>
<p>添加系统调用处理。完成这个<code>exercise</code>。就能够完整的运行<code>hello world</code>了。之前建立<code>idt</code>表的时候，我已经设定好系统调用的映射了。所以这里直接处理<code>trap_dispatch()</code>就行。真正的<code>系统调用</code>触发在<code>/lib/syscall.c</code> 中，就是如下这条汇编语句</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">"int %1\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">             : <span class="string">"=a"</span> (ret)</span></span></span><br><span class="line">             : "i" (T_SYSCALL),</span><br><span class="line">               <span class="string">"a"</span> (num),</span><br><span class="line">               <span class="string">"d"</span> (a1),</span><br><span class="line">               <span class="string">"c"</span> (a2),</span><br><span class="line">               <span class="string">"b"</span> (a3),</span><br><span class="line">               <span class="string">"D"</span> (a4),</span><br><span class="line">               <span class="string">"S"</span> (a5)</span><br><span class="line">             : <span class="string">"cc"</span>, <span class="string">"memory"</span>);</span><br></pre></td></tr></table></figure>
<p><code>系统调用</code> 传入需要调用函数号，以及参数。所以当分发系统调用是，只要按照说明传入相应的参数，并且在<code>/kern/syscall.c</code>中按照函数号，分发下去即可。最后把返回值保存在<code>eax</code>中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> T_SYSCALL:</span><br><span class="line">           r = syscall(</span><br><span class="line">                   tf-&gt;tf_regs.reg_eax,</span><br><span class="line">                   tf-&gt;tf_regs.reg_edx,</span><br><span class="line">                   tf-&gt;tf_regs.reg_ecx,</span><br><span class="line">                   tf-&gt;tf_regs.reg_ebx,</span><br><span class="line">                   tf-&gt;tf_regs.reg_edi,</span><br><span class="line">                   tf-&gt;tf_regs.reg_esi);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123;</span><br><span class="line">               panic(<span class="string">"trap_dispatch: %e"</span>, r);</span><br><span class="line">           &#125;</span><br><span class="line">           tf-&gt;tf_regs.reg_eax = r;</span><br><span class="line">           <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>
<p><code>/kern/syscall.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int32_t</span></span><br><span class="line">syscall(<span class="keyword">uint32_t</span> syscallno, <span class="keyword">uint32_t</span> a1, <span class="keyword">uint32_t</span> a2, <span class="keyword">uint32_t</span> a3, <span class="keyword">uint32_t</span> a4, <span class="keyword">uint32_t</span> a5) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (syscallno) &#123;</span><br><span class="line">        <span class="keyword">case</span> SYS_cputs:</span><br><span class="line">            sys_cputs((<span class="keyword">const</span> <span class="keyword">char</span> *) a1,(<span class="keyword">size_t</span>) a2);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">case</span> SYS_cgetc:</span><br><span class="line">            <span class="keyword">return</span> sys_cgetc();</span><br><span class="line">        <span class="keyword">case</span> SYS_getenvid:</span><br><span class="line">            <span class="keyword">return</span> sys_getenvid();</span><br><span class="line">        <span class="keyword">case</span> SYS_env_destroy:</span><br><span class="line">            <span class="keyword">return</span> sys_env_destroy((<span class="keyword">envid_t</span>)a1);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Exercise-8"><a href="#Exercise-8" class="headerlink" title="Exercise 8"></a>Exercise 8</h3><blockquote>
<p>Add the required code to the user library, then boot your kernel. You should see user/hello print “hello, world” and then print “i am environment 00001000”.user/hello then attempts to “exit” by calling <code>sys_env_destroy()</code> (see lib/libmain.c and lib/exit.c). Since the kernel currently only supports one user environment, it should report that it has destroyed the only environment and then drop into the kernel monitor.</p>
</blockquote>
<p>这个也简单，即设置当前活动的进程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thisenv = envs + ENVX(sys_getenvid ());</span><br></pre></td></tr></table></figure>
<h3 id="Exercise-9"><a href="#Exercise-9" class="headerlink" title="Exercise 9"></a>Exercise 9</h3><blockquote>
<p> Change <code>kern/trap.c</code> to panic if a page fault happens in kernel mode.</p>
<p>Hint: to determine whether a fault happened in user mode or in kernel mode, check the low bits of the <code>tf_cs</code>.</p>
<p>Read <code>user_mem_assert</code> in kern/pmap.c and implement <code>user_mem_check</code> in that same file.</p>
</blockquote>
<p>内存保护。这个也很清楚，照着说明来即可。主要就是检查标志位。用户程序不能访问<code>kernel</code>的内存。以及在kernel中<code>page fault</code>，需要特别报错。</p>
<p><code>/kern/trap.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//page_fault_handler</span></span><br><span class="line"><span class="keyword">if</span> (tf-&gt;tf_cs == GD_KT) &#123;</span><br><span class="line">       panic(<span class="string">"page_fault_handler: page fault in kernel mode"</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>‘/kern/pmap.c’  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">user_mem_check</span><span class="params">(struct Env *env, <span class="keyword">const</span> <span class="keyword">void</span> *va, <span class="keyword">size_t</span> len, <span class="keyword">int</span> perm)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *vat =(<span class="keyword">void</span> *) va;</span><br><span class="line">    <span class="keyword">void</span> *end =(<span class="keyword">void</span> *)va + len;</span><br><span class="line">    <span class="keyword">int</span> p = perm | PTE_P;</span><br><span class="line">    <span class="keyword">pte_t</span> *pte;</span><br><span class="line">    <span class="keyword">for</span> (; vat &lt; end; vat = ROUNDDOWN(vat+PGSIZE, PGSIZE)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">uint32_t</span>)vat &gt; ULIM) &#123;</span><br><span class="line">            user_mem_check_addr =(<span class="keyword">uintptr_t</span>) vat;</span><br><span class="line">            <span class="keyword">return</span> -E_FAULT;</span><br><span class="line">        &#125;</span><br><span class="line">        page_lookup(env-&gt;env_pgdir, vat, &amp;pte);</span><br><span class="line">        <span class="keyword">if</span> (!(pte &amp;&amp; ((*pte &amp; p) == p))) &#123;</span><br><span class="line">            user_mem_check_addr = (<span class="keyword">uintptr_t</span>) vat;</span><br><span class="line">            <span class="keyword">return</span> -E_FAULT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>/kern/syscall.c</code> 最后需要在<code>sys_cputs</code> 添加检查，因为只有这个调用访问到地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sys_cputs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Check that the user has permission to read memory [s, s+len).</span></span><br><span class="line">    <span class="comment">// Destroy the environment if not.</span></span><br><span class="line">    user_mem_assert(curenv, s, len, PTE_U | PTE_W);</span><br><span class="line">    <span class="comment">// Print the string supplied by the user.</span></span><br><span class="line">    cprintf(<span class="string">"%.*s"</span>, len, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此<code>lab3</code>结束</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/22/MIT 6.828 lab3/" data-id="cjg0y8s0c000jl35ye1u0rowc" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MIT-6-828/">MIT 6.828</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Operating-system/">Operating system</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/12/02/MIT 6.828 lab4/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          MIT 6.828 lab4
        
      </div>
    </a>
  
  
    <a href="/2016/11/14/MIT 6.828 lab2/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">MIT 6.828 lab2</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithm/">Algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Computer-Network/">Computer Network</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Database-System/">Database System</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Distributed-Computing/">Distributed Computing</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Distributed-System/">Distributed System</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MIT-6-828/">MIT 6.828</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Machine-Learning/">Machine Learning</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Operating-system/">Operating system</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tomcat/">Tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/杂/">杂</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Algorithm/" style="font-size: 20px;">Algorithm</a> <a href="/tags/Android/" style="font-size: 16px;">Android</a> <a href="/tags/Computer-Network/" style="font-size: 10px;">Computer Network</a> <a href="/tags/Database-System/" style="font-size: 10px;">Database System</a> <a href="/tags/Distributed-Computing/" style="font-size: 10px;">Distributed Computing</a> <a href="/tags/Distributed-System/" style="font-size: 10px;">Distributed System</a> <a href="/tags/Java/" style="font-size: 12px;">Java</a> <a href="/tags/MIT-6-828/" style="font-size: 14px;">MIT 6.828</a> <a href="/tags/Machine-Learning/" style="font-size: 12px;">Machine Learning</a> <a href="/tags/Operating-system/" style="font-size: 18px;">Operating system</a> <a href="/tags/Tomcat/" style="font-size: 10px;">Tomcat</a> <a href="/tags/杂/" style="font-size: 10px;">杂</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">October 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">September 2015</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/06/11/Raft 共识算法/">Raft 共识算法</a>
          </li>
        
          <li>
            <a href="/2016/12/30/数据库事务与并发控制/">数据库事务与并发控制</a>
          </li>
        
          <li>
            <a href="/2016/12/18/计算机网络自顶向下之可靠传输协议的笔记/">计算机网络自顶向下之可靠传输协议的笔记</a>
          </li>
        
          <li>
            <a href="/2016/12/07/MIT 6.828 lab5/">MIT 6.828 lab5</a>
          </li>
        
          <li>
            <a href="/2016/12/02/MIT 6.828 lab4/">MIT 6.828 lab4</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>