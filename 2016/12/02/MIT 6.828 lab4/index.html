<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>MIT 6.828 lab4 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="前言lab4终于完成了。lab4是到目前为止，比较复杂而且代码最多的lab。总共需要完成三个部分。part A添加多核支持，实现RR调度。part B实现Copy-On-Write fork。part C 实现时钟中断以及支持基本的IPC。 Part AExercise 1 Implement mmio_map_region in kern/pmap.c. To see how this is u">
<meta name="keywords" content="Operating system,MIT 6.828">
<meta property="og:type" content="article">
<meta property="og:title" content="MIT 6.828 lab4">
<meta property="og:url" content="http://yoursite.com/2016/12/02/MIT 6.828 lab4/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="前言lab4终于完成了。lab4是到目前为止，比较复杂而且代码最多的lab。总共需要完成三个部分。part A添加多核支持，实现RR调度。part B实现Copy-On-Write fork。part C 实现时钟中断以及支持基本的IPC。 Part AExercise 1 Implement mmio_map_region in kern/pmap.c. To see how this is u">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2018-04-15T14:49:01.368Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MIT 6.828 lab4">
<meta name="twitter:description" content="前言lab4终于完成了。lab4是到目前为止，比较复杂而且代码最多的lab。总共需要完成三个部分。part A添加多核支持，实现RR调度。part B实现Copy-On-Write fork。part C 实现时钟中断以及支持基本的IPC。 Part AExercise 1 Implement mmio_map_region in kern/pmap.c. To see how this is u">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-MIT 6.828 lab4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/02/MIT 6.828 lab4/" class="article-date">
  <time datetime="2016-12-02T15:04:06.000Z" itemprop="datePublished">2016-12-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      MIT 6.828 lab4
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>lab4</code>终于完成了。<code>lab4</code>是到目前为止，比较复杂而且代码最多的<code>lab</code>。总共需要完成三个部分。<code>part A</code>添加多核支持，实现<code>RR</code>调度。<code>part B</code>实现<code>Copy-On-Write fork</code>。<code>part C</code> 实现时钟中断以及支持基本的<code>IPC</code>。</p>
<h2 id="Part-A"><a href="#Part-A" class="headerlink" title="Part A"></a>Part A</h2><h3 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise 1"></a>Exercise 1</h3><blockquote>
<p>Implement <code>mmio_map_region</code> in kern/pmap.c. To see how this is used, look at the beginning of <code>lapic_init</code> in kern/lapic.c. You’ll have to do the next exercise, too, before the tests for <code>mmio_map_region</code> will run.</p>
</blockquote>
<p>实现需要让<code>Jos</code>支持<code>symmetric multiprocessing</code>，也就是所有的<code>cpu</code>都拥有相同的权限去访问资源。<code>Jos</code>使用<code>LAPIC</code>来分发中断，以及通过它来知道当前使用的<code>cpu</code>。而处理器访问<code>LAPIC</code>，需要使用<code>MMIO</code>。所以我们需要对<code>MMIO</code>进行内存映射，这个函数比较简单。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line">mmio_map_region(<span class="keyword">physaddr_t</span> pa, <span class="keyword">size_t</span> size) &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">uintptr_t</span> base = MMIOBASE;</span><br><span class="line"></span><br><span class="line">    size = ROUNDUP(size, PGSIZE);</span><br><span class="line">    <span class="keyword">if</span>(base + size &gt; MMIOLIM)&#123;</span><br><span class="line">        panic(<span class="string">"mmio_map_region: reservation mem overflow"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    boot_map_region(kern_pgdir, base, size, pa, PTE_W | PTE_PCD | PTE_P);</span><br><span class="line">    <span class="keyword">uintptr_t</span> b = base;</span><br><span class="line">    base += size;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span> *) b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="Exercise-2"><a href="#Exercise-2" class="headerlink" title="Exercise 2"></a>Exercise 2</h3><blockquote>
<p>Read <code>boot_aps()</code> and <code>mp_main()</code> in kern/init.c, and the assembly code in kern/mpentry.S. Make sure you understand the control flow transfer during the bootstrap of APs. Then modify your implementation of <code>page_init()</code> in kern/pmap.c to avoid adding the page at <code>MPENTRY_PADDR</code> to the free list, so that we can safely copy and run AP bootstrap code at that physical address. Your code should pass the updated <code>check_page_free_list()</code> test (but might fail the updated <code>check_kern_pgdir()</code> test, which we will fix soon).</p>
</blockquote>
<p><code>boot_aps()</code>首先把<code>mpentry.S</code>的代码复制到内存<code>MPENTRY_PADDR</code>中。然后对每个<code>cpu</code>都启动一个进程，也就是<code>APS</code>，进程栈保存在<code>percpu_kstacks</code>。最后通过<code>lapic_startap</code>发生中断跳到<code>mpentry.S</code>去执行。然后进行死循环等待<code>cpu进程</code>启动。<code>mpentry.S</code>的功能与<code>bootloader</code>类似，最后会跳转到<code>mp_main</code>。然后就是进行一些初始化，改变<code>cpu</code>状态为启动，通知<code>boot_aps()</code>可以进行<code>boot</code>下一个进程了。</p>
<p>所以这里我门需要为<code>MPENTRY_PADDR</code>留出一块空间来放<code>mpentry.S</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mpentry_i = PGNUM(MPENTRY_PADDR);</span><br><span class="line">   pages[mpentry_i + <span class="number">1</span>].pp_link = pages[mpentry_i].pp_link;</span><br><span class="line">   pages[mpentry_i].pp_link = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<h4 id="Question-1"><a href="#Question-1" class="headerlink" title="Question 1"></a>Question 1</h4><blockquote>
<p>Compare kern/mpentry.S side by side with boot/boot.S. Bearing in mind that kern/mpentry.S is compiled and linked to run above <code>KERNBASE</code> just like everything else in the kernel, what is the purpose of macro <code>MPBOOTPHYS</code>? Why is it necessary in kern/mpentry.S but not in boot/boot.S? In other words, what could go wrong if it were omitted in kern/mpentry.S?<br>Hint: recall the differences between the link address and the load address that we have discussed in Lab 1.</p>
</blockquote>
<p><code>MPBOOTPHYS</code>的作用是将高地址变为地址。因为根据注释上的说明，此次还处于实模式，但是代码中的地址已经经过重定位，所以需要进行地址翻译。</p>
<h3 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise 3"></a>Exercise 3</h3><blockquote>
<p>Modify <code>mem_init_mp()</code> (in kern/pmap.c) to map per-CPU stacks starting at <code>KSTACKTOP</code>, as shown in inc/memlayout.h. The size of each stack is <code>KSTKSIZE</code> bytes plus<code>KSTKGAP</code> bytes of unmapped guard pages. Your code should pass the new check in <code>check_kern_pgdir()</code>.</p>
</blockquote>
<p>为每个cpu栈分配内存，比较简单，按照<code>memlayout</code>来就行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">mem_init_mp(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="keyword">uintptr_t</span> kstacktop_i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NCPU; i++)&#123;</span><br><span class="line">        kstacktop_i = KSTACKTOP - i * (KSTKSIZE + KSTKGAP);</span><br><span class="line">        boot_map_region(kern_pgdir, kstacktop_i - KSTKSIZE, KSTKSIZE,</span><br><span class="line">        				PADDR(percpu_kstacks[i]), PTE_W);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise 4"></a>Exercise 4</h3><blockquote>
<p>The code in <code>trap_init_percpu()</code> (kern/trap.c) initializes the TSS and TSS descriptor for the BSP. It worked in Lab 3, but is incorrect when running on other CPUs. Change the code so that it can work on all CPUs. (Note: your new code should not use the global <code>ts</code> variable any more.)</p>
</blockquote>
<p>初始化每个cpu进程，这里也没什么好说的，照着注释写即可</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">trap_init_percpu(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> i = cpunum();</span><br><span class="line">    <span class="comment">// Setup a TSS so that we get the right stack</span></span><br><span class="line">    <span class="comment">// when we trap to the kernel.</span></span><br><span class="line">    thiscpu-&gt;cpu_ts.ts_esp0 = (<span class="keyword">uintptr_t</span>)percpu_kstacks[i];</span><br><span class="line">    <span class="comment">//thiscpu-&gt;cpu_ts.ts_esp0 = KSTACKTOP - i * (KSTKSIZE + KSTKGAP);</span></span><br><span class="line">    thiscpu-&gt;cpu_ts.ts_ss0 = GD_KD;</span><br><span class="line">    thiscpu-&gt;cpu_ts.ts_iomb = <span class="keyword">sizeof</span>(struct Taskstate);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize the TSS slot of the gdt.</span></span><br><span class="line">    gdt[(GD_TSS0 &gt;&gt; <span class="number">3</span>) + i] = SEG16(STS_T32A, (<span class="keyword">uint32_t</span>) (&amp;thiscpu-&gt;cpu_ts),</span><br><span class="line">                    <span class="keyword">sizeof</span>(struct Taskstate) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    gdt[(GD_TSS0 &gt;&gt; <span class="number">3</span>) + i].sd_s = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Load the TSS selector (like other segment selectors, the</span></span><br><span class="line">    <span class="comment">// bottom three bits are special; we leave them 0)</span></span><br><span class="line">    ltr(GD_TSS0 + (i &lt;&lt; <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Load the IDT</span></span><br><span class="line">    lidt(&amp;idt_pd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Exercise-5"><a href="#Exercise-5" class="headerlink" title="Exercise 5"></a>Exercise 5</h3><blockquote>
<p>Apply the big kernel lock as described above, by calling <code>lock_kernel()</code> and <code>unlock_kernel()</code> at the proper locations.</p>
</blockquote>
<p>现在有多个<code>cpu</code>进程都能运行<code>kernel</code>，所以现在必须要解决进程间资源竞争的问题，这里直接套了一个大锁，进程进入<code>kernel</code>的时候上锁，退出的时候释放。。。略邪恶。这里需要贴的地方比较多，但代码比较简单，我就不放了。需要的可以去<code>github</code>上找。</p>
<h4 id="Question-2"><a href="#Question-2" class="headerlink" title="Question 2"></a>Question 2</h4><blockquote>
<p>It seems that using the big kernel lock guarantees that only one CPU can run the kernel code at a time. Why do we still need separate kernel stacks for each CPU? Describe a scenario in which using a shared kernel stack will go wrong, even with the protection of the big kernel lock.</p>
</blockquote>
<p>这个问题采用了<a href="https://github.com/Al--Zn/JOS/tree/lab4" target="_blank" rel="noopener">AL–Zn</a>的回答。中断发生时会自动压栈，而这时候还没有取得锁，若多个CPU同时发生中断，共享内核栈将会出错。</p>
<h3 id="Exercise-6"><a href="#Exercise-6" class="headerlink" title="Exercise 6"></a>Exercise 6</h3><blockquote>
<p>Implement round-robin scheduling in <code>sched_yield()</code> as described above. Don’t forget to modify <code>syscall()</code> to dispatch <code>sys_yield()</code>.<br>Make sure to invoke <code>sched_yield()</code> in <code>mp_main</code>.<br>Modify <code>kern/init.c</code> to create three (or more!) environments that all run the program <code>user/yield.c</code></p>
</blockquote>
<p>实现<code>RR</code>调度。顺序循环进行遍历进程，从当前进程开始找，直到找到第一个<code>ENV_RUNNABLE</code>的进程，并运行它。具体细节参照注释。实现如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">sched_yield(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> cur_idx;</span><br><span class="line">    <span class="keyword">if</span> (curenv)</span><br><span class="line">        cur_idx = ENVX(curenv-&gt;env_id);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cur_idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(envs[cur_idx].env_status == ENV_RUNNABLE)&#123;</span><br><span class="line">        env_run(&amp;envs[cur_idx]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = cur_idx + <span class="number">1</span>; i != cur_idx; i = (i + <span class="number">1</span>) % NENV)&#123;</span><br><span class="line">        <span class="keyword">if</span>(envs[i].env_status == ENV_RUNNABLE)&#123;</span><br><span class="line">            env_run(&amp;envs[i]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(curenv &amp;&amp; curenv-&gt;env_status == ENV_RUNNING) &#123;</span><br><span class="line">        env_run(curenv);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sched_halt never returns</span></span><br><span class="line">    sched_halt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Question-3"><a href="#Question-3" class="headerlink" title="Question 3"></a>Question 3</h4><blockquote>
<p>In your implementation of <code>env_run()</code> you should have called <code>lcr3()</code>. Before and after the call to <code>lcr3()</code>, your code makes references (at least it should) to the variable<code>e</code>, the argument to <code>env_run</code>. Upon loading the <code>%cr3</code> register, the addressing context used by the MMU is instantly changed. But a virtual address (namely <code>e</code>) has meaning relative to a given address context–the address context specifies the physical address to which the virtual address maps. Why can the pointer <code>e</code> be dereferenced both before and after the addressing switch?</p>
</blockquote>
<p>因为<code>mem_init()</code>时是以<code>kernel pgdir</code>为模板的</p>
<h4 id="Question-4"><a href="#Question-4" class="headerlink" title="Question 4"></a>Question 4</h4><blockquote>
<p>Whenever the kernel switches from one environment to another, it must ensure the old environment’s registers are saved so they can be restored properly later. Why? Where does this happen?</p>
</blockquote>
<p>当然需要保存。不然进程切换时无法恢复啊。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy trap frame (which is currently on the stack)</span></span><br><span class="line"><span class="comment">// into 'curenv-&gt;env_tf', so that running the environment</span></span><br><span class="line">   <span class="comment">// will restart at the trap point.</span></span><br><span class="line">   curenv-&gt;env_tf = *tf;</span><br></pre></td></tr></table></figure>
<h3 id="Exercise-7"><a href="#Exercise-7" class="headerlink" title="Exercise 7"></a>Exercise 7</h3><blockquote>
<p>Implement the system calls described above in kern/syscall.c. You will need to use various functions in kern/pmap.c and kern/env.c, particularly <code>envid2env()</code>. For now, whenever you call <code>envid2env()</code>, pass 1 in the <code>checkperm</code> parameter. Be sure you check for any invalid system call arguments, returning <code>-E_INVAL</code> in that case. Test your JOS kernel with user/dumbfork and make sure it works before proceeding.</p>
</blockquote>
<p>这里虽然看起来需要实现的代码很多，其实并不难，因为注释很详细，需要完成的任务也简单。</p>
<p><code>sys_exofork</code>这里的<code>fork</code>，只是单纯分配了一块地址空间给进程，但里面是空的，所以目前进程还是不可运行。具体做法也很直观，下面是实现，注意要把子进程返回值的寄存器设为0.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">envid_t</span></span><br><span class="line">sys_exofork(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">child_env</span>;</span></span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    r = env_alloc(&amp;child_env, curenv-&gt;env_id);</span><br><span class="line">    <span class="keyword">if</span>(r!=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    child_env-&gt;env_status = ENV_NOT_RUNNABLE;</span><br><span class="line">    child_env-&gt;env_tf = curenv-&gt;env_tf;</span><br><span class="line">    child_env-&gt;env_tf.tf_regs.reg_eax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> child_env-&gt;env_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sys_env_set_status</code>设置状态，不多说。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_env_set_status(<span class="keyword">envid_t</span> envid, <span class="keyword">int</span> status) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line">    <span class="keyword">int</span> r = envid2env(envid, &amp;env, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(r!=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    <span class="keyword">if</span>(env-&gt;env_status == ENV_RUNNABLE || env-&gt;env_status == ENV_NOT_RUNNABLE)&#123;</span><br><span class="line">        env-&gt;env_status = status;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sys_page_alloc</code> 分配页的系统调用，不难，比较烦的是权限检查。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_page_alloc(<span class="keyword">envid_t</span> envid, <span class="keyword">void</span> *va, <span class="keyword">int</span> perm) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line">    <span class="keyword">int</span> r = envid2env(envid, &amp;env, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(r!=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    <span class="keyword">if</span> (va &gt; (<span class="keyword">void</span> *) UTOP || va != ROUNDDOWN(va, PGSIZE))</span><br><span class="line">       <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    <span class="keyword">int</span> flag = PTE_U | PTE_P;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((perm &amp; flag) != flag)</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (perm &amp; (~(PTE_U | PTE_P | PTE_AVAIL | PTE_W)))</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp</span> = <span class="title">page_alloc</span>(1);</span></span><br><span class="line">    <span class="keyword">if</span>(pp == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">    pp-&gt;pp_ref ++;</span><br><span class="line">    r = page_insert(env-&gt;env_pgdir, pp, va, perm);</span><br><span class="line">    <span class="keyword">if</span>(r!=<span class="number">0</span>)&#123;</span><br><span class="line">        page_free(pp);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sys_page_map</code>，页的映射，用来两个进程通信时使用，使两块地址空间的部分内容映射到同一块物理地址。也不难。。还是烦在地址检查。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_page_map(<span class="keyword">envid_t</span> srcenvid, <span class="keyword">void</span> *srcva,</span><br><span class="line">         <span class="keyword">envid_t</span> dstenvid, <span class="keyword">void</span> *dstva, <span class="keyword">int</span> perm) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">srcenv</span>, *<span class="title">dstenv</span>;</span></span><br><span class="line">    <span class="keyword">int</span> r = envid2env(srcenvid, &amp;srcenv, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(r!=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    r = envid2env(dstenvid, &amp;dstenv, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(r!=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (srcva &gt;= (<span class="keyword">void</span> *) UTOP || dstva &gt;= (<span class="keyword">void</span> *) UTOP ||</span><br><span class="line">        srcva != ROUNDDOWN(srcva, PGSIZE) || dstva != ROUNDDOWN(dstva, PGSIZE))</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pte_t</span> *pte;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp</span> = <span class="title">page_lookup</span>(<span class="title">srcenv</span>-&gt;<span class="title">env_pgdir</span>, <span class="title">srcva</span>, &amp;<span class="title">pte</span>);</span></span><br><span class="line">    <span class="keyword">if</span>(pp == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((!(perm &amp; (PTE_U | PTE_P))) || (perm &amp; (~(PTE_U | PTE_P | PTE_AVAIL | PTE_W))))</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((perm &amp; PTE_W) &amp;&amp; !(*pte &amp; PTE_W))</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line"></span><br><span class="line">    r = page_insert(dstenv-&gt;env_pgdir, pp, dstva, perm);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sys_page_unmap</code>不多说</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_page_unmap(<span class="keyword">envid_t</span> envid, <span class="keyword">void</span> *va) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line">    <span class="keyword">int</span> r = envid2env(envid, &amp;env, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(r!=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    <span class="keyword">if</span> (va &gt; (<span class="keyword">void</span> *)UTOP || va != ROUNDDOWN(va, PGSIZE))</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line"></span><br><span class="line">    page_remove(env-&gt;env_pgdir, va);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Part-B"><a href="#Part-B" class="headerlink" title="Part B"></a>Part B</h2><p><code>Part B</code>的任务主要是实现<code>Copy-on-Write Fork</code>，也就是所谓的写时拷贝技术。传统的<code>fork</code>函数，调用时会直接将父进程的内存内容拷贝到子进程当中了，但是大多数是程序，当<code>fork</code>之后就直接调用<code>exec()</code>填充新的内存内容了。所以拷贝这一步很浪费时间。所以现在采用的做法是<code>COW fork</code>，也就是把拷贝的时间推迟到子进程需要写入的时候。这种做法用的很多，比如<code>cache</code>更新的情况。</p>
<p>具体做法是，当<code>fork</code>调用时，把子进程的用户空间的地址都映射到父进程时，并且设置权限位，直到子进程需要写内存的时候，权限判断失败，并触发<code>page fault</code>，然后进行系统分配页，把需要写入的那一页内存<code>copy</code>出来，并分配到子进程的地址空间中。</p>
<p>所以在写<code>COW Fork</code>之前，首先需要处理在用户空间<code>page fault</code>的情况。</p>
<h3 id="Exercise-8"><a href="#Exercise-8" class="headerlink" title="Exercise 8"></a>Exercise 8</h3><blockquote>
<p>Implement the <code>sys_env_set_pgfault_upcall</code> system call. Be sure to enable permission checking when looking up the environment ID of the target environment, since this is a “dangerous” system call</p>
</blockquote>
<p>这个很简单了，就是设置<code>pgfault</code>时需要调用的函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_env_set_pgfault_upcall(<span class="keyword">envid_t</span> envid, <span class="keyword">void</span> *func) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line">    <span class="keyword">int</span> r = envid2env(envid, &amp;env, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(r!=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    env-&gt;env_pgfault_upcall = func;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Exercise-9"><a href="#Exercise-9" class="headerlink" title="Exercise 9"></a>Exercise 9</h3><blockquote>
<p>Implement the code in <code>page_fault_handler</code> in kern/trap.c required to dispatch page faults to the user-mode handler. Be sure to take appropriate precautions when writing into the exception stack. (What happens if the user environment runs out of space on the exception stack?)</p>
</blockquote>
<p>这个函数比较复杂。因为这里涉及到栈的切换。当<code>kernel</code>处理<code>page_fault</code>时，并不是在<code>kernel栈</code>或者<code>用户栈</code>处理，而是启用了一个新的栈，<code>用户异常栈</code>。并且使用一个新的数据结构<code>UTrapframe</code>来保存触发<code>page_fault</code>的进程信息。所以现在用户空间的缺页流程是这样的的，用户空间发生缺页，产生中断，陷入到内核中，分发到<code>page_fault_handler</code>中，在<code>用户异常栈</code>保存错误进程的信息，以及错误地址(保存到<code>UTrapframe</code>中)，切换到<code>用户异常栈</code>，然后调用用户自定义的<code>pgfault_upcall</code>，最后再切换到原来错误的地方继续运行。</p>
<p>栈的切换分成两种情况。</p>
<ul>
<li>用户进程发生<code>page_fault</code>。<code>用户栈</code> -&gt; <code>kernel栈</code> -&gt; <code>用户异常栈</code></li>
<li>在<code>page_fault</code>处理时又发生<code>page_fault</code>。虽然已经在用户异常栈了，但还是会继续陷入到内核中，重走一遍上面的流程，这里需要注意，压入<code>UTrapframe</code>时，需要空<code>4</code>个字节。所以栈切换顺序为，<code>用户异常栈</code> -&gt; <code>kernel栈</code> -&gt; <code>用户异常栈</code></li>
</ul>
<p>好，现在情况应该比较清楚了。所以目前这个函数需要做的就是在<code>用户异常栈</code>中压入<code>UTrapframe</code>数据结构，并保存错误进程的信息，以便之后恢复重新运行。这里有一点要注意，就是有可能发生上面说的第二种情况，所以需要判断进程的栈地址是不是已经在<code>用户异常栈</code>了，然后需要多压<code>4字节</code>，另外别忘了检查地址用完的情况。代码如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(curenv-&gt;env_pgfault_upcall!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">UTrapframe</span> *<span class="title">utf</span>;</span></span><br><span class="line">       <span class="keyword">uintptr_t</span> utf_addr;</span><br><span class="line">       <span class="keyword">if</span>(tf-&gt;tf_esp &gt;= UXSTACKTOP - PGSIZE &amp;&amp; tf-&gt;tf_esp &lt; UXSTACKTOP)&#123;</span><br><span class="line">           utf_addr = tf-&gt;tf_esp - <span class="keyword">sizeof</span>(struct UTrapframe) - <span class="number">4</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span>&#123;</span><br><span class="line">           utf_addr = UXSTACKTOP - <span class="keyword">sizeof</span>(struct UTrapframe);</span><br><span class="line">       &#125;</span><br><span class="line">       user_mem_assert(curenv, (<span class="keyword">void</span> *) utf_addr, <span class="keyword">sizeof</span>(struct UTrapframe), PTE_W);</span><br><span class="line"></span><br><span class="line">       utf = (struct UTrapframe *) utf_addr;</span><br><span class="line">       utf-&gt;utf_fault_va = fault_va;</span><br><span class="line">       utf-&gt;utf_err = tf-&gt;tf_err;</span><br><span class="line">       utf-&gt;utf_regs = tf-&gt;tf_regs;</span><br><span class="line">       utf-&gt;utf_eip = tf-&gt;tf_eip;</span><br><span class="line">       utf-&gt;utf_eflags = tf-&gt;tf_eflags;</span><br><span class="line">       utf-&gt;utf_esp = tf-&gt;tf_esp;</span><br><span class="line"></span><br><span class="line">       tf-&gt;tf_eip = (<span class="keyword">uintptr_t</span>) curenv-&gt;env_pgfault_upcall;</span><br><span class="line">       tf-&gt;tf_esp = utf_addr;</span><br><span class="line">       env_run(curenv);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Exercise-10"><a href="#Exercise-10" class="headerlink" title="Exercise 10"></a>Exercise 10</h3><blockquote>
<p>Implement the <code>_pgfault_upcall</code> routine in lib/pfentry.S. The interesting part is returning to the original point in the user code that caused the page fault. You’ll return directly there, without going back through the kernel. The hard part is simultaneously switching stacks and re-loading the EIP.</p>
</blockquote>
<p>这是我最头疼的部分。这段汇编先调用了用户自定义的<code>page_handler</code>函数，然后需要根据之前压入的<code>UTrapframe</code>来切换为发生的错误的进程继续运行。这里我用了<code>PKU张弛</code>的代码。。他貌似也是用了别人的代码。。。我没有过多去纠结这段代码。大致是把返回的错误地址填到之前空的<code>4</code>个字节处，再加点<code>trick</code>，就可以同时切换<code>esp</code>和<code>eip</code>。下面是代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">movl 0x28(%esp), %eax</span><br><span class="line">subl $0x4, 0x30(%esp)</span><br><span class="line">movl 0x30(%esp), %edx</span><br><span class="line">movl %eax, (%edx)</span><br><span class="line">addl $0x8, %esp</span><br><span class="line"></span><br><span class="line">// Restore the trap-time registers.  After you do this, you</span><br><span class="line">// can no longer modify any general-purpose registers.</span><br><span class="line">popal</span><br><span class="line"></span><br><span class="line">// Restore eflags from the stack.  After you do this, you can</span><br><span class="line">// no longer use arithmetic operations or anything else that</span><br><span class="line">// modifies eflags.</span><br><span class="line">addl $0x4, %esp</span><br><span class="line">popfl</span><br><span class="line">// Switch back to the adjusted trap-time stack.</span><br><span class="line">// LAB 4: Your code here.</span><br><span class="line">popl %esp</span><br><span class="line">// Return to re-execute the instruction that faulted.</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<h3 id="Exercise-11"><a href="#Exercise-11" class="headerlink" title="Exercise 11"></a>Exercise 11</h3><blockquote>
<p>Finish <code>set_pgfault_handler()</code> in lib/pgfault.c.</p>
</blockquote>
<p>最后就简单了，为<code>用户异常栈</code>分配页，已经设置<code>upcall</code>调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">set_pgfault_handler(<span class="keyword">void</span> (*handler)(struct UTrapframe *utf)) &#123;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">if</span> (_pgfault_handler == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(sys_page_alloc(thisenv-&gt;env_id,</span><br><span class="line">                          (<span class="keyword">void</span> *) (UXSTACKTOP - PGSIZE), PTE_U|PTE_P|PTE_W) != <span class="number">0</span>)&#123;</span><br><span class="line">            panic(<span class="string">"set_pgfault_handler: sys_page_alloc failed"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sys_env_set_pgfault_upcall(thisenv-&gt;env_id, _pgfault_upcall) != <span class="number">0</span>)&#123;</span><br><span class="line">            panic(<span class="string">"set_pgfault_handler: sys_env_set_pgfault_upcall failed"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Save handler pointer for assembly to call.</span></span><br><span class="line">    _pgfault_handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个个过程非常<code>trick</code>，十分有趣。其实绕这么一大圈，最终的目的还是为了保护<code>kernel</code>！</p>
<h3 id="Exercise-12"><a href="#Exercise-12" class="headerlink" title="Exercise 12"></a>Exercise 12</h3><blockquote>
<p>Implement <code>fork</code>, <code>duppage</code> and <code>pgfault</code> in lib/fork.c.</p>
</blockquote>
<p>还没完。。。高潮才刚刚到来。前面搞了这么多，都只是为了实现<code>COW Fork</code>！。因为我门需要把<code>COW Fork</code>作为自定义函数库来实现。所以前面弄了这么多，只有一个目的，那就是在用户进程中<code>handle page fault</code>。</p>
<p>关与具体实现，其实<code>mit</code>的讲义上已经很清楚了。大致就是说把<code>UTOP</code>以下的地址都通过<code>duppage</code>进行映射到同一块物理地址上，当子进程发生缺页时，才通过<code>pgfault</code>来分配页。具体细节不赘述。</p>
<p>下面是代码。</p>
<p><code>fork</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">envid_t</span> fork(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="keyword">envid_t</span> envid;</span><br><span class="line">    <span class="keyword">uintptr_t</span> addr;</span><br><span class="line"></span><br><span class="line">    set_pgfault_handler(&amp;pgfault);</span><br><span class="line">    envid = sys_exofork();</span><br><span class="line">    <span class="keyword">if</span>(envid &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">"fork: sys_exofork failed"</span>);</span><br><span class="line">    <span class="keyword">if</span>(envid == <span class="number">0</span>)&#123;</span><br><span class="line">        thisenv = &amp;envs[ENVX(sys_getenvid())];</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (addr = <span class="number">0</span>; addr &lt; USTACKTOP; addr += PGSIZE) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((uvpd[PDX(addr)] &amp; PTE_P) &amp;&amp; (uvpt[PGNUM(addr)] &amp; PTE_P))</span><br><span class="line">            duppage(envid, PGNUM(addr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sys_page_alloc(envid, (<span class="keyword">void</span> *) (UXSTACKTOP - PGSIZE),</span><br><span class="line">                    PTE_P | PTE_U | PTE_W) &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">"fork: sys_page_alloc failed"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">void</span> _pgfault_upcall();</span><br><span class="line">    sys_env_set_pgfault_upcall(envid, _pgfault_upcall);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sys_env_set_status(envid, ENV_RUNNABLE) != <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">"fork: sys_env_set_status"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> envid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>duppage</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">duppage</span><span class="params">(<span class="keyword">envid_t</span> envid, <span class="keyword">unsigned</span> pn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">void</span> *addr = (<span class="keyword">void</span> *)(pn * PGSIZE);</span><br><span class="line">    <span class="keyword">if</span> ((uvpt[pn] &amp; PTE_W) || (uvpt[pn] &amp; PTE_COW)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, addr, envid, addr, PTE_P | PTE_U | PTE_COW)) &lt; <span class="number">0</span>)</span><br><span class="line">            panic(<span class="string">"duppage: %e"</span>, r);</span><br><span class="line">        <span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, addr, <span class="number">0</span>, addr, PTE_P | PTE_U | PTE_COW)) &lt; <span class="number">0</span>)</span><br><span class="line">            panic(<span class="string">"duppage: %e"</span>, r);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, addr, envid, addr, PTE_P | PTE_U)) &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">"duppage: %e"</span>, r);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>pafault</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">pgfault(struct UTrapframe *utf) &#123;</span><br><span class="line">    <span class="keyword">void</span> *addr = (<span class="keyword">void</span> *) utf-&gt;utf_fault_va;</span><br><span class="line">    <span class="keyword">uint32_t</span> err = utf-&gt;utf_err;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pte_t</span> pte = ((<span class="keyword">pte_t</span> *) uvpt)[PGNUM(addr)];</span><br><span class="line">    <span class="keyword">if</span>(!( (err &amp; FEC_WR) != <span class="number">0</span> &amp;&amp; (pte &amp; PTE_COW)!=<span class="number">0</span> ))&#123;</span><br><span class="line">        panic(<span class="string">"pgfault: not write and not a COW page"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addr = ROUNDDOWN(addr, PGSIZE);</span><br><span class="line">    <span class="keyword">envid_t</span> envid = sys_getenvid();</span><br><span class="line">    <span class="keyword">if</span> ((r = sys_page_alloc(envid, PFTEMP, PTE_P | PTE_U | PTE_W)) &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">"pgfault: %e"</span>, r);</span><br><span class="line">    <span class="built_in">memcpy</span>(PFTEMP, addr, PGSIZE);</span><br><span class="line">    <span class="keyword">if</span> ((r = sys_page_map(envid, PFTEMP, envid, addr, PTE_P | PTE_U | PTE_W)) &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">"pgfault: %e"</span>, r);</span><br><span class="line">    <span class="keyword">if</span> ((r = sys_page_unmap(envid, PFTEMP)) &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">"pgfault: %e"</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>精彩的<code>Part B</code>！</p>
<h2 id="Part-C"><a href="#Part-C" class="headerlink" title="Part C"></a>Part C</h2><p>实现基本的IPC通信，这部分代码还比较简单。</p>
<h3 id="Exercise-13"><a href="#Exercise-13" class="headerlink" title="Exercise 13"></a>Exercise 13</h3><blockquote>
<p>Modify kern/trapentry.S and kern/trap.c to initialize the appropriate entries in the IDT and provide handlers for IRQs 0 through 15. Then modify the code in<code>env_alloc()</code> in kern/env.c to ensure that user environments are always run with interrupts enabled.</p>
</blockquote>
<p>很简单，像之前注册中断门，这里需要参考<code>intel</code>手册注册相应的IPC门。代码略去。</p>
<p>完成之后，<code>Jos</code>就能进行时钟中断了。</p>
<h3 id="Exercise-14"><a href="#Exercise-14" class="headerlink" title="Exercise 14"></a>Exercise 14</h3><blockquote>
<p>Modify the kernel’s <code>trap_dispatch()</code> function so that it calls <code>sched_yield()</code> to find and run a different environment whenever a clock interrupt takes place.</p>
<p>You should now be able to get the user/spin test to work: the parent environment should fork off the child, <code>sys_yield()</code> to it a couple times but in each case regain control of the CPU after one time slice, and finally kill the child environment and terminate gracefully.</p>
</blockquote>
<p>处理时钟中断。防止进程死循环一直霸占<code>cpu</code>，所以需要在时钟中断处，重新调度进程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (tf-&gt;tf_trapno == IRQ_OFFSET + IRQ_TIMER) &#123;</span><br><span class="line">       lapic_eoi();</span><br><span class="line">       sched_yield();</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Exercise-15"><a href="#Exercise-15" class="headerlink" title="Exercise 15"></a>Exercise 15</h3><blockquote>
<p>Implement <code>sys_ipc_recv</code> and <code>sys_ipc_try_send</code> in kern/syscall.c. Read the comments on both before implementing them, since they have to work together. When you call <code>envid2env</code> in these routines, you should set the <code>checkperm</code> flag to 0, meaning that any environment is allowed to send IPC messages to any other environment, and the kernel does no special permission checking other than verifying that the target envid is valid.</p>
<p>Then implement the <code>ipc_recv</code> and <code>ipc_send</code> functions in lib/ipc.c.</p>
</blockquote>
<p>这几个函数都很好写，因为注释很详细！</p>
<p><code>sys_ipc_recv</code>，这里等待接受信息，只需要改变进程状态，直接调度就会阻塞了。我一开始没反应过来还弄了死循环。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_ipc_recv(<span class="keyword">void</span> *dstva) &#123;</span><br><span class="line">    <span class="keyword">if</span>(dstva &lt; (<span class="keyword">void</span> *)UTOP &amp;&amp; dstva != ROUNDDOWN(dstva, PGSIZE))&#123;</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    curenv-&gt;env_ipc_recving =<span class="literal">true</span>;</span><br><span class="line">    curenv-&gt;env_ipc_dstva = dstva;</span><br><span class="line">    curenv-&gt;env_status = ENV_NOT_RUNNABLE;</span><br><span class="line">    sys_yield();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sys_ipc_try_send</code>需要注意一点就是共享内存时，不能直接使用<code>sys_page_map</code>，因为<code>sys_page_map</code>查找<code>env</code>时会检查权限。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_ipc_try_send(<span class="keyword">envid_t</span> envid, <span class="keyword">uint32_t</span> value, <span class="keyword">void</span> *srcva, <span class="keyword">unsigned</span> perm) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line">    <span class="keyword">int</span> r = envid2env(envid, &amp;env, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> flag = PTE_U | PTE_P;</span><br><span class="line">    <span class="keyword">if</span>(r!=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    <span class="keyword">if</span>(!env-&gt;env_ipc_recving)</span><br><span class="line">        <span class="keyword">return</span> -E_IPC_NOT_RECV;</span><br><span class="line">    <span class="keyword">if</span>(srcva &lt; (<span class="keyword">void</span> *) UTOP)&#123;</span><br><span class="line">        <span class="keyword">if</span>(srcva != ROUNDUP(srcva, PGSIZE))</span><br><span class="line">            <span class="keyword">return</span> -E_INVAL;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">pte_t</span> *pte;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp</span> = <span class="title">page_lookup</span>(<span class="title">curenv</span>-&gt;<span class="title">env_pgdir</span>, <span class="title">srcva</span>, &amp;<span class="title">pte</span>);</span></span><br><span class="line">        <span class="keyword">if</span>(pp == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> -E_INVAL;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((!(perm &amp; (PTE_U | PTE_P))) ||</span><br><span class="line">            (perm &amp; (~(PTE_U | PTE_P | PTE_AVAIL | PTE_W))))</span><br><span class="line">            <span class="keyword">return</span> -E_INVAL;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((perm &amp; PTE_W) &amp;&amp; !(*pte &amp; PTE_W))</span><br><span class="line">            <span class="keyword">return</span> -E_INVAL;</span><br><span class="line"></span><br><span class="line">        r = page_insert(env-&gt;env_pgdir, pp, env-&gt;env_ipc_dstva, perm);</span><br><span class="line">        <span class="keyword">if</span>(r!=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    env-&gt;env_ipc_value = value;</span><br><span class="line">    env-&gt;env_ipc_recving = <span class="literal">false</span>;</span><br><span class="line">    env-&gt;env_ipc_from = curenv-&gt;env_id;</span><br><span class="line">    env-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line">    env-&gt;env_tf.tf_regs.reg_eax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就是函数库的两个函数，是对上面两个系统调用的包装，让用户使用更为方便。没啥可说的，看代码把。</p>
<p><code>ipc_recv</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int32_t</span></span><br><span class="line">ipc_recv(<span class="keyword">envid_t</span> *from_env_store, <span class="keyword">void</span> *pg, <span class="keyword">int</span> *perm_store) &#123;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">if</span>(!pg)&#123;</span><br><span class="line">        pg = (<span class="keyword">void</span> *) <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    r = sys_ipc_recv(pg);</span><br><span class="line">    <span class="keyword">if</span>(r==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(from_env_store)</span><br><span class="line">            *from_env_store = thisenv-&gt;env_ipc_from;</span><br><span class="line">        <span class="keyword">if</span>(perm_store)</span><br><span class="line">            *perm_store = thisenv-&gt;env_ipc_perm;</span><br><span class="line">        <span class="keyword">return</span> thisenv-&gt;env_ipc_value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        *from_env_store = <span class="number">0</span>;</span><br><span class="line">        *perm_store = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ipc_send</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">ipc_send(<span class="keyword">envid_t</span> to_env, <span class="keyword">uint32_t</span> val, <span class="keyword">void</span> *pg, <span class="keyword">int</span> perm) &#123;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">if</span>(!pg)</span><br><span class="line">        pg = (<span class="keyword">void</span> *) <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        r = sys_ipc_try_send(to_env, val, pg, perm);</span><br><span class="line">        <span class="keyword">if</span>(r == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(r != -E_IPC_NOT_RECV)</span><br><span class="line">            panic(<span class="string">"ipc_send:%e"</span>, r);</span><br><span class="line">        sys_yield();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>lab4</code>完。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/02/MIT 6.828 lab4/" data-id="cjg0y8s0d000ll35yix25mjbs" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MIT-6-828/">MIT 6.828</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Operating-system/">Operating system</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/12/07/MIT 6.828 lab5/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          MIT 6.828 lab5
        
      </div>
    </a>
  
  
    <a href="/2016/11/22/MIT 6.828 lab3/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">MIT 6.828 lab3</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithm/">Algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Computer-Network/">Computer Network</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Database-System/">Database System</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Distributed-Computing/">Distributed Computing</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Distributed-System/">Distributed System</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MIT-6-828/">MIT 6.828</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Machine-Learning/">Machine Learning</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Operating-system/">Operating system</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tomcat/">Tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/杂/">杂</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Algorithm/" style="font-size: 20px;">Algorithm</a> <a href="/tags/Android/" style="font-size: 16px;">Android</a> <a href="/tags/Computer-Network/" style="font-size: 10px;">Computer Network</a> <a href="/tags/Database-System/" style="font-size: 10px;">Database System</a> <a href="/tags/Distributed-Computing/" style="font-size: 10px;">Distributed Computing</a> <a href="/tags/Distributed-System/" style="font-size: 10px;">Distributed System</a> <a href="/tags/Java/" style="font-size: 12px;">Java</a> <a href="/tags/MIT-6-828/" style="font-size: 14px;">MIT 6.828</a> <a href="/tags/Machine-Learning/" style="font-size: 12px;">Machine Learning</a> <a href="/tags/Operating-system/" style="font-size: 18px;">Operating system</a> <a href="/tags/Tomcat/" style="font-size: 10px;">Tomcat</a> <a href="/tags/杂/" style="font-size: 10px;">杂</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">October 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">September 2015</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/06/11/Raft 共识算法/">Raft 共识算法</a>
          </li>
        
          <li>
            <a href="/2016/12/30/数据库事务与并发控制/">数据库事务与并发控制</a>
          </li>
        
          <li>
            <a href="/2016/12/18/计算机网络自顶向下之可靠传输协议的笔记/">计算机网络自顶向下之可靠传输协议的笔记</a>
          </li>
        
          <li>
            <a href="/2016/12/07/MIT 6.828 lab5/">MIT 6.828 lab5</a>
          </li>
        
          <li>
            <a href="/2016/12/02/MIT 6.828 lab4/">MIT 6.828 lab4</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>