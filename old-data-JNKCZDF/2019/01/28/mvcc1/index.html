<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 论文笔记 [VLDB '17] An Empirical Evaluation of In-Memory Multi-Version Concurrency Control · 一派胡言</title><meta name="description" content="论文笔记 [VLDB '17] An Empirical Evaluation of In-Memory Multi-Version Concurrency Control - Jian Zhang"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://threezj.com/atom.xml" title="一派胡言"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="https://github.com/zyycj" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">论文笔记 [VLDB '17] An Empirical Evaluation of In-Memory Multi-Version Concurrency Control</h1><div class="post-info">2019年1月28日</div><div class="post-content"><h2 id="Snapshot-Isolation-SI"><a href="#Snapshot-Isolation-SI" class="headerlink" title="Snapshot Isolation(SI)"></a>Snapshot Isolation(SI)</h2><p>MVCC天生是属于SI隔离级别的。SI表示每个事务开始的时候看到的是一个独立的snapshot，在提交的时候如果write未冲突即成功。在SI下会有write skew的异常情况。</p>
<p>write skew可以用白球黑球的例子来说明。比如说现在有一堆球，一半是黑的，一半是白的。现在执行两个事务txn1，txn2。</p>
<ul>
<li>txn1把黑球变成白球</li>
<li>txn2把白球变成黑球</li>
</ul>
<p>如果是SERIALIZABLE隔离级别的，那就相当于事务顺序执行, 最后的结果肯定是全黑或者全白。但如果是SI，两个事务都看到相同的snapshot，并在这基础上修改，就很有可能出现还是一半黑一半白的情况。</p>
<p>只要在range scan的情况下会出现write skew, point update不会有这种情况。</p>
<h2 id="Multi-version-Concurrency-Control-MVCC"><a href="#Multi-version-Concurrency-Control-MVCC" class="headerlink" title="Multi-version Concurrency Control (MVCC)"></a>Multi-version Concurrency Control (MVCC)</h2><p>MVCC是目前最流行事务并发管理的方式。根据字面含义，DBMS会创建多个物理的tuple版本，根据事务版本选择对应的tuple版本返回给当前的事务。MVCC有很多优势，如下。</p>
<ul>
<li><p>writer do not block reader.</p>
<p>需要注意的是，MVCC并不意味只不上锁。比如一个事务t1在写某一个tuple A1，会先对A1上锁，然后生成A2。这个时候假如事务t2要读A1是不行的，只能读A1之前的版本，因为此时t1还没有提交。所以这里的读写互不阻塞指的是事务级别的，写事务不阻塞读事务，不必像2PL那样等到别的事务提交之后才能拿到锁继续执行。</p>
</li>
<li><p>Read-only transactions can read a consistent snapshot without acquiring locks.</p>
<p>consistent指的是所有已提交的事务所做的修改。</p>
</li>
<li><p>Easily support time-travel queries.</p>
<p>很容易追溯过去的版本</p>
</li>
</ul>
<p>一般MVCC的单个tuple含有txn-id(tid), begin-ts, end-ts, pointer这几个字段，不同算法会略有不同。</p>
<p>MVCC涉及到很多数据库设计方式。比如MVCC需要和别的Concurrency Control ptotocol搭配使用，例如T/O, OCC, 2PL等 。主要有四个关键的设计决策。</p>
<ul>
<li>Concurrency Control ptotocol</li>
<li>Version Storage</li>
<li>Garbage Collection</li>
<li>Index Management</li>
</ul>
<p>另外这篇文章不考虑range scan，没有phantoms，所以下面描述的算法都是serializable isolation。该文主要讨论的是in-memory database, 和disk-based DBMS有很多区别，比如write-lock 是直接内嵌在tuple上的，当有事务修改tuple时，会将该tuple的txn-id设置为事务的tid，相当于上了锁，事务提交后将txn-id设为0。</p>
<p>下面是一张论文对现有数据库设计的调研结果。</p>
<p><img src="https://zhang.nos-eastchina1.126.net/blog/WX20190128-220955%402x.png" alt=""><br><a id="more"></a></p>
<h4 id="Concurrency-Control-ptotocol"><a href="#Concurrency-Control-ptotocol" class="headerlink" title="Concurrency Control ptotocol"></a>Concurrency Control ptotocol</h4><ol>
<li><p>Timestamp Ordering(MVTO)</p>
<p>MVTO使用tid来预先定义事务执行的顺序。tuple中额外增加一个read-ts字段，用来保存最后事务读取该tuple的tid。</p>
<ul>
<li>read需要检查当前事务的tid是否落在begin-ts和end-ts之间，并且该tuple没有被别的事务锁定，即txn-id=0或等于tid。如果可以读的话，将read-ts设置为tid。</li>
<li>write需要检查该tuple没有被其他事务锁定，并且tid大于当前tuple的read-ts。如果满足条件则创建新的tuple。</li>
</ul>
</li>
<li><p>Optimistic Concurrency Control(MVOCC)</p>
<p>OCC在事务执行时不做检查。在事务提交的时候，进入Validation Phase之后，会分配一个timestamp，根据这个时间戳判断事务的先后顺序，如不符合则abort。OCC是假设事务冲突的次数会比较少。MVOCC和原始的OCC不同的是，不再维护私有的工作空间，而是生成真正的物理上tuple。具体OCC的算法可以看上一篇博客<a href="http://threezj.com/2019/01/24/occ-silo/">occ</a>。</p>
<p>对长事务最后又abort的这种情况不友好。</p>
</li>
<li><p>Two-phase Locking(MV2PL)</p>
<p>事务需要在对tuple执行操作之前获取锁。write-lock就还是之前txn-id，read-lock额外增加一个字段read-cnt，代表当前读取该tuple的数量。</p>
<ul>
<li>read也是需要根据tid找到一个落在begin-ts和end-ts直接的tuple版本，如果该tuple的txn-id为0的话（其他事务没有获取这个tuple的互斥锁）, 则递增read-cnt</li>
<li>write只有在read-cnt和txn-id都为0的情况下，才能创建新的tuple版本。</li>
</ul>
<p>和常规2PL一样，关键在于如何处理死锁。</p>
</li>
</ol>
<h4 id="Version-Storage"><a href="#Version-Storage" class="headerlink" title="Version Storage"></a>Version Storage</h4><p>MVCC利用pointer将所有版本的tuple串成一个链表管理。索引总是指向链表表头。</p>
<ol>
<li><p>Append-only Storage</p>
<p>所有版本的tuple存在同一个表上。每次write的时候，往同一个表的empty slot中添加。这种方式的区别在于链表链接的顺序。</p>
<ul>
<li><p>Oldest-to-Newest(O2N)</p>
<p>head指向oldest tuple，每次查找都需要从旧往新搜索一遍整个链表。</p>
</li>
<li><p>Newest-to-Oldest(N2O)</p>
<p>head指向newest tuple。插入tuple的时候，需要更新index的指向，但是不需要搜索整个链表。可以让index指向一个逻辑的间接节点，避免频繁更新index。</p>
</li>
</ul>
<p>更适合分析性查询和大块的遍历，因为大部分tuple都连在一起。</p>
</li>
<li><p>Time-Travel Storage</p>
<p>和Append-only的区别就是将older tuple存到不同的表上。</p>
<ul>
<li>每次更新的时候，copy当前版本的tuple到time-travel table上</li>
<li>然后修改main table中的master version为最新的内容，并更新指针指向旧的tuple</li>
</ul>
</li>
<li><p>Delta Storage</p>
<p>这种方式和TIme-Travel的不同在于，每次copy的时候，仅仅copy被修改了的字段。如果需要旧的版本，DBMS需要遍历链表重建tuple。适合write-intensive的workloads，对read-intensive的事务不友好。</p>
</li>
</ol>
<h4 id="Garbage-Collection"><a href="#Garbage-Collection" class="headerlink" title="Garbage Collection"></a>Garbage Collection</h4><p>DBMS需要定期清理无用的tuple来提高查询效率和节省空间。满足以下两个条件，则这个版本的tuple可以被清理。</p>
<ol>
<li>当前所有在运行的事务都看不到这个版本的tuple。</li>
<li>这个tuple是由被abort的事务创造的</li>
</ol>
<p>GC可以分成两种力度</p>
<ol>
<li><p>Tuple Level</p>
<ul>
<li><p>Background Vacuuming(VAC)</p>
<p>开一个额外的线程，搜索所有tuple，找出无效的tuple。这种方式最常见，比较容易。也可以用bitmap来优化，追踪那些dirty block，所以vacuum线程就不需要查找所有的block。</p>
</li>
<li><p>Cooperative Cleaning(COOP)</p>
<p>不开额外的线程。在正常事务执行过程中，遍历tuple链表的时候，同时也判断tuple是否过期，只对O2N有效。这种方式可能会带来额外消耗和漏网之鱼，一般还是会再定期开个线程遍历全表检查一下。</p>
</li>
</ul>
</li>
<li><p>Transaction Level</p>
<p>用这种方式事务需要自己管理它们旧版本的tuple，由DBMS来决定已经结束的事务所产生的tuple是无效的（no longer visible to other txns）。</p>
</li>
</ol>
<h4 id="Index-Management"><a href="#Index-Management" class="headerlink" title="Index Management"></a>Index Management</h4><p>主键索引当然永远指向version chain的head。关键在于secondary index的设计。secondary index的叶子节点的value可以指向一个间接的逻辑节点，也可以直接指向tuple的地址。</p>
<ol>
<li><p>Logical Pointer</p>
<p>这种方式不需要经常修改index，因为它的指向永远是固定。比如说指向主键，但是需要再用主键通过primary index找到对应的tuple，这是额外的消耗。或者指向tupleid，另外维护一个数据结构将tupleid对应到物理的tuple地址。适合write-intensive。</p>
</li>
<li><p>Physical Pointer</p>
<p>直接指向物理的tuple地址。不需要再搜索一次，但需要频繁变更index。适合read-intensive。</p>
</li>
</ol>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>最后论文里测出来的结果Version Storage的格式对数据库性能有很大的影响，而不是传统认为的concurrency control protocols。而concurrency control protocols中，MVTO的效果最均衡，但是生产环境中居然没有数据库用这种算法。GC算法表现最好的是transaction-level GC。索引管理方面，logical pointer总是表现的更好。具体的workloads和测试方法可以看论文。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] An Empirical Evaluation of In-Memory Multi-Version Concurrency Control. VLDB ‘17</p>
</div></article></div></main><footer><div class="paginator"><a href="/2019/03/04/ARIES/" class="prev">上一篇</a><a href="/2019/01/24/occ-silo/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'seansun';
var disqus_identifier = '2019/01/28/mvcc1/';
var disqus_title = '论文笔记 [VLDB '17] An Empirical Evaluation of In-Memory Multi-Version Concurrency Control';
var disqus_url = 'http://threezj.com/2019/01/28/mvcc1/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//seansun.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2019 <a href="http://threezj.com">Jian Zhang</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>