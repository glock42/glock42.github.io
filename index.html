<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 一派胡言</title><meta name="description" content="我向往安静且自由的生活"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://threezj.com/atom.xml" title="一派胡言"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link active">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="https://github.com/zyycj" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/08/20/NFS vs AFS/" class="post-title-link">NFS vs AFS</a></h2><div class="post-info">2018年8月20日</div><div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>周末读了ostep的两篇文章<a href="http://pages.cs.wisc.edu/~remzi/OSTEP/dist-nfs.pdf" target="_blank" rel="noopener">Sun’s Network File System</a>和<a href="http://pages.cs.wisc.edu/~remzi/OSTEP/dist-afs.pdf" target="_blank" rel="noopener">The Andrew File System</a>，都是讲的分布式文件系统，但是侧重的方向不同，导致相关实现也全然不同，写篇笔记对比一下。</p>
<h2 id="NFS"><a href="#NFS" class="headerlink" title="NFS"></a>NFS</h2><p>NFS的goal是fast crash recovery and simple，所以它的设计都是为这个目的服务。</p>
<h4 id="key-design"><a href="#key-design" class="headerlink" title="key design"></a>key design</h4><ul>
<li><p>stateless  </p>
<p>server不保存任何有关client的状态。假如crash，不用做任何操作，直接重启即可。这是一个最重要的设计。需要的信息都通过rpc的参数传递过来。</p>
</li>
<li><p>idempotent</p>
<p>接口都做到幂等性，这样做主要是为了处理message lost 或者 server crash这些情况，client只需要retry即可。</p>
</li>
<li><p>client-cache</p>
<p>这主要为性能考虑，但同时为带来一致性问题。NFS通过前先通过getattr request发送给server，查看cache是否过期，一般是周期性的问一下，比如所3s。同时在close的时候将cache刷回server。</p></div><a href="/2018/08/20/NFS vs AFS/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/07/05/Database concurrency control note/" class="post-title-link">Database concurrency control note</a></h2><div class="post-info">2018年7月5日</div><div class="post-content"><h2 id="Locking-in-B-Tree"><a href="#Locking-in-B-Tree" class="headerlink" title="Locking in B+Tree"></a>Locking in B+Tree</h2><p>使用2PL在index上效果会很差，因为每次使用索引时都会lock root，导致其他事务无法访问。Index一般使用<code>Lock crabbing</code>。</p>
<h4 id="Basic-Lock-Crabbing"><a href="#Basic-Lock-Crabbing" class="headerlink" title="Basic Lock Crabbing"></a>Basic Lock Crabbing</h4><ol>
<li>search<ul>
<li>获取parent的S lock</li>
<li>接着到下一层获取child的S lock</li>
<li>释放上一层parent的S lock，如此循环。</li>
</ul>
</li>
<li>insert/delete<ul>
<li>获取parent的X lock</li>
<li>到下一层，获取child的X lock</li>
<li>如果安全的话则释放parent的X lock。安全即是指child没有分裂或者合并。也就是说有足够的空间插入，或者足够多的节点删除。不然继续到一层，如此循环。</li>
</ul>
</li>
</ol>
<p>在删除或者插入的情况下，如果节点都满或者都不够的话很有可能整条链上都有锁，一直到leaf节点才会逐级向上释放，并发性比较差，由此引入一种优化的方案。<br></div><a href="/2018/07/05/Database concurrency control note/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/06/20/Database join algorithm note/" class="post-title-link">Database join algorithm note</a></h2><div class="post-info">2018年6月20日</div><div class="post-content"><h2 id="Join-algorithm"><a href="#Join-algorithm" class="headerlink" title="Join algorithm"></a>Join algorithm</h2><ul>
<li>Simple Nested Loop Join</li>
<li>Block Nested Loop Join</li>
<li>Index Nested Loop Join</li>
<li>Sort-Merge Join</li>
<li>Hash Join</li>
</ul>
<p>下面以这两张表为例</p>
<p><img src="http://7xrsib.com1.z0.glb.clouddn.com/WX20180620-212956.png" alt=""></p>
<h2 id="Simple-Nested-Loop-Join"><a href="#Simple-Nested-Loop-Join" class="headerlink" title="Simple Nested Loop Join"></a>Simple Nested Loop Join</h2><p>即简单的双重循环。对每一个外层table中的tuple都要scan一遍内层table</p>
<p><code>Cost: M + (m*N)</code><br></div><a href="/2018/06/20/Database join algorithm note/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/05/23/Database Storage and Buffer pools note/" class="post-title-link">Database Storage and Buffer pools note</a></h2><div class="post-info">2018年5月23日</div><div class="post-content"><h2 id="Goals-of-the-DBMS"><a href="#Goals-of-the-DBMS" class="headerlink" title="Goals of the DBMS"></a>Goals of the DBMS</h2><ul>
<li>Allow the DBMS to manage databases that exceed the amount of memory available</li>
<li>Reading/writing to disk is expensive, so it must be managed carefully</li>
</ul>
<p>DBMS总是希望自己来管理所有东西，而不是依靠操作系统</p>
<h2 id="File-Storage"><a href="#File-Storage" class="headerlink" title="File Storage"></a>File Storage</h2><ul>
<li>最简单的形式，一张表存储一个文件。但是也有多个关联的表存在一个文件的实现。</li>
<li>操作系统对于db的文件内容是不关心。</li>
</ul>
<p>每个file由多个page组成，有多种不同的方式来存储，</p>
<ul>
<li>Heap File</li>
<li>Sequential File</li>
<li>Hashing File</li>
<li>Log-Structured File</div><a href="/2018/05/23/Database Storage and Buffer pools note/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/04/28/LFS/" class="post-title-link">论文笔记 [SOSP' 91] The Design and Implementation of a Log-Structured File System</a></h2><div class="post-info">2018年4月28日</div><div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这两天花了点时间读了下<code>The Design and Implementation of a Log-Structured File System</code>，92年的一篇经典文章。Idea其实很简单，就是利用大内存缓存足够多的内容后，然后一次性顺序的写到磁盘中。LFS的所有写入都是顺序添加。极大提升写效率。思想简单，但是实现比较tricky，有各种细节需要注意，却不复杂，很符合人类直觉。</p>
<h2 id="位置在变化的inode"><a href="#位置在变化的inode" class="headerlink" title="位置在变化的inode"></a>位置在变化的inode</h2><p>LFS比较关键的一个点，在于inode不是存在一个fix的位置，而是每次写入一个新的块的时候，都会生成新的inode。之所以这样做是因为，传统的文件系统将inode放在fix位置，当添加或者更新块的时候，需要seek到多个位置去查找inode，查找间接块等，物理运动极其耗时。而LFS这样做了之后，只需要顺序接下去写就行了，但如果是添加的话，还需要读取一次旧的inode块，来维护新的inode块。</p>
<p>但是寻找inode又是一个问题，传统文件中，反正inode数组位置是固定的，只需要位置加上filenumber偏移量就可以了。而在LFS中，存在一个叫imap的数组来索引到最新的inode。也就是说当每次写的时候，在最后总会加上一块imap，来索引最新的inode地址（旧的失效）。到最后整个磁盘中有很多分块的imap。</p>
<p>但是最后还是需要一块fix的位置来存磁盘中所有最新的imap的地址，即checkpoint region(CR)。比如说放在磁盘最开始的地方。CR肯定是需要磁盘seek过去更新，不过这个更新是周期性的，长时间的，比如30秒。而且所有最新imap，是足够小，可以存在内存的。所以只需要磁盘挂载的时候一次性seek到各个位置读入一次所有的imap即可（所有目的都是为了减少seek）。</p>
<p><img src="http://7xrsib.com1.z0.glb.clouddn.com/WX20180428-174248@2x.png" alt=""></p>
<p>大概情况如上图。当然还有目录的情况，目录其实也是个文件(保存file name: file number的映射)    ，所以处理其实是和普通文件一样的。<br></div><a href="/2018/04/28/LFS/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/06/11/Raft 共识算法/" class="post-title-link">Raft 共识算法</a></h2><div class="post-info">2017年6月11日</div><div class="post-content"><h2 id="Raft"><a href="#Raft" class="headerlink" title="Raft"></a>Raft</h2><p>关于<code>mit 6.824</code>，这门课在找工作期间，又拾起来继续做了，断断续续的把<code>lab2</code>做完了，pass掉所有test。完整的实现了<code>Raft</code>算法，对分布式的了解也算是更进了一步。此文会对<code>Raft</code>做一个归纳总结，大部分的内容基于<a href="https://pdos.csail.mit.edu/6.824/papers/raft-extended.pdf" target="_blank" rel="noopener">raft 论文</a> 。</p>
<p><code>Raft</code>是一个共识算法，目的是为了保证多个副本在多个服务器的情况下数据的一致性，以及保证一定的容错能力。</p>
<p><code>Raft</code>的卖点是<code>understandable</code>，论文中一直在强调可理解（这个可理解对没接触过分布式的人来说，其实也不太好理解…）。这个可理解应该是相对于<code>paxos</code>来说的。基于<code>understandable</code>这个目标，<code>Raft</code>把整个共识的过程分成三块，分别是<code>leader election</code>， <code>log replication</code>和<code>safety</code>，下面我们会一一介绍。<br></div><a href="/2017/06/11/Raft 共识算法/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/12/30/数据库事务与并发控制/" class="post-title-link">数据库事务与并发控制</a></h2><div class="post-info">2016年12月30日</div><div class="post-content"><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><blockquote>
<p>数据库事务是<code>DBMS</code>执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。</p>
</blockquote>
<p>事务必须要满足<code>ACID</code>四个特性。</p>
<ul>
<li><p><code>Atomicity</code>(原子性)</p>
<p>也就是所谓的<code>all-or-nothing</code>。单个事务有一系列的操作，比如查找，增加，更新等。当事务提交之后事务中所有对数据库的操作必须反映到数据库上。但如果由于某些原因中断，那么所有对数据的操作必须恢复到这个事务开始之前。也就是事务对数据库的操作，要么全部执行，要么都不执行。</p>
</li>
<li><p><code>Consistency</code>(一致性)</p>
<p>事务开始之前数据满足的完整性约束，在事务结束之后也需要满足。其实也就是事务得到了正确的执行。</p>
</li>
<li><p><code>Isolation</code>(隔离性)</p>
<p>每个事务之间是相互独立的。有点类似于进程的概念。因为事务是并发执行的，所以事务之间不能相互影响不然就有可能破坏<code>一致性</code>。</p>
</li>
<li><p><code>Durability</code>(持久性)</p>
<p>已被提交的事务对数据库的修改应该永久保存在数据库中。这里的关键应该在于永久二字，也就是说即使系统崩溃、硬盘损坏等不可控因素发生，也要保证数据仍然存在数据库中。所以备份很重要啊。</p></div><a href="/2016/12/30/数据库事务与并发控制/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/12/18/计算机网络自顶向下之可靠传输协议的笔记/" class="post-title-link">计算机网络自顶向下之可靠传输协议的笔记</a></h2><div class="post-info">2016年12月18日</div><div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>此篇文章是<code>计算机网络 自顶向下方法</code>第三章的简略版笔记，这一章非常精彩。个人认为运输层可以说是计算网络中最重要的一层，分别面向应用层以及网络层。众所周知，网络层是无法保证可靠传输的。所以运输层根本的问题在于<code>如何能够在不可靠的网络层之上进行可靠的网络</code>。</p>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p><code>UDP</code>几乎没有做事情，仅仅只是把应用层的数据加上报文段，然后交付给网络层，虽然<code>UDP</code>有差错检查，但它也只是丢弃这个包而已。应用程序采用<code>UDP</code>的主要是基于效率的考虑。<code>UDP</code>简单，所以效率高。本文不讨论<code>UDP</code>。</p>
<h2 id="可靠数据传输"><a href="#可靠数据传输" class="headerlink" title="可靠数据传输"></a>可靠数据传输</h2><p>这一节我们从最简单的情况开始，针对各种情况，慢慢完善，最终形成一个可靠的数据传输协议。<code>TCP</code>是一个<code>全双工</code>的协议，双方可以互相发送信息。目前我们只考虑单向的传输。</p>
<h4 id="假设网络层可靠"><a href="#假设网络层可靠" class="headerlink" title="假设网络层可靠"></a>假设网络层可靠</h4><p>最开始我们先假设网络层是可靠的，也就是说我们交付给网络层的包不会丢失且完好无损，同时假设发送和接受双方速率是一样的。这种情况下我们需要考虑什么？什么都不需要考虑。就像<code>UDP</code>一样，打包好交付给网络层即可。相当于在网络层实现了可靠传输。<br></div><a href="/2016/12/18/计算机网络自顶向下之可靠传输协议的笔记/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/12/07/MIT 6.828 lab5/" class="post-title-link">MIT 6.828 lab5</a></h2><div class="post-info">2016年12月7日</div><div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>lab5</code>比较简单，相对于之前的<code>lab</code>来说。主要就是完成简单的文件系统。大部分代码<code>mit</code>都已经帮你搭好了。</p>
<h2 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise 1"></a>Exercise 1</h2><blockquote>
<p><code>i386_init</code> identifies the file system environment by passing the type <code>ENV_TYPE_FS</code> to your environment creation function, <code>env_create</code>. Modify <code>env_create</code> in env.c, so that it gives the file system environment I/O privilege, but never gives that privilege to any other environment</p>
</blockquote>
<p>启动<code>IO</code>驱动器，设置一下标志位即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(type == ENV_TYPE_FS)&#123;</span><br><span class="line">       e-&gt;env_tf.tf_eflags |= FL_IOPL_3;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="Question-1"><a href="#Question-1" class="headerlink" title="Question 1"></a>Question 1</h4><blockquote>
<p>Do you have to do anything else to ensure that this I/O privilege setting is saved and restored properly when you subsequently switch from one environment to another? Why?</p>
</blockquote>
<p>不需要。因为进程切换时会保存<code>Trapframe</code>。</p>
<h2 id="Exercise-2"><a href="#Exercise-2" class="headerlink" title="Exercise 2"></a>Exercise 2</h2><blockquote>
<p>Implement the <code>bc_pgfault</code> and <code>flush_block</code> functions in fs/bc.c. <code>bc_pgfault</code> is a page fault handler, just like the one your wrote in the previous lab for copy-on-write fork, except that its job is to load pages in from the disk in response to a page fault. When writing this, keep in mind that (1) <code>addr</code> may not be aligned to a block boundary and (2) <code>ide_read</code> operates in sectors, not blocks.</p>
</blockquote>
<p>我们用<code>3G</code>的内存地址来映射磁盘。从<code>DISKMAP</code>至<code>DISKMAP+DISKMAX</code>。但是不可能把整块磁盘的内容都加载到内存中来。所以我们采用类似于<code>COW</code>的方式，延迟到<code>page fault</code>时，再从磁盘中读取，这种方式抽象了整个磁盘都在内存中的假象，并且以有限的内存空间，支持更大的磁盘读取。</p>
<p><code>bc_pgfault</code> 当产生<code>page fault</code>，说明这一页还未读取到内存中，则先分配一页，然后进行读取。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">addr = ROUNDDOWN(addr, PGSIZE);</span><br><span class="line">   r = sys_page_alloc(<span class="number">0</span>, addr, PTE_P | PTE_U | PTE_W);</span><br><span class="line">   <span class="keyword">if</span>(r != <span class="number">0</span>)</span><br><span class="line">       panic(<span class="string">"bc.c: paga_alloc failed %e"</span>, r);</span><br><span class="line">   r = ide_read(blockno * BLKSECTS, addr, BLKSECTS);</span><br><span class="line">   <span class="keyword">if</span>(r != <span class="number">0</span>)</span><br><span class="line">       panic(<span class="string">"bc.c: ide_read failed %e"</span>, r);</span><br></pre></td></tr></table></figure>
<p><code>flush_block</code> 内存中的内容被修改之后，需要写回到磁盘中。因为本质上它就是一块<code>Cache</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flush_block</span><span class="params">(<span class="keyword">void</span> *addr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> blockno = ((<span class="keyword">uint32_t</span>)addr - DISKMAP) / BLKSIZE;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">if</span> (addr &lt; (<span class="keyword">void</span>*)DISKMAP || addr &gt;= (<span class="keyword">void</span>*)(DISKMAP + DISKSIZE))</span><br><span class="line">        panic(<span class="string">"flush_block of bad va %08x"</span>, addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(va_is_mapped(addr) &amp;&amp; va_is_dirty(addr)))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    addr = ROUNDDOWN(addr, PGSIZE);</span><br><span class="line">    <span class="keyword">if</span>(va_is_mapped(addr) &amp;&amp; va_is_dirty(addr))&#123;</span><br><span class="line">        r = ide_write(blockno * BLKSECTS, addr, BLKSECTS);</span><br><span class="line">        <span class="keyword">if</span>(r != <span class="number">0</span>)</span><br><span class="line">            panic(<span class="string">"flush_block: ide_write failed %e"</span>, r);</span><br><span class="line">        r = sys_page_map(<span class="number">0</span>, addr, <span class="number">0</span>, addr, uvpt[PGNUM(addr)] &amp; PTE_SYSCALL);</span><br><span class="line">        <span class="keyword">if</span>(r != <span class="number">0</span>)</span><br><span class="line">            panic(<span class="string">"flush_block: sys_page_map failed %e"</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><a href="/2016/12/07/MIT 6.828 lab5/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/12/02/MIT 6.828 lab4/" class="post-title-link">MIT 6.828 lab4</a></h2><div class="post-info">2016年12月2日</div><div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>lab4</code>终于完成了。<code>lab4</code>是到目前为止，比较复杂而且代码最多的<code>lab</code>。总共需要完成三个部分。<code>part A</code>添加多核支持，实现<code>RR</code>调度。<code>part B</code>实现<code>Copy-On-Write fork</code>。<code>part C</code> 实现时钟中断以及支持基本的<code>IPC</code>。</p>
<h2 id="Part-A"><a href="#Part-A" class="headerlink" title="Part A"></a>Part A</h2><h4 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise 1"></a>Exercise 1</h4><blockquote>
<p>Implement <code>mmio_map_region</code> in kern/pmap.c. To see how this is used, look at the beginning of <code>lapic_init</code> in kern/lapic.c. You’ll have to do the next exercise, too, before the tests for <code>mmio_map_region</code> will run.</p>
</blockquote>
<p>实现需要让<code>Jos</code>支持<code>symmetric multiprocessing</code>，也就是所有的<code>cpu</code>都拥有相同的权限去访问资源。<code>Jos</code>使用<code>LAPIC</code>来分发中断，以及通过它来知道当前使用的<code>cpu</code>。而处理器访问<code>LAPIC</code>，需要使用<code>MMIO</code>。所以我们需要对<code>MMIO</code>进行内存映射，这个函数比较简单。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line">mmio_map_region(<span class="keyword">physaddr_t</span> pa, <span class="keyword">size_t</span> size) &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">uintptr_t</span> base = MMIOBASE;</span><br><span class="line"></span><br><span class="line">    size = ROUNDUP(size, PGSIZE);</span><br><span class="line">    <span class="keyword">if</span>(base + size &gt; MMIOLIM)&#123;</span><br><span class="line">        panic(<span class="string">"mmio_map_region: reservation mem overflow"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    boot_map_region(kern_pgdir, base, size, pa, PTE_W | PTE_PCD | PTE_P);</span><br><span class="line">    <span class="keyword">uintptr_t</span> b = base;</span><br><span class="line">    base += size;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span> *) b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><a href="/2016/12/02/MIT 6.828 lab4/" class="read-more">...阅读全文</a></article></li></ul></main><footer><div class="paginator"><a href="/page/2/" class="next">下一页</a></div><div class="copyright"><p>© 2015 - 2018 <a href="http://threezj.com">Jian Zhang</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>