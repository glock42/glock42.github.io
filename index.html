<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 一派胡言</title><meta name="description" content="我向往安静且自由的生活"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://threezj.com/atom.xml" title="一派胡言"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link active">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="https://github.com/zyycj" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="https://weibo.com/zjthree" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/04/28/LFS/" class="post-title-link"></a></h2><div class="post-info">2018年4月28日</div><div class="post-content"></div><a href="/2018/04/28/LFS/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/06/11/Raft 共识算法/" class="post-title-link">Raft 共识算法</a></h2><div class="post-info">2017年6月11日</div><div class="post-content"><h2 id="Raft"><a href="#Raft" class="headerlink" title="Raft"></a>Raft</h2><p>关于<code>mit 6.824</code>，这门课在找工作期间，又拾起来继续做了，断断续续的把<code>lab2</code>做完了，pass掉所有test。完整的实现了<code>Raft</code>算法，对分布式的了解也算是更进了一步。此文会对<code>Raft</code>做一个归纳总结，大部分的内容基于<a href="https://pdos.csail.mit.edu/6.824/papers/raft-extended.pdf" target="_blank" rel="noopener">raft 论文</a> 。</p>
<p><code>Raft</code>是一个共识算法，目的是为了保证多个副本在多个服务器的情况下数据的一致性，以及保证一定的容错能力。</p>
<p><code>Raft</code>的卖点是<code>understandable</code>，论文中一直在强调可理解（这个可理解对没接触过分布式的人来说，其实也不太好理解…）。这个可理解应该是相对于<code>paxos</code>来说的。基于<code>understandable</code>这个目标，<code>Raft</code>把整个共识的过程分成三块，分别是<code>leader election</code>， <code>log replication</code>和<code>safety</code>，下面我们会一一介绍。<br></div><a href="/2017/06/11/Raft 共识算法/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/12/30/数据库事务与并发控制/" class="post-title-link">数据库事务与并发控制</a></h2><div class="post-info">2016年12月30日</div><div class="post-content"><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><blockquote>
<p>数据库事务是<code>DBMS</code>执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。</p>
</blockquote>
<p>事务必须要满足<code>ACID</code>四个特性。</p>
<ul>
<li><p><code>Atomicity</code>(原子性)</p>
<p>也就是所谓的<code>all-or-nothing</code>。单个事务有一系列的操作，比如查找，增加，更新等。当事务提交之后事务中所有对数据库的操作必须反映到数据库上。但如果由于某些原因中断，那么所有对数据的操作必须恢复到这个事务开始之前。也就是事务对数据库的操作，要么全部执行，要么都不执行。</p>
</li>
<li><p><code>Consistency</code>(一致性)</p>
<p>事务开始之前数据满足的完整性约束，在事务结束之后也需要满足。其实也就是事务得到了正确的执行。</p>
</li>
<li><p><code>Isolation</code>(隔离性)</p>
<p>每个事务之间是相互独立的。有点类似于进程的概念。因为事务是并发执行的，所以事务之间不能相互影响不然就有可能破坏<code>一致性</code>。</p>
</li>
<li><p><code>Durability</code>(持久性)</p>
<p>已被提交的事务对数据库的修改应该永久保存在数据库中。这里的关键应该在于永久二字，也就是说即使系统崩溃、硬盘损坏等不可控因素发生，也要保证数据仍然存在数据库中。所以备份很重要啊。</p></div><a href="/2016/12/30/数据库事务与并发控制/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/12/18/计算机网络自顶向下之可靠传输协议的笔记/" class="post-title-link">计算机网络自顶向下之可靠传输协议的笔记</a></h2><div class="post-info">2016年12月18日</div><div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>此篇文章是<code>计算机网络 自顶向下方法</code>第三章的简略版笔记，这一章非常精彩。个人认为运输层可以说是计算网络中最重要的一层，分别面向应用层以及网络层。众所周知，网络层是无法保证可靠传输的。所以运输层根本的问题在于<code>如何能够在不可靠的网络层之上进行可靠的网络</code>。</p>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p><code>UDP</code>几乎没有做事情，仅仅只是把应用层的数据加上报文段，然后交付给网络层，虽然<code>UDP</code>有差错检查，但它也只是丢弃这个包而已。应用程序采用<code>UDP</code>的主要是基于效率的考虑。<code>UDP</code>简单，所以效率高。本文不讨论<code>UDP</code>。</p>
<h2 id="可靠数据传输"><a href="#可靠数据传输" class="headerlink" title="可靠数据传输"></a>可靠数据传输</h2><p>这一节我们从最简单的情况开始，针对各种情况，慢慢完善，最终形成一个可靠的数据传输协议。<code>TCP</code>是一个<code>全双工</code>的协议，双方可以互相发送信息。目前我们只考虑单向的传输。</p>
<h4 id="假设网络层可靠"><a href="#假设网络层可靠" class="headerlink" title="假设网络层可靠"></a>假设网络层可靠</h4><p>最开始我们先假设网络层是可靠的，也就是说我们交付给网络层的包不会丢失且完好无损，同时假设发送和接受双方速率是一样的。这种情况下我们需要考虑什么？什么都不需要考虑。就像<code>UDP</code>一样，打包好交付给网络层即可。相当于在网络层实现了可靠传输。<br></div><a href="/2016/12/18/计算机网络自顶向下之可靠传输协议的笔记/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/12/07/MIT 6.828 lab5/" class="post-title-link">MIT 6.828 lab5</a></h2><div class="post-info">2016年12月7日</div><div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>lab5</code>比较简单，相对于之前的<code>lab</code>来说。主要就是完成简单的文件系统。大部分代码<code>mit</code>都已经帮你搭好了。</p>
<h2 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise 1"></a>Exercise 1</h2><blockquote>
<p><code>i386_init</code> identifies the file system environment by passing the type <code>ENV_TYPE_FS</code> to your environment creation function, <code>env_create</code>. Modify <code>env_create</code> in env.c, so that it gives the file system environment I/O privilege, but never gives that privilege to any other environment</p>
</blockquote>
<p>启动<code>IO</code>驱动器，设置一下标志位即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(type == ENV_TYPE_FS)&#123;</span><br><span class="line">       e-&gt;env_tf.tf_eflags |= FL_IOPL_3;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="Question-1"><a href="#Question-1" class="headerlink" title="Question 1"></a>Question 1</h4><blockquote>
<p>Do you have to do anything else to ensure that this I/O privilege setting is saved and restored properly when you subsequently switch from one environment to another? Why?</p>
</blockquote>
<p>不需要。因为进程切换时会保存<code>Trapframe</code>。</p>
<h2 id="Exercise-2"><a href="#Exercise-2" class="headerlink" title="Exercise 2"></a>Exercise 2</h2><blockquote>
<p>Implement the <code>bc_pgfault</code> and <code>flush_block</code> functions in fs/bc.c. <code>bc_pgfault</code> is a page fault handler, just like the one your wrote in the previous lab for copy-on-write fork, except that its job is to load pages in from the disk in response to a page fault. When writing this, keep in mind that (1) <code>addr</code> may not be aligned to a block boundary and (2) <code>ide_read</code> operates in sectors, not blocks.</p>
</blockquote>
<p>我们用<code>3G</code>的内存地址来映射磁盘。从<code>DISKMAP</code>至<code>DISKMAP+DISKMAX</code>。但是不可能把整块磁盘的内容都加载到内存中来。所以我们采用类似于<code>COW</code>的方式，延迟到<code>page fault</code>时，再从磁盘中读取，这种方式抽象了整个磁盘都在内存中的假象，并且以有限的内存空间，支持更大的磁盘读取。</p>
<p><code>bc_pgfault</code> 当产生<code>page fault</code>，说明这一页还未读取到内存中，则先分配一页，然后进行读取。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">addr = ROUNDDOWN(addr, PGSIZE);</span><br><span class="line">   r = sys_page_alloc(<span class="number">0</span>, addr, PTE_P | PTE_U | PTE_W);</span><br><span class="line">   <span class="keyword">if</span>(r != <span class="number">0</span>)</span><br><span class="line">       panic(<span class="string">"bc.c: paga_alloc failed %e"</span>, r);</span><br><span class="line">   r = ide_read(blockno * BLKSECTS, addr, BLKSECTS);</span><br><span class="line">   <span class="keyword">if</span>(r != <span class="number">0</span>)</span><br><span class="line">       panic(<span class="string">"bc.c: ide_read failed %e"</span>, r);</span><br></pre></td></tr></table></figure>
<p><code>flush_block</code> 内存中的内容被修改之后，需要写回到磁盘中。因为本质上它就是一块<code>Cache</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flush_block</span><span class="params">(<span class="keyword">void</span> *addr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> blockno = ((<span class="keyword">uint32_t</span>)addr - DISKMAP) / BLKSIZE;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">if</span> (addr &lt; (<span class="keyword">void</span>*)DISKMAP || addr &gt;= (<span class="keyword">void</span>*)(DISKMAP + DISKSIZE))</span><br><span class="line">        panic(<span class="string">"flush_block of bad va %08x"</span>, addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(va_is_mapped(addr) &amp;&amp; va_is_dirty(addr)))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    addr = ROUNDDOWN(addr, PGSIZE);</span><br><span class="line">    <span class="keyword">if</span>(va_is_mapped(addr) &amp;&amp; va_is_dirty(addr))&#123;</span><br><span class="line">        r = ide_write(blockno * BLKSECTS, addr, BLKSECTS);</span><br><span class="line">        <span class="keyword">if</span>(r != <span class="number">0</span>)</span><br><span class="line">            panic(<span class="string">"flush_block: ide_write failed %e"</span>, r);</span><br><span class="line">        r = sys_page_map(<span class="number">0</span>, addr, <span class="number">0</span>, addr, uvpt[PGNUM(addr)] &amp; PTE_SYSCALL);</span><br><span class="line">        <span class="keyword">if</span>(r != <span class="number">0</span>)</span><br><span class="line">            panic(<span class="string">"flush_block: sys_page_map failed %e"</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><a href="/2016/12/07/MIT 6.828 lab5/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/12/02/MIT 6.828 lab4/" class="post-title-link">MIT 6.828 lab4</a></h2><div class="post-info">2016年12月2日</div><div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>lab4</code>终于完成了。<code>lab4</code>是到目前为止，比较复杂而且代码最多的<code>lab</code>。总共需要完成三个部分。<code>part A</code>添加多核支持，实现<code>RR</code>调度。<code>part B</code>实现<code>Copy-On-Write fork</code>。<code>part C</code> 实现时钟中断以及支持基本的<code>IPC</code>。</p>
<h2 id="Part-A"><a href="#Part-A" class="headerlink" title="Part A"></a>Part A</h2><h4 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise 1"></a>Exercise 1</h4><blockquote>
<p>Implement <code>mmio_map_region</code> in kern/pmap.c. To see how this is used, look at the beginning of <code>lapic_init</code> in kern/lapic.c. You’ll have to do the next exercise, too, before the tests for <code>mmio_map_region</code> will run.</p>
</blockquote>
<p>实现需要让<code>Jos</code>支持<code>symmetric multiprocessing</code>，也就是所有的<code>cpu</code>都拥有相同的权限去访问资源。<code>Jos</code>使用<code>LAPIC</code>来分发中断，以及通过它来知道当前使用的<code>cpu</code>。而处理器访问<code>LAPIC</code>，需要使用<code>MMIO</code>。所以我们需要对<code>MMIO</code>进行内存映射，这个函数比较简单。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line">mmio_map_region(<span class="keyword">physaddr_t</span> pa, <span class="keyword">size_t</span> size) &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">uintptr_t</span> base = MMIOBASE;</span><br><span class="line"></span><br><span class="line">    size = ROUNDUP(size, PGSIZE);</span><br><span class="line">    <span class="keyword">if</span>(base + size &gt; MMIOLIM)&#123;</span><br><span class="line">        panic(<span class="string">"mmio_map_region: reservation mem overflow"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    boot_map_region(kern_pgdir, base, size, pa, PTE_W | PTE_PCD | PTE_P);</span><br><span class="line">    <span class="keyword">uintptr_t</span> b = base;</span><br><span class="line">    base += size;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span> *) b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><a href="/2016/12/02/MIT 6.828 lab4/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/11/22/MIT 6.828 lab3/" class="post-title-link">MIT 6.828 lab3</a></h2><div class="post-info">2016年11月22日</div><div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这次<code>lab</code>的<code>Part A</code>让操作系统支持进程(单进程)，<code>Part B</code>处理了异常中断，使其能在<code>kernel态</code>和<code>用户态</code>进行切换。我觉得这次lab不算很难，可能是因为经过了前面两个lab洗礼的缘故。但还是在中断跳转那里卡了好一会，不会写汇编啊。</p>
<h2 id="Part-A"><a href="#Part-A" class="headerlink" title="Part A"></a>Part A</h2><p>在<code>Jos</code>中 我们用<code>Env</code>结构体来描述进程，关于Env，讲义中已经很清楚了，这里不赘述。关键点是通过<code>envs</code>数组和<code>env_free_list</code>来维护数组，这里需要注意的是<code>env_free_list</code>，不是像之前<code>free_page_list</code>那样是反向。这里需要和<code>envs</code>的顺序相同。</p>
<h4 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise 1"></a>Exercise 1</h4><blockquote>
<p>Modify <code>mem_init()</code> in kern/pmap.c to allocate and map the <code>envs</code> array. This array consists of exactly <code>NENV</code> instances of the <code>Env</code> structure allocated much like how you allocated the <code>pages</code> array. Also like the <code>pages</code> array, the memory backing <code>envs</code> should also be mapped user read-only at <code>UENVS</code> (defined in inc/memlayout.h) so user processes can read from this array.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">envs = (struct Env *) boot_alloc(NENV * <span class="keyword">sizeof</span>(struct Env));</span><br><span class="line">boot_map_region(kern_pgdir, UENVS, PTSIZE, PADDR(envs), PTE_U);</span><br></pre></td></tr></table></figure>
<p>这个应该轻车熟路了，就是为<code>envs</code>分配内存，并开启虚拟映射。<br></div><a href="/2016/11/22/MIT 6.828 lab3/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/11/14/MIT 6.828 lab2/" class="post-title-link">MIT 6.828 lab2</a></h2><div class="post-info">2016年11月14日</div><div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这个<code>lab</code>主要是写内存管理相关的代码。实现操作系统必须满足三个要求<code>multiplexing, isolation, and interaction</code> 。翻译成中文就是<code>复用，隔离和相互作用</code>。这三个条件其实主要靠抽象完成。<code>复用</code> 比如<code>IO</code>读写，都对文件描述符进行处理，而不管底下是网络读写还是磁盘读写等。<code>隔离</code>抽象地址空间，每个进程拥有一个自己的地址空间，相互并不影响。<code>相互作用</code>也需要抽象的控制，防止一些恶意的软件。</p>
<p><code>lab2</code>关注点在于如何实现地址空间。<code>jos</code>通过实现分页管理来实现。操作系统中所有程序接触的地址都是虚拟地址，然后硬件上真正需要的则是物理地址，所以中间则是使用<code>MMU(memory management unit)</code>来把虚拟地址翻译为物理地址。</p>
<h2 id="连续的内存分配"><a href="#连续的内存分配" class="headerlink" title="连续的内存分配"></a>连续的内存分配</h2><p>早期操作系统都是直接操作物理地址，很明显，这样做有着致命的缺点。比如用户程序可以直接访问<code>kernel</code>地址，导致系统崩溃，多个用户程序程序直接相互影响。即使设立了保护机制，也就是通过一些<code>flag</code>来辨别是否可以访问，但还是会有问题。就是当两个进程同时载入内存时，会进行地址偏移，跳转到指令并不会是程序中原先的指令，此时需要进行<code>重定位</code>，就是扫描一遍程序，给程序中涉及到的地址加上偏移量。但是这种方法效率是很低的。需要为每个需要执行的程序进行扫描判定计算。</p>
<h4 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h4><p>所以这里我们提出了<code>地址空间</code>的概念。重点还是抽象。我门让每个进程处于独立的进程空间中。比如虽然两个进程都指向同一个虚拟地址，但是实际所指的物理地址是不同的。</p>
<h4 id="基地寄存器和界限寄存器"><a href="#基地寄存器和界限寄存器" class="headerlink" title="基地寄存器和界限寄存器"></a>基地寄存器和界限寄存器</h4><p>其实就是动态重定位。把重定位的时间推迟了，之前的重定位一般发生在加载时，而现在推迟到访问内存时，并且减少了扫描查找的时间。通过两个寄存器来保存进程的起始地址和进程使用空间的长度。当程序访问内存时，自动加上偏移量，如果超出界限，则产生错误。但这种方法还是不够快，需要进行计算，比较可以进行的很快，但计算不行。进行动态重定位之后地址称为<code>线性地址</code><br></div><a href="/2016/11/14/MIT 6.828 lab2/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/11/06/MIT 6.828 lab1/" class="post-title-link">MIT 6.828 lab1</a></h2><div class="post-info">2016年11月6日</div><div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>开启一场漫长且有趣的旅程，即日起开始学习<code>MIT 6.828</code>。总共有七个<code>lab</code>。<code>lab6</code>和<code>lab7</code>其中选一个做。</p>
<h2 id="PC启动流程简述"><a href="#PC启动流程简述" class="headerlink" title="PC启动流程简述"></a>PC启动流程简述</h2><p>先了解一下当<code>PC</code>加电后，整个物理地址空间分布。</p>
<p><img src="http://7xrsib.com1.z0.glb.clouddn.com/2016-11-03%2020-55-37%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p>
<p>早期的<code>16位</code>计算机是只有<code>1MB</code>的寻址能力。也就是说只能使用<code>0x0000 - 0xffff</code>这么多，如上图所示，<code>640kb</code>以下的部分为早期计算机使用的部分。而上面<code>640kb - 1mb</code>的这些地方则保留下来作为特殊使用，比如视频显示之类的。其中最重要的部分为<code>BIOS( Basic Input/Output System)</code>，<code>BIOS</code>的主要责任为进行一些自检，然后从启动设备中，并载入它的第一扇区到内存的特定位置，即<code>0x7c00</code>，然后跳转到这个位置继续执行。此时，<code>BIOS</code>的工作完成。<code>0x7c00</code> 即是<code>bootloader</code>的入口点。</p>
<p>当现代计算机突破了<code>1MB</code>内存，达到<code>4GB</code>甚至更多的时候，依然保留了最开始的<code>1M</code>内存空间。所以开始一开始加电以后，是处于实模式的，也就是只有<code>1MB</code>内存可以访问。<code>bootloader</code>会把实模式切换到保护模式。也就是<code>4GB</code>寻址模式。然后再读取<code>kernel</code>到内存中，并且把控制权转给<code>kernel</code>。至此操作系统才算真正的启动起来。</p>
<p>下面简单总结下启动流程。</p>
<ol>
<li><code>PC</code>启动，并且执行第一条指令，位于<code>0xffff0</code>。是一条跳转指令，跳到<code>BIOS</code>刚开始的地方</li>
<li><code>BIOS</code> 进行初始化。</li>
<li><code>BIOS</code>搜寻启动设备，并加载<code>bootloader</code>到内存中，转移控制给<code>bootloader</code></li>
<li><code>bootloader</code>从实模式切换到保护模式</li>
<li><code>bootloader</code>从硬盘中读取<code>kernel</code>到内存中，并转移控制给<code>kernel</code></li>
<li>操作系统启动</div><a href="/2016/11/06/MIT 6.828 lab1/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/10/30/生成学习算法/" class="post-title-link">生成学习算法</a></h2><div class="post-info">2016年10月30日</div><div class="post-content"><h2 id="生成学习算法"><a href="#生成学习算法" class="headerlink" title="生成学习算法"></a>生成学习算法</h2><p>可能大部分人之前学过的分类算法，都是基于<code>train data</code>来最佳化参数，从而得到<code>data</code>的类别。也就是基于<code>p(y|x; θ)</code>来进行学习，比如<code>Logistic Regression</code>。现在我们换一种思路，反过来求解，分别对<code>p(x|y)</code> 求解，也就是说，对每一个<code>y</code>，<code>model</code>一个概率模型。当需要对新的<code>data</code>分类时，分别计算属于每个类的概率，从而得到最优的类别。公式基于贝叶斯定理,如下所示。</p>
<p><img src="http://7xrsib.com1.z0.glb.clouddn.com/2016-10-29%2023-45-27%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""><br></div><a href="/2016/10/30/生成学习算法/" class="read-more">...阅读全文</a></article></li></ul></main><footer><div class="paginator"><a href="/page/2/" class="next">下一页</a></div><div class="copyright"><p>© 2015 - 2018 <a href="http://threezj.com">Jian Zhang</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>