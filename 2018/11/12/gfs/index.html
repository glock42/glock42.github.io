<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 论文笔记 [SOSP '03] The Google File System · 一派胡言</title><meta name="description" content="论文笔记 [SOSP '03] The Google File System - Jian Zhang"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://threezj.com/atom.xml" title="一派胡言"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="https://github.com/zyycj" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">论文笔记 [SOSP '03] The Google File System</h1><div class="post-info">2018年11月12日</div><div class="post-content"><p>google file system， 谷歌经典论文之一。GFS通过single master，Garbage Collection，control path 与data path分离等机制，很好的在便宜机器上实现了Availability, recoverability, High throughput。但是GFS针对的是特定的workloads（写一次，读多次，大批量的读等），并且需要appication支持, 以避免不一致数据的情况。</p>
<h2 id="Assumptions"><a href="#Assumptions" class="headerlink" title="Assumptions"></a>Assumptions</h2><p>既然是google file system，当然是针对google的应用场景做的优化。这篇发在03年的sosp，现在workloads已经变了很多了，gfs已经有了第二代Colossus，不过没paper出来。</p>
<ul>
<li>便宜的设备，会经常损坏(fault tolerate)</li>
<li>大量的大文件，基本都在100MB以上或者更大，GB级别的文件是很常见的</li>
<li>read workloads:  Mostly large streaming reads（1MB or more）和Some sorted random reads(a few KB)。</li>
<li>write workloads: many large，sequential write。append居多。写一次，读多次。</li>
<li>多用户并发向同一个文件进行append操作</li>
<li>google的大都是高速批量写入的应用，所以它更要求持久稳定的带宽。<a id="more"></a>
</li>
</ul>
<h2 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h2><p>GFS是一个single master，multiple chunkserver的架构。 比较有意思的是GFS将control path 和data path做了分离。所有的control path从master走，data path由client直接与chunkserver通信。</p>
<p>master存metadata，比如namespace，控制权限等。这些信息都是存在内存里的，用WAL保证持久。WAL会有副本（replication state machine），防止master挂掉导致不可用。这里注意的是，尽管所有chunk的metadata都存在master内存中，但这并不会成为一个瓶颈。因为数据量非常小，每个文件64bytes（利用前缀压缩）。</p>
<p>master和chunkserver直接通过heartbeat（心跳包）通信来监测chunk 的位置等信息。</p>
<p><img src="https://zhang.nos-eastchina1.126.net/blog/gfs1.png" alt=""></p>
<h4 id="chunk"><a href="#chunk" class="headerlink" title="chunk"></a>chunk</h4><p>每一个文件被分成了多个固定大小的chunk（64MB）。chunk就是直接存在chunkserver上的，就是一个单个机器上就是一个普通的文件存在ext4或别的文件系统。chunk会存在多个副本在不同的chunkserver上。需要注意的是chunk比linux上普通的block要大很多，这是基于google应用场景做的优化（large streaming read）。这么做存在一些优缺点。</p>
<ul>
<li>advantages<ul>
<li>减少了client和master通信的次数。因为同一个chunk，client只需要最开始的时候向mater要一下location即可。</li>
<li>减少网络通信。</li>
<li>减少master需要管理的metadata。</li>
</ul>
</li>
<li>disadvantages<ul>
<li>当文件很小时，单个chunk就是一个文件。假如这个文件是热点数据。同时几百个client同时请求同一个chunk，chunkserver会过载。这种情况可以通过调整chunk副本数量来做负载均衡。或者让client从别的client那里读chunk（减少chunkserver压力）。</li>
</ul>
</li>
</ul>
<h2 id="Consistency-Model"><a href="#Consistency-Model" class="headerlink" title="Consistency Model"></a>Consistency Model</h2><p>首先gfs提出了几个名词来表示consistency。</p>
<ul>
<li>consistent: 所有client都看到相同的数据，无所是从哪个副本读的。</li>
<li>defined: 当发出一个mutation后，所有client都能看到这个mutation修改后的数据。</li>
<li>consistent but undefined: 所有client都看到相同的数据，但并不反映任何一个mutation修改后的结果。（多个client并发操作）</li>
</ul>
<p>如下图。</p>
<p><img src="https://zhang.nos-eastchina1.126.net/blog/gfs2.png" alt=""></p>
<p>metadata修改都是原子的，master内部会用锁和全局有序的log来保证这个。这也是single master的好处。</p>
<p>data修改的顺序是由primary server定的。串行写可以保证所有副本的defined。但是多个client并发写，数据就会出现被覆盖等情况，即consistent but undefined。这是write的情况，即由用户指定offset的情况。</p>
<p>而GFS的大部分的wrokload都是append模式的。这种情况下，gfs可以保证原子性的completes at least once（通过失败之后重复请求等方式）。但还是会有重复的record或者padding这种情况，这需要application自己来检测（chunksum，unique id）。</p>
<h2 id="Implemention"><a href="#Implemention" class="headerlink" title="Implemention"></a>Implemention</h2><p>系统的实现目标是尽可能的减少与master的交互。master会选择一个副本作为primary，同时授予primary 一个60s的lease。在lease有效期内，由primary来决定每个副本mutation的顺序。lease是可以被master 收回或者延长的（heartbeat更新lease）。</p>
<h4 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a>Mutation</h4><p>下图是mutation的顺序图。</p>
<p><img src="https://zhang.nos-eastchina1.126.net/blog/gfs3.png" alt=""></p>
<ol>
<li>client询问master，chunk的location。master会选择一个副本作为primary（授予lease，如果没有的话）</li>
<li>master返回副本的location和primary信息。client会缓存这些信息。直到lease过期，或者副本挂掉。</li>
<li>client将data push到所有副本（任意order，这里可以利用网络结构做优化，pipelining）。</li>
<li>当所有副本收到data之后，client发送写请求给primary。primary会选择一个串行的顺序，并按顺序修改本地data</li>
<li>primary转发写请求到所有副本，另外的副本按同样的顺序修改。</li>
<li>副本返回给primary，表明写入完成</li>
<li>primary回复client。若有错误，client进行重试（3-7）</li>
</ol>
<h4 id="Snapshot"><a href="#Snapshot" class="headerlink" title="Snapshot"></a>Snapshot</h4><p>snapshot操作就是快速copy 一份文件或者目录，并减少对正在进行中的mutation的干扰。GFS利用copy-on-write的方式。当master收到snapshot请求之后，master会立即收回所有相关chunk的lease。</p>
<ol>
<li>snapshout 某一个文件</li>
<li>master回收所有相关chunk的lease（保证后续写操作会和master交互）</li>
<li>log snapshot操作</li>
<li>copy一份这个文件的metadata，指向相同的chunk</li>
<li>延迟到client发起写相关文件的chunk时，master会让chunkserver创建一个新的chunk，并修改metadata指向新的chunk，并授予lease，返回给client。</li>
</ol>
<h4 id="Garbage-Collection"><a href="#Garbage-Collection" class="headerlink" title="Garbage Collection"></a>Garbage Collection</h4><p>当一个文件被删除时，并不会立即删除。master先log 删除操作，然后将这个file修改成特殊的名字(比如.xxx)隐藏起来。在进行垃圾回收的时候才删除那些已经存在了3天以上的隐藏文件（天数是可配置的）。然后通过和chunkserver进行heartbeat通信，将这个信息告诉chunkserver，让chunkserver进行物理删除data。</p>
<p>也就是只要是master所不知道的副本都是garbage。这种lazy 删除的方法，将删除的操作batch到一起，更高效。</p>
<h4 id="Stale-Replica-Detection"><a href="#Stale-Replica-Detection" class="headerlink" title="Stale Replica Detection"></a>Stale Replica Detection</h4><p>chunk的副本还有可能过期。当chunkserver挂掉的时候，有mutation操作的话。所以为每一个chunk，master会维护一个版本号来追踪是否是最新的版本。version number在master授予lease的时候更新。在垃圾回收的时候删除过期的版本。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] The Google File System. SOSP ‘03 </p>
</div></article></div></main><footer><div class="paginator"><a href="/2018/11/02/pebblesdb/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'seansun';
var disqus_identifier = '2018/11/12/gfs/';
var disqus_title = '论文笔记 [SOSP '03] The Google File System';
var disqus_url = 'http://threezj.com/2018/11/12/gfs/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//seansun.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2018 <a href="http://threezj.com">Jian Zhang</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>