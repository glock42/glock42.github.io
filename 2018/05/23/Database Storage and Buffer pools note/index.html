<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Database Storage and Buffer pools note · 一派胡言</title><meta name="description" content="Database Storage and Buffer pools note - Jian Zhang"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://threezj.com/atom.xml" title="一派胡言"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="https://github.com/zyycj" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Database Storage and Buffer pools note</h1><div class="post-info">2018年5月23日</div><div class="post-content"><h2 id="Goals-of-the-DBMS"><a href="#Goals-of-the-DBMS" class="headerlink" title="Goals of the DBMS"></a>Goals of the DBMS</h2><ul>
<li>Allow the DBMS to manage databases that exceed the amount of memory available</li>
<li>Reading/writing to disk is expensive, so it must be managed carefully</li>
</ul>
<p>DBMS总是希望自己来管理所有东西，而不是依靠操作系统</p>
<h2 id="File-Storage"><a href="#File-Storage" class="headerlink" title="File Storage"></a>File Storage</h2><ul>
<li>最简单的形式，一张表存储一个文件。但是也有多个关联的表存在一个文件的实现。</li>
<li>操作系统对于db的文件内容是不关心。</li>
</ul>
<p>每个file由多个page组成，有多种不同的方式来存储，</p>
<ul>
<li>Heap File</li>
<li>Sequential File</li>
<li>Hashing File</li>
<li>Log-Structured File <a id="more"></a>
</li>
</ul>
<h4 id="Heap-File"><a href="#Heap-File" class="headerlink" title="Heap File"></a>Heap File</h4><p>page在文件是无序的可以任意放，一般有两种方式组织</p>
<ul>
<li>Linker List：用两个链表，data list和free list。这种方式在获取某个page的时候用时较长，需要遍历链表。</li>
<li>Page Directory：用一个特殊的page，来存所有page的位置。一般采用这种。</li>
</ul>
<h4 id="Sequential-File"><a href="#Sequential-File" class="headerlink" title="Sequential File"></a>Sequential File</h4><p>所有Tuple是按照某个特定的键（比如主键）排序存放的。在根据特殊键操作表的时候性能会Heap形式要好</p>
<h4 id="Log-Structred"><a href="#Log-Structred" class="headerlink" title="Log-Structred"></a>Log-Structred</h4><p>不存储tuple，只存储log（即insert，delete，update操作）。当查找的时候，反向搜索，recreate一个tuple。插入快，读慢。一般会考虑额外建立索引来维护log，并定期压缩。</p>
<p><img src="http://zhang.nos-eastchina1.126.net/blog/WX20180524-164401.png" alt=""></p>
<h2 id="Database-Page"><a href="#Database-Page" class="headerlink" title="Database Page"></a>Database Page</h2><ul>
<li>单个文件分成多个page，每个page的大小是固定大小的</li>
</ul>
<p>page的存储格式是多样的。为了支持变长的<code>Tuple</code>，一般的存储格式为<code>slotted-page structure</code>如下图。</p>
<p><img src="http://zhang.nos-eastchina1.126.net/blog/WX20180524-162444.png" alt=""> </p>
<p>当中间的Tuple被删除的时候，前面的Tuple需要往后移来对齐。这个移动的性能消耗不是太高，因为一般page大小也就4k。若Tuple过大，超过一个page的大小，一般会考虑采用一个额外的overflow page来保存。</p>
<h2 id="Tuple-layout"><a href="#Tuple-layout" class="headerlink" title="Tuple layout"></a>Tuple layout</h2><p>tuple才是真实的一条记录，即一串二进制序列，由database负责解释。分为两块。</p>
<ul>
<li>header：metadata，每个属性的位置和长度，bitmap来快速发现null属性</li>
<li>data</li>
</ul>
<p><img src="http://zhang.nos-eastchina1.126.net/blog/WX20180524-165218@2x.png" alt=""></p>
<p>目前普遍是按行存的做法，某些情况不是很好，比如应用只需要一行的其中一个数据，但db会将整行都读入，浪费io带宽。也有一些按列存的数据库。比如单个page只存某个属性的数据。</p>
<h2 id="Different-type-of-the-DBMS-in-different-workloads"><a href="#Different-type-of-the-DBMS-in-different-workloads" class="headerlink" title="Different type of the DBMS in different workloads"></a>Different type of the DBMS in different workloads</h2><ul>
<li>OLTP: On-line transaction processing 适合简单增删改操作，事务短，操作快的类型</li>
<li>OLAP: On-line analyitical processing 适合复杂的分析操作，需要运行较长时间。</li>
</ul>
<h2 id="Buffer-pool"><a href="#Buffer-pool" class="headerlink" title="Buffer pool"></a>Buffer pool</h2><p>类似虚拟内存。让database可以管理超出内存大小的数据。也就在内存维护cache，以page为单位，来换入换出。</p>
<ul>
<li>脏页换出需要写入磁盘</li>
<li>pin counter：当有线程在使用这个页的时候，不能换出。</li>
</ul>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><ul>
<li>多个buffer pool，减少锁竞争</li>
<li>根据query plan，进行预读取。</li>
<li>cursor共享。两个不同query，但是可能读取的东西是相同，可以依附于同一个cursor来读，更好利用缓存。</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li>cmu 15445</li>
<li>Database System Concepts 6th Edition</li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2018/06/20/Database join algorithm note/" class="prev">上一篇</a><a href="/2018/04/28/LFS/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'seansun';
var disqus_identifier = '2018/05/23/Database Storage and Buffer pools note/';
var disqus_title = 'Database Storage and Buffer pools note';
var disqus_url = 'http://threezj.com/2018/05/23/Database Storage and Buffer pools note/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//seansun.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2019 <a href="http://threezj.com">Jian Zhang</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>