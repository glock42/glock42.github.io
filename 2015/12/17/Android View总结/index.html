<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Android View总结 · 一派胡言</title><meta name="description" content="Android View总结 - Jian Zhang"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://threezj.com/atom.xml" title="一派胡言"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="https://github.com/zyycj" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Android View总结</h1><div class="post-info">2015年12月17日</div><div class="post-content"><h2 id="关于Android-View控件"><a href="#关于Android-View控件" class="headerlink" title="关于Android View控件"></a>关于Android View控件</h2><p>Android中控件大致被分为两类ViewGroup,View。ViewGroup作为容器管理View。Android视图，是类似于Dom树的架构。父视图负责测量定位绘制等操作。我们经常在用的<code>findViewById</code> 方法代价昂贵的原因，就是因为他负责至上而下遍历整棵控件树，来寻找View实例，在重复操作中尽量少用。现在在用的很多控件都是直接或者间接继承自View的，如下图。</p>
<p><img src="http://ww2.sinaimg.cn/mw690/87dacc16gw1ez2rbxd8lsj20mw0d9wfy.jpg" alt="view 继承树"><br><a id="more"></a></p>
<h2 id="Android-UI界面架构"><a href="#Android-UI界面架构" class="headerlink" title="Android UI界面架构"></a>Android UI界面架构</h2><p>每个Activity包含一个<code>PhoneWindow</code>对象，<code>PhoneWindow</code>设置<code>DecorView</code>为应用窗口的根视图。在里面就是熟悉的<code>TitleView</code>和<code>ContentView</code>,没错，平时使用的<code>setContentView()</code>就是设置的<code>ContentView</code>。</p>
<p><img src="http://hujiaweibujidao.github.io/images/androidheros_ui.png" alt="UI 架构"></p>
<h2 id="Android是如何绘制View的？"><a href="#Android是如何绘制View的？" class="headerlink" title="Android是如何绘制View的？"></a>Android是如何绘制View的？</h2><p>当一个Activity启动时，会被要求绘制出它的布局。Android框架会处理这个请求，当然前提是Activity提供了合理的布局。绘制从根视图开始，从上至下遍历整棵视图树，每一个<code>ViewGroup</code>负责让自己的子<code>View</code>被绘制，每一个<code>View</code>负责绘制自己，通过<code>draw()</code>方法.绘制过程分三步走。</p>
<ul>
<li>Measure</li>
<li>Layout</li>
<li>Draw</li>
</ul>
<p>整个绘制流程是在<code>ViewRoot</code>中的<code>performTraversals()</code>方法展开的。部分源代码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//最外层的根视图的widthMeasureSpec和heightMeasureSpec由来</span></span><br><span class="line">    <span class="comment">//lp.width和lp.height在创建ViewGroup实例时等于MATCH_PARENT</span></span><br><span class="line">    <span class="keyword">int</span> childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);</span><br><span class="line">    <span class="keyword">int</span> childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);</span><br><span class="line">    ......</span><br><span class="line">    mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">    ......</span><br><span class="line">    mView.layout(<span class="number">0</span>, <span class="number">0</span>, mView.getMeasuredWidth(), mView.getMeasuredHeight());</span><br><span class="line">    ......</span><br><span class="line">    mView.draw(canvas);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在绘制之前当然要知道view的尺寸和绘制。所以先进行<code>measu</code>和<code>layout</code>（测量和定位），如下图。</p>
<p><img src="http://hi.csdn.net/attachment/201112/29/0_132516479540V4.gif" alt="绘制流程"></p>
<h2 id="Measure过程"><a href="#Measure过程" class="headerlink" title="Measure过程"></a>Measure过程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//....  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//回调onMeasure()方法    </span></span><br><span class="line">    onMeasure(widthMeasureSpec, heightMeasureSpec);  </span><br><span class="line">     </span><br><span class="line">    <span class="comment">//more  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>计算view的实际大小，获得高宽存入<code>mMeasuredHeight</code>和<code>mMeasureWidth</code>，<code>measure(int, int)</code>传入的两个参数。<code>MeasureSpec</code>是一个32位int值，高2位为测量的模式，低30位为测量的大小。测量的模式可以分为以下三种。</p>
<ul>
<li><p>EXACTLY<br>精确值模式，当<code>layout_width</code>或<code>layout_height</code>指定为具体数值，或者为<code>match_parent</code>时，系统使用EXACTLY。</p>
</li>
<li><p>AT_MOST<br>最大值模式，指定为<code>wrap_content</code>时，控件的尺寸不能超过父控件允许的最大尺寸。</p>
</li>
<li><p>UNSPECIFIED<br>不指定测量模式，View想多大就多大，一般不太使用。</p>
</li>
</ul>
<p>根据上面的源码可知，measure方法不可被重写，自定义时需要重写的是<code>onMeasure</code>方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">        setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</span><br><span class="line">                getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>查看源码可知最终的高宽是调用<code>setMeasuredDimension()</code>设定的,如果不重写，默认是直接调用<code>getDefaultSize</code>获取尺寸的。</p>
<p>使用View的getMeasuredWidth()和getMeasuredHeight()方法来获取View测量的宽高，必须保证这两个方法在onMeasure流程之后被调用才能返回有效值。</p>
<h2 id="Layout过程"><a href="#Layout过程" class="headerlink" title="Layout过程"></a>Layout过程</h2><p>Layout方法就是用来确定view布局的位置，就好像你知道了一件东西的大小以后，总要知道位置才能画上去。</p>
<p><code>mView.layout(0, 0, mView.getMeasuredWidth(), mView.getMeasuredHeight());</code></p>
<p>layout获取四个参数，左，上，右，下坐标，相对于父视图而言。这里可以看到，使用了刚刚测量的宽和高。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldL = mLeft;</span><br><span class="line">    <span class="keyword">int</span> oldT = mTop;</span><br><span class="line">    <span class="keyword">int</span> oldB = mBottom;</span><br><span class="line">    <span class="keyword">int</span> oldR = mRight;</span><br><span class="line">    <span class="keyword">boolean</span> changed = setFrame(l, t, r, b);</span><br><span class="line">    <span class="keyword">if</span> (changed || (mPrivateFlags &amp; LAYOUT_REQUIRED) == LAYOUT_REQUIRED) &#123;</span><br><span class="line">        .....</span><br><span class="line">        onLayout(changed, l, t, r, b);</span><br><span class="line">        .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过<code>setFrame</code>设置坐标。如果坐标改变过了，则重新进行定位。如果是View对象，那么onLayout是个空方法。因为定位是由ViewGroup确定的。</p>
<p>当layout结束以后<code>getWidth()</code>与<code>getHeight()</code>才会返回正确的值。</p>
<p>这里出现一个问题，<code>getWidth/Height()</code> and <code>getMeasuredWidth/Height()</code>有什么区别？  </p>
<ul>
<li><code>getWidth()</code>:View在設定好佈局後整個View的寬度。</li>
<li><code>getMeasuredWidth()</code>:對View上的內容進行測量後得到的View內容佔據的寬度</li>
</ul>
<p><img src="http://img.blog.csdn.net/20141106113343781?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3lfYno=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="getwidth"></p>
<h2 id="Draw过程"><a href="#Draw过程" class="headerlink" title="Draw过程"></a>Draw过程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Draw traversal performs several drawing steps which must be executed</span></span><br><span class="line"><span class="comment">         * in the appropriate order:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *      1. Draw the background</span></span><br><span class="line"><span class="comment">         *      2. If necessary, save the canvas' layers to prepare for fading</span></span><br><span class="line"><span class="comment">         *      3. Draw view's content</span></span><br><span class="line"><span class="comment">         *      4. Draw children</span></span><br><span class="line"><span class="comment">         *      5. If necessary, draw the fading edges and restore layers</span></span><br><span class="line"><span class="comment">         *      6. Draw decorations (scrollbars for instance)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step 1, draw the background, if needed</span></span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (!dirtyOpaque) &#123;</span><br><span class="line">            drawBackground(canvas);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// skip step 2 &amp; 5 if possible (common case)</span></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step 2, save the canvas' layers</span></span><br><span class="line">        ......</span><br><span class="line">            <span class="keyword">if</span> (drawTop) &#123;</span><br><span class="line">                canvas.saveLayer(left, top, right, top + length, <span class="keyword">null</span>, flags);</span><br><span class="line">            &#125;</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step 3, draw the content</span></span><br><span class="line">        <span class="keyword">if</span> (!dirtyOpaque) onDraw(canvas);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step 4, draw the children</span></span><br><span class="line">        dispatchDraw(canvas);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step 5, draw the fade effect and restore layers</span></span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (drawTop) &#123;</span><br><span class="line">            matrix.setScale(<span class="number">1</span>, fadeHeight * topFadeStrength);</span><br><span class="line">            matrix.postTranslate(left, top);</span><br><span class="line">            fade.setLocalMatrix(matrix);</span><br><span class="line">            p.setShader(fade);</span><br><span class="line">            canvas.drawRect(left, top, right, top + length, p);</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step 6, draw decorations (scrollbars)</span></span><br><span class="line">        onDrawScrollBars(canvas);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>重点是第三步调用onDraw方法。其它几步都是绘制一些边边角角的东西比如背景、scrollBar之类的。其中<code>dispatchDraw</code>，是用来递归调用子View,如果没有则不需要。</p>
<p>onDraw方法是需要自己实现的，因为每个控件绘制的内容不同。主要用canvas对象进行绘制，这里就不说了。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="http://blog.csdn.net/guolin_blog/article/details/16330267" target="_blank" rel="noopener">Android视图绘制流程完全解析，带你一步步深入了解View(二)</a></li>
<li><a href="http://blog.csdn.net/yanbober/article/details/46128379" target="_blank" rel="noopener">Android应用层View绘制流程与源码分析</a></li>
<li><a href="http://developer.android.com/intl/zh-cn/guide/topics/ui/how-android-draws.html" target="_blank" rel="noopener">How Android Draws Views</a></li>
<li><a href="http://www.amazon.cn/Android%E7%BE%A4%E8%8B%B1%E4%BC%A0-%E5%BE%90%E5%AE%9C%E7%94%9F/dp/B01481RAA4/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1450359477&amp;sr=1-1&amp;keywords=android%E7%BE%A4%E8%8B%B1%E4%BC%A0" target="_blank" rel="noopener">《Android群英传》</a></li>
<li><a href="http://stackoverflow.com/questions/8657540/what-is-the-difference-between-getwidth-height-and-getmeasuredwidth-height-i" target="_blank" rel="noopener">What is the difference between getWidth/Height() and getMeasuredWidth/Height() in Android SDK?</a></li>
</ol>
</div></article></div></main><footer><div class="paginator"><a href="/2016/01/23/Android Handler Looper Message 详细分析/" class="prev">上一篇</a><a href="/2015/10/14/Android Studio莫名奇妙错误系列/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'seansun';
var disqus_identifier = '2015/12/17/Android View总结/';
var disqus_title = 'Android View总结';
var disqus_url = 'http://threezj.com/2015/12/17/Android View总结/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//seansun.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2018 <a href="http://threezj.com">Jian Zhang</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>